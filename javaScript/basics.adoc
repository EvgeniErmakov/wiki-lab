:imagesdir: ../assets/img/javascript

= Основы JavaScript

*JavaScript* — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. *JavaScript* обычно используется как встраиваемый язык для программного доступа к объектам приложений. Наиболее широкое применение находит в браузерах как язык сценариев для придания интерактивности веб-страницам.

*JavaScript* является интерпретируемым языком, это означает, что код на языке *JavaScript* выполняется с помощью *интерпретатора*. Он получает инструкции языка *JavaScript*, которые определены на веб-странице, выполняет их (или интерпретирует).

== Основы синтаксиса javascript

Прежде чем переходить к детальному изучению основ языка программирования *javascript*, рассмотрим некоторые базовые моменты его синтаксиса.

Код *javascript* состоит из инструкций, каждая из которых завершается точкой запятой:

[source, javascript]
----
alert("Вычисление выражения"); var a = 5 + 8; alert(a);
----

Однако современные браузеры вполне могут различать отдельные инструкции, если они просто располагаются на отдельных строках без точки запятой:

[source, javascript]
----
alert("Вычисление выражения")
var a = 5 + 8
alert(a)
----

Но чтобы улучшить читабельность кода и снизить число возможных ошибок, рекомендуется определять каждую инструкцию *javascript* на отдельной строчке и завершать ее точкой с запятой, как в первом варианте.

В коде *javascript* могут использоваться *комментарии*, они не обрабатываются интерпретатором *javascript* и никак не учитываются в работе программы. Комментарии предназначен для ориентации по коду, чтобы указать, что делает тот или иной код.

*Комментарии* могут быть *однострочными*, для которых используется двойной слеш `//`:

[source, javascript]
----
// вывод сообщения
alert("Вычисление выражения");
// арифметическая операция
var a = 5 + 8;
alert(a);
----

Кроме однострочных комментариев могут использоваться и *многострочные*. Такие комментарии заключаются между символами `/* текст комментария */`. Например:

[source, javascript]
----
// вывод сообщения
/*  вывод сообщения и
 арифметическая операция */
alert("Вычисление выражения");
var a = 5 + 8;
alert(a);
----

== Переменные и константы

Для хранения данных в программе используются *переменные*, они предназначены для хранения каких-нибудь временных данных или таких данных, которые в процессе работы могут менять свое значение.

Для создания переменных применяются ключевые слова `var` и `let`. Например, объявим переменную `myIncome`:

[source, javascript]
----
var myIncome;
// другой вариант
let myIncome2;
----

Каждая переменная имеет *имя*, оно представляет собой произвольный набор алфавитно-цифровых символов, знака подчеркивания `_` или знака доллара `$`, причем названия не должны начинаться с цифровых символов. То есть можно использовать в названии буквы, цифры, подчеркивание. Однако все остальные символы запрещены.

*Например*, правильные названия переменных:

[source, javascript]
----
$commision
someVariable
product_Store
income2
myIncome_from_deposit
----

Следующие названия являются некорректными и не могут использоваться:

[source, javascript]
----
222lol
@someVariable
my%percent
----

Также нельзя давать переменным такие имена, которые совпадают с зарезервированными ключевыми словами. В *JavaScript* не так много ключевых слов, поэтому данное правило не сложно соблюдать. Например, следующее название будет некорректным, так как `for` - ключевое слово в *JavaScript*:

[source, javascript]
----
var for;
----

*Список зарезервированных слов в JavaScript:*

`abstract, boolean, break, byte, case, catch, char, class, const, continue, debugger, default, delete, do, double, else, enum, export, extends, false, final, finally, float, for, function, goto, if, implements, import, in, instanceof, int, inteface, long, native, new, null, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, true, try, typeof, var, volatile, void, while, with`

При названии переменных надо учитывать, что *JavaScript* является регистрозависимым языком, то есть в следующем коде объявлены две разные переменные:

[source, javascript]
----
var myIncome;
var MyIncome;
----

Через запятую можно определить сразу несколько переменных:

[source, javascript]
----
var myIncome, procent, sum;
let a, b, c;
----

С помощью знака равно `=` можно присвоить переменной какое-либо значение:

[source, javascript]
----
var income = 300;
let price = 76;
----

Процесс присвоения переменной начального значения называется *инициализацией*. Теперь переменная `income` будет хранить число 300, а переменная `price` - число 76. Отличительной чертой переменных является то, что можно изменить их значение:

[source, javascript]
----

var income = 300;
income = 400;
console.log(income);

let price = 76;
price = 54;
console.log(price);
----

=== Константы

С помощью ключевого слова `const` можно определить константу, которая, как и переменная, хранит значение, однако это значение не может быть изменено.

[source, javascript]
----
const rate = 10;
----

Если попробовать изменить ее значение, то возникнет ошибка:

[source, javascript]
----
const rate = 10;
rate = 23;  // ошибка, rate - константа, поэтому  нельзя изменить ее значение
----

Также стоит отметить, что поскольку нельзя изменить значение константы, то она должна быть инициализирована, то есть при ее определении необходимо предоставить ей начальное значение. Если этого не сделать, возникнет ошибка:

[source, javascript]
----
const rate; // ошибка, rate не инициализирована
----

== Типы данных

Все используемые данные в *javascript* имеют определенный тип. В *JavaScript* имеется *пять примитивных* типов данных:

* `String:` представляет строку

* `Number:` представляет числовое значение

* `Boolean:` представляет логическое значение *true* или *false*

* `undefined:` указывает, что значение не установлено

* `null:` указывает на неопределенное значение

Все данные, которые не попадают под вышеперечисленные пять типов, относятся к типу *object*.

=== Числовые данные

Числа в *JavaScript* могут иметь две формы:

* Целые числа, например, 35. Можно использовать как положительные, так и отрицательные числа. Диапазон используемых чисел: *от* `-2^53` *до* `2^53`.

* Дробные числа (числа с плавающей точкой), например, *3.5575*. Опять же можно использовать как положительные, так и отрицательные числа. Для чисел с плавающей точкой используется тот же диапазон: *от* `-2^53` *до* `2^53`.

*Например:*

[source, javascript]
----
var x = 45;
var y = 23.897;
----

В качестве разделителя между целой и дробной частями, как и в других языках программирования, используется точка.

=== *Строки*

Тип `string` представляет строки, то есть такие данные, которые заключены в кавычки. Например, *"Привет мир"*. Причем можно использовать как двойные, так и одинарные кавычки: *"Привет мир"* и *'Привет мир'*. Единственно ограничение: тип закрывающей кавычки должен быть тот же, что и тип открывающей, то есть либо обе двойные, либо обе одинарные.

Если внутри строки встречаются кавычки, то их нужно экранировать слешем `\`. Например, пусть у нас есть текст *"Бюро "Рога и копыта"*. Теперь экранируем кавычки:

[source, javascript]
----
var companyName = "Бюро \"Рога и копыта\"
----

Также можно внутри стоки использовать другой тип кавычек:

[source, javascript]
----
var companyName1 = "Бюро 'Рога и копыта'";
var companyName2 = 'Бюро "Рога и копыта"';
----

=== Тип Boolean

Тип Boolean представляет булевые или логические значения `true` и `false` (то есть да или нет):

[source, javascript]
----
var isAlive = true;
var isDead = false;
----

=== null и undefined

Нередко возникает путаница между `null` и `undefined`. Итак, когда только определяется переменная без присвоения ей начального значения, она представляет тип `undefined`:

[source, javascript]
----
var isAlive;
console.log(isAlive); // выведет undefined
----

Присвоение значение `null` означает, что переменная имеет некоторое неопределенное значение (не число, не строка, не логическое значение), но все-таки имеет значение (`undefined` означает, что переменная не имеет значения):

[source, javascript]
----
var isAlive;
console.log(isAlive); // undefined
isAlive = null;
console.log(isAlive); // null
isAlive = undefined;  // снова установим тип undefined
console.log(isAlive); // undefined
----

=== object

Тип `object` представляет сложный объект. Простейшее определение объекта представляют фигурные скобки:

[source, javascript]
----
var user = {};
----

Объект может иметь различные свойства и методы:

[source, javascript]
----
var user = {name: "Tom", age:24};
console.log(user.name);
----

В данном случае объект называется `user`, и он имеет два свойства: `name` и `age`. Это краткое описание объектов, более подробное описание приводится в соответствующей главе.

=== Слабая типизация

*JavaScript* является языком со слабой типизацией. Это значит, что переменные могут динамически менять тип. *Например:*

[source, javascript]
----
var xNumber;  // тип undefined
console.log(xNumber);
xNumber = 45;  // тип number
console.log(xNumber);
xNumber = "45"; // тип string
console.log(xNumber);
----

Несмотря на то, что во втором и третьем случае консоль выведет число 45, но во втором случае переменная `xNumber` будет представлять число, а в третьем случае - строку.

Это важный момент, который надо учитывать и от которого зависит поведение переменной в программе:

[source, javascript]
----
var xNumber = 45;  // тип number
var yNumber = xNumber + 5;
console.log(yNumber); // 50

xNumber = "45"; // тип string
var zNumber = xNumber + 5
console.log(zNumber); // 455
----

Выше в обоих случая к переменной `xNumber` применяется операция сложения `+`. Но в первом случае `xNumber` представляет число, поэтому результатом операции `xNumber + 5` будет число 50.

Во втором случае `xNumber` представляет строку. Но операция сложения между строкой и числом 5 невозможна. Поэтому число 5 будет преобразовываться к строке, и будет происходить операция объединения строк. И результатом выражения `xNumber + 5` будет стока "455".

=== Оператор `typeof`

С помощью оператора `typeof` можно получить тип переменной:

[source, javascript]
----
var name = "Tom";
console.log(typeof name); // string

var income = 45.8;
console.log(typeof income); // number

var isEnabled = true;
console.log(typeof isEnabled); // boolean

var undefVariable;
console.log(typeof undefVariable); // undefined
----

== Операции с переменными
=== Математические операции

`JavaScript` поддерживает все базовые математические операции:

* *Сложение:*

[source, javascript]
----
var x = 10;
var y = x + 50;
----

* *Вычитание:*

[source, javascript]
----
var x = 100;
var y = x - 50;
----

* *Умножение:*

[source, javascript]
----
var x = 4;
var y = 5;
var z = x * y;
----

* *Деление:*

[source, javascript]
----
var x = 40;
var y = 5;
var z = x / y;
----

* *Деление по модулю* (оператор %) возвращает остаток от деления:

[source, javascript]
----
var x = 40;
var y = 7;
var z = x % y;
console.log(z); // 5
----

Результатом будет 5, так как наибольшее целое число, которое меньше или равно 40 и при этом делится на 7 равно 35, а 40 - 35 = 5.

* *Инкремент:*

[source, javascript]
----
var x = 5;
x++; // x = 6
----

Оператор инкремента `++` увеличивает переменную на единицу. Существует префиксный инкремент, который сначала увеличивает переменную на единицу, а затем возвращает ее значение. И есть постфиксный инкремент, который сначала возвращает значение переменной, а затем увеличивает его на единицу:

[source, javascript]
----
// префиксный инкремент
var x = 5;
var z = ++x;
console.log(x); // 6
console.log(z); // 6

// постфиксный инкремент
var a = 5;
var b = a++;
console.log(a); // 6
console.log(b); // 5
----

* *Постфиксный инкремент аналогичен операции:*

[source, javascript]
----
a = a + 1; // a++
----

Декремент уменьшает значение переменной на единицу. Также есть префиксный и постфиксный декремент:

[source, javascript]
----
// префиксный декремент
var x = 5;
var z = --x;
console.log(x); // 4
console.log(z); // 4

// постфиксный декремент
var a = 5;
var b = a--;
console.log(a); // 4
console.log(b); // 5
----

Как и принято в математике, все операции выполняются слева направо и различаются по приоритетам: сначала операции инкремента и декремента, затем выполняются умножение и деление, а потом сложение и вычитание. Чтобы изменить стандартный ход выполнения операций, часть выражений можно поместить в скобки:

[source, javascript]
----
var x = 10;
var y = 5 + (6 - 2) * --x;
console.log(y); //41
----

=== Операции присваивания

* `=`

*Приравнивает* переменной определенное значение: `var x = 5`;

* `+=`

*Сложение* с последующим присвоением результата. *Например:*

[source, javascript]
----
var a = 23;
a += 5; // аналогично a = a + 5
console.log(a); // 28
----

* `-=`

*Вычитание* с последующим присвоением результата. *Например:*

[source, javascript]
----
var a = 28;
a -= 10; // аналогично a = a - 10
console.log(a); // 18
----

* `*=`

*Умножение* с последующим присвоением результата:

[source, javascript]
----
var x = 20;
x *= 2; // аналогично x = x * 2
console.log(x); // 40
----

* `/=`

*Деление* с последующим присвоением результата:

[source, javascript]
----
var x = 40;
x /= 4; // аналогично x = x / 4
console.log(x); // 10
----

* `%=`

*Получение остатка от деления* с последующим присвоением результата:

[source, javascript]
----
var x = 10;
x %= 3; // аналогично x = x % 3
console.log(x); // 1, так как 10 - 3*3 = 1
----

=== Операторы сравнения

Как правило, для проверки условия используются операторы сравнения. Операторы сравнения сравнивают два значения и возвращают значение *true* или *false*:

* `==`

Оператор равенства сравнивает два значения, и если они равны, возвращает *true*, иначе возвращает *false*: `x == 5`

* `===`

Оператор тождественности также сравнивает два значения и их тип, и если они равны, возвращает *true*, иначе возвращает *false*: `x === 5`

* `!=`

Сравнивает два значения, и если они не равны, возвращает *true*, иначе возвращает`*false*: `x != 5`

* `!==`

Сравнивает два значения и их типы, и если они не равны, возвращает *true*, иначе возвращает *false*: `x !== 5`

* `>`

Сравнивает два значения, и если первое больше второго, то возвращает *true*, иначе возвращает *false*: `x > 5`

* `<`

Сравнивает два значения, и если первое меньше второго, то возвращает *true*, иначе возвращает *false*: `x < 5`

* `>=`

Сравнивает два значения, и если первое больше или равно второму, то возвращает *true*, иначе возвращает *false*: `x >= 5`

* `<=`

Сравнивает два значения, и если первое меньше или равно второму, то возвращает *true*, иначе возвращает *false*: `x <= 5`

Все операторы довольно просты, наверное, за исключением оператора равенства и оператора тождественности. Они оба сравнивают два значения, но оператор тождественности также принимает во внимание и тип значения. *Например:*

[source, javascript]
----
var income = 100;
var strIncome = "100";
var result = income == strIncome;
console.log(result); //true
----

Переменная `result` здесь будет равна *true*, так как фактически и `income`, и `strIncome` представляют число 100.

Но оператор тождественности возвратит в этом случае *false*, так как данные имеют разные тип:

[source, javascript]
----
var income = 100;
var strIncome = "100";
var result = income === strIncome;
console.log(result); // false
----

Аналогично работают операторы неравенства `!=` и `!==`.

=== Логические операции

*Логические операции* применяются для объединения результатов двух операций сравнения. В *JavaScript* есть следующие логические операции:

* `&&`

Возвращает *true*, если обе операции сравнения возвращают *true*, иначе возвращает *false*:

[source, javascript]
----
var income = 100;
var percent = 10;
var result = income > 50 && percent < 12;
console.log(result); //true
----

* `||`

Возвращает *true*, если хотя бы одна операция сравнения возвращают *true*, иначе возвращает *false*:

[source, javascript]
----
var income = 100;
var isDeposit = true;
var result = income > 50 || isDeposit == true;
console.log(result); //true
----

* `!`

Возвращает *true*, если операция сравнения возвращает *false*:

[source, javascript]
----
var income = 100;
var result1 = !(income > 50);
console.log(result1); // false, так как income > 50 возвращает true

var isDeposit = false;
var result2 = !isDeposit;
console.log(result2); // true
----

=== Операции со строками

Строки могут использовать оператор `+` для объединения. *Например:*

[source, javascript]
----
var name = "Том";
var surname = "Сойер"
var fullname = name + " " + surname;
console.log(fullname); //Том Сойер
----

Если одно из выражений представляет строку, а другое - число, то число преобразуется к строке и выполняется операция объединения строк:

[source, javascript]
----
var name = "Том";
var fullname = name + 256;
console.log(fullname); //Том256
----

В конце напишем небольшую программу, которая продемонстрирует работу с операциями над переменными.

[source, html]
----
<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8" />
    <title>JavaScript</title>
</head>
<body>
    <script>
        var sum = 500; // сумма вклада
        var percent = 10;  // процент по вкладу
        var income = sum * percent / 100;  // доход по вкладу
        sum = sum + income; // определяем новую сумму
        console.log("Доход по вкладу: " + income);
        console.log("Сумма вклада после первого года: " + sum);
    </script>
</body>
</html>
----

В скрипте объявляются три переменных: `sum`, `percent` и `income`. Переменная `income` вычисляется по остальным двум переменным с помощью операций умножения и деления. И в конце ее значение суммируется с значением переменной `sum`.

*И консоль браузера выведет:*

image::operations-with-variables.png[архитектура http протокола, align=center]

== Преобразование данных

Нередко возникает необходимость преобразовать одни данные в другие. Например:

[source, javascript]
----
var number1 = "46";
var number2 = "4";
var result = number1 + number2;
console.log(result); //464
----

Обе переменных представляют строки, а точнее строковые представления чисел. И в итоге получим не число 50, а строку 464. Но было бы неплохо, если бы их тоже можно было бы складывать, вычитать, в общем работать как с обычными числами.

В этом случае можно использовать операции преобразования. Для преобразования строки в число применяется функция `parseInt()`:

[source, javascript]
----
var number1 = "46";
var number2 = "4";
var result = parseInt(number1) + parseInt(number2);
console.log(result); // 50
----

Для преобразования строк в дробные числа применяется функция `parseFloat()`:

[source, javascript]
----
var number1 = "46.07";
var number2 = "4.98";
var result = parseFloat(number1) + parseFloat(number2);
console.log(result); //51.05
----

При этом строка может иметь смешанное содержимое, например, *"123hello"*, то есть в данном случае есть цифры, но есть и обычные символы. Но метод `parseInt()` все равно попытается выполнить преобразование:

[source, javascript]
----
var num1 = "123hello";
var num2 = parseInt(num1);
console.log(num2); // 123
----

Если методу не удастся выполнить преобразование, то он возвращает значение `NaN (Not a Number)`, которое говорит о том, что строка не представляет число и не может быть преобразована.

С помощью специальной функции `isNaN()` можно проверить, представляет ли строка число. Если строка не является числом, то функция возвращает *true*, если это число - то *false*:

[source, javascript]
----
var num1 = "javascript";
var num2 = "22";
var result = isNaN(num1);
console.log(result); // true - num1 не является числом

result = isNaN(num2);
console.log(result); //  false - num2 - это число
----

Выше был расмотрен перевод строк в числа в десятичной системе. Однако можно переводить числа в любую систему. По умолчанию интерпретатор *JavaScript* сам отгадывает, в число из какой системы исчисления хотели преобразовать строку (как правило, выбирается десятичная система). Но можно с помощью второго параметра явно указать, что хотим преобразовать строку в число в определенной системе. Например, преобразование в число в двоичной системе:

[source, javascript]
----
var num1 = "110";
var num2 = parseInt(num1, 2);
console.log(num2); // 6
----

Результатом будет 6, так как 110 в двоичной системе - это число 6 в десятичной.

Теперь напишем небольшую программу, в которой используем операции с переменными:

[source, html]
----
<!DOCTYPE html>
    <html>
        <head>
        <meta charset="utf-8" />
        <title>JavaScript</title>
        </head>
    <body>
        <script>
            var strSum = prompt("Введите сумму вклада", 1000);
            var strPercent = prompt("Введите процентную ставку", 10);
            var sum = parseInt(strSum);
            var procent = parseInt(strPercent);
            sum = sum + sum * procent / 100;
            alert("После начисления процентов сумма вклада составит: " + sum);
        </script>
    </body>
</html>
----

С помощью функции `prompt()` в браузере выводится диалоговое окно с предложением ввести некоторое значение. Второй аргумент в этой функции указывает на значение, которое будет использоваться по умолчанию.

Однако функция `prompt()` возвращает строку. Поэтому эту строку необходимо преобразовать в число, чтобы выполнить с ней операции.

После открытия страницы в браузере увидим приглашение к вводу суммы вклада:

image::invitation-enter-deposit-amount.png[архитектура http протокола, align=center]

Затем подобное сообщение отобразится и для ввода процента. И в конце программа получит данные, преобразует их в числа и выполнит подсчет:

image::counting-results.png[архитектура http протокола, align=center]

== Массивы

Для работы с наборами данных предназначены *массивы*. Для создания массива применяется выражение `new Array()`:

[source, javascript]
----
var myArray = new Array();
----

Существует также более короткий способ инициализации массива:

[source, javascript]
----
var myArray = [];
----

В данном случае создаётся пустой массив. Но можно также добавить в него начальные данные:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people);
----

В этом случае в массиве `myArray` будет три элемента. Графически его можно представить так:

Для обращения к отдельным элементам массива используются индексы. Отсчет начинается с нуля, то есть первый элемент будет иметь индекс *0*, а последний - *2*:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[0]); // Tom
var person3 = people[2]; // Sam
console.log(person3); // Sam
----

Если попробовать обратиться к элементу по индексу больше размера массива, то получим `undefined`:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[7]); // undefined
----

Также по индексу осуществляется установка значений для элементов массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[0]); // Tom
people[0] = "Bob";
console.log(people[0]); // Bob
----

Причем в отличие от других языков, как _C#_ или _Java_, можно установить элемент, который изначально не установлен:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[7]); // undefined - в массиве только три элемента
people[7] = "Bob";
console.log(people[7]); // Bob
----
Также стоит отметить, что в отличие от ряда языков программирования в *JavaScript* массивы не являются строго типизированными, один массив может хранить данные разных типов:
[source, javascript]
----
var objects = ["Tom", 12, true, 3.14, false];
console.log(objects);
----

=== spread-оператор

`spread-оператор...` позволяет взять значения из массива по отдельности:

[source, javascript]
----
let numbers = [1, 2, 3, 4];
console.log(...numbers);    // 1 2 3 4
console.log(numbers);       // [1, 2, 3, 4]
----

`spread-оператор` указывается перед массивом. В результате выражение `...numbers` возвратит набор чисел, но это будет не массив, а именно отедльные значения.

=== Многомерные массивы

Массивы могут быть одномерными и многомерными. Каждый элемент в многомерном массиве может представлять собой отдельный массив. Выше рассмотрели одномерный массив, теперь создадим многомерный массив:

[source, javascript]
----
var numbers1 = [0, 1, 2, 3, 4, 5 ]; // одномерный массив
var numbers2 = [[0, 1, 2], [3, 4, 5] ]; // двумерный массив
----

Визуально оба массива можно представить следующим образом:

.Одномерный массив numbers1
|===
|0|1|2|3|4|5
|===

.Двухмерный массив numbers2
|===
|0|1|2
|3|4|5
|===

Поскольку массив `numbers2` двухмерный, он представляет собой простую таблицу. Каждый его элемент может представлять отдельный массив.

Рассмотрим еще один двумерный массив:

[source, javascript]
----
var people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];

console.log(people[0]); // ["Tom", 25, false]
console.log(people[1]); // ["Bill", 38, true]
----

Массив `people` можно представить в виде следующей таблицы:

|===
|Tom|25|false
|Bill|38|true
|Alice|21|false
|===

Чтобы получить отдельный элемент массива, также используется индекс:

[source, javascript]
----
var tomInfo = people[0];
----
Только теперь переменная `tomInfo` будет представлять массив. Чтобы получить элемент внутри вложенного массива, необходимо использовать его вторую размерность:

[source, javascript]
----
console.log("Имя: " + people[0][0]); // Tom
console.log("Возраст: " + people[0][1]); // 25
----
То есть если визуально двумерный массив можемно представить в виде таблицы, то элемент `people[0][1]` будет ссылаться на ячейку таблицы, которая находится на пересечении первой строки и второго столбца (первая размерность - *0* - *строка*, вторая размерность - *1* - *столбец*).

Также можно выполнить присвоение:

[source, javascript]
----
var people = [
["Tom", 25, false],
["Bill", 38, true],
["Alice", 21, false]
];
people[0][1] = 56; // присваиваем отдельное значение
console.log(people[0][1]); // 56

people[1] = ["Bob", 29, false]; // присваиваем массив
console.log(people[1][0]); // Bob
----

При создании многомерных массивов не ограничены только двумерными, но также можем использовать массивы больших размерностей:

[source, javascript]
----
var numbers = [];
numbers[0] = []; // теперь numbers - двумерный массив
numbers[0][0]=[]; // теперь numbers - трехмерный массив
numbers[0][0][0] = 5; // первый элемент трехмерного массива равен 5
console.log(numbers[0][0][0]);
----

== Условные конструкции

Условные конструкции позволяют выполнить те или иные действия в зависимости от определенных условий.

=== *Выражение `if`*

Конструкция `if` проверяет некоторое условие и если это условие верно, то выполняет некоторые действия. Общая форма конструкции `if`:

[source, javascript]
----
if(условие) действия;
----

*Например:*

[source, javascript]
----
var income = 100;
if(income > 50) alert("доход больше 50");
----

Здесь в конструкции `if` используется следующее условие: `income > 50`. Если это условие возвращает *true*, то есть переменная `income` имеет значение больше 50, то браузер отображает сообщение. Если же значение `income` меньше 50, то никакого сообщения не отображается.

Если необходимо выполнить по условию набор инструкций, то они помещаются в блок из фигурных скобок:

[source, javascript]
----
var income = 100;
if(income > 50){

    var message = "доход больше 50";
    alert(message);
}
----

Причем условия могут быть сложными:

[source, javascript]
----
var income = 100;
var age = 19;
if(income < 150 && age > 18){

    var message = "доход больше 50";
    alert(message);
}
----

Конструкция `if` позволяет проверить наличие значения. *Например:*

[source, javascript]
----
var myVar = 89;
if(myVar){
// действия
----

Если переменная `myVar` имеет значение, то в условной конструкции она возвратит значение *true*.

Но нередко для проверки значения переменной используют альтернативный вариант - проверяют на значение `undefined`:

[source, javascript]
----
if (typeof myVar != "undefined") {
// действия
}
----

В конструкции `if` также можно использовать блок `else`. Данный блок содержит инструкции, которые выполняются, если условие после `if` ложно, то есть равно *false*:

[source, javascript]
----
var age = 17;
if(age >= 18){

    alert("Вы допущены к программе кредитования");
}
else{
    alert("Вы не можете участвовать в программе, так как возраст меньше 18");
}

----
С помощью конструкции `else if`  можно добавить альтернативное условие к блоку `if`:

[source, javascript]
----
var income = 300;
if(income < 200){

    alert("Доход ниже среднего");
}
else if(income >= 200 && income <= 400){

    alert("Средний доход");
}
else{

    alert("Доход выше среднего");
}
----

В данном случае выполнится блок `else if`. При необходимости можно использовать несколько блоков `else if` с разными условиями:

[source, javascript]
----
if(income < 200){

    alert("Доход ниже среднего");
}
else if(income>=200 && income<300){

    alert("Чуть ниже среднего");
}
else if(income>=300 && income<400){

    alert("Средний доход");
}
else{
    alert("Доход выше среднего");
}
----

=== *True или false*

В *javascript* любая переменная может применяться в условных выражениях, но не любая переменная представляет тип `boolean`. И в этой связи возникает вопрос, что возвратит та или иная переменная - *true* или *false*? Много зависит от типа данных, который представляет переменная:

* `undefined`

Возвращает *false*

* `null`

Возвращает *false*

* `Boolean`

Если переменная равна *false*, то возвращается *false*. Соответствено если переменная равна *true*, то возвращается *true*

* `Number`

Возвращает *false*, если число равно *0* или *NaN (Not a Number)*, в остальных случаях возвращается *true*

Например, следующая переменная будет возращать *false*:

[source, javascript]
----
var x = NaN;
if(x){  // false

}
----

* `String`

Возвращает *false*, если переменная равна пустой строке, то есть ее длина равна 0, в остальных случаях возвращается true

[source, javascript]
----
var y = ""; // false - так как пустая строка
var z = "javascript";   // true - строка не пустая
----

*  `Object`

Всегда возвращает *true*

[source, javascript]
----
var user = {name:"Tom"};    // true
var isEnabled = new Boolean(false)  // true
var car = {}    // true
----

=== Конструкция `switch..case`

Конструкция `switch..case` является альтернативой использованию конструкции `if..else if..else` и также позволяет обработать сразу несколько условий:

[source, javascript]
----
var income = 300;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 300 :
        console.log("Доход равен 300");
        break;
}
----

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.

В конце каждого блока сase ставится оператор `break`, чтобы избежать выполнения других блоков.

Если есть необходимость обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`:

[source, javascript]
----
var income = 300;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 300 :
        console.log("Доход равен 300");
        break;
    default:
        console.log("Доход неизвестной величины");
        break;
}
----

=== Тернарная операция

*Тернарная операция* состоит из трех операндов и имеет следующее определение:

`[первый операнд - условие] *?* [второй операнд] *:* [третий операнд]`

В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно *true*, то возвращается второй операнд; если условие равно *false*, то третий. Например:

[source, javascript]
----
var a = 1;
var b = 2;
var result = a < b ? a + b : a - b;
console.log(result); // 3
----

Если значение переменной `a` меньше значения переменной `b`, то переменная `result` будет равняться `a + b`. Иначе значение `result` будет равняться `a - b`.

== Циклы

Циклы позволяют в зависимости от определенных условий выполнять некоторое действие множество раз. В *JavaScript* имеются следующие виды циклов:

`for`

`for..in`

`for..of`

`while`

`do..while`

=== *Цикл for*

Цикл `for` имеет следующее формальное определение:

[source, javascript]
----
for ([инициализация счетчика]; [условие]; [изменение счетчика]){

    // действия
}
----

Например, используем цикл `for` для перебора элементов массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for(var i = 0; i<people.length; i++){

    console.log(people[i]);
}
----

Первая часть объявления цикла - `var i = 0` - создает и инициализирует счетчик - переменную `i`. И перед выполнением цикла ее значение будет равно *0*. По сути это то же самое, что и объявление переменной.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока значение `i` не достигнет величины, равной длине массива `people`. Получить длину массива можно с помощью свойства `length: people.length`.

Третья часть - приращение счетчика на единицу.

И так как в массиве 4 элемента, то блок цикла сработает 4 раза, пока значение `i` не станет равным `people.length` (то есть 4). И каждый раз это значение будет увеличиваться на 1. Каждое отдельное повторение цикла называется итерацией. Таким образом, в данном случае сработают 4 итерации.

А с помощью выражения `people[i]` сможно получить элемент массива для его последующего вывода в браузере.

Необязательно увеличивать счетчик на единицу, можно производить с ним другие действия, например, уменьшать на единицу:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for(var i = people.length - 1; i >= 0; i--){

    console.log(people[i]);
}
----

В данном случае массив выводится с конца, а перебор массива начинается с i = 3 до i = 0.

=== Цикл `for..in`

Цикл `for..in` предназначен для перебора массивов и объектов. Его формальное определение:

[source, javascript]
----
for (индекс in массив) {
// действия
----

Например, переберем элементы массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for(var index in people){

    console.log(people[index]);
}
----

=== Цикл `for...of`

Цикл `for...of` похож на цикл `for...in` и предназначен для перебора коллекций, например, массивов:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
for(let val of users)
console.log(val);
----

Текущий перебираемый элемент коллекции помещается в переменную `val`, значение которой затем выводится на консоль.

=== Цикл `while`

Цикл `while` выполняется до тех пор, пока некоторое условие истинно. Его формальное определение:

[source, javascript]
----
while(условие){

    // действия
}
----

Опять же выведем с помощью `while` элементы массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
var index = 0;
while(index < people.length){

    console.log(people[index]);
    index++;
}
----

Цикл `while` здесь будет выполняться, пока значение index не станет равным длине массива.

=== Цикл `do..while`

В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие истинно, цикл повторяется. *Например:*

[source, javascript]
----
var x = 1;
do{
console.log(x * x);
x++;
}while(x < 10)
----

Здесь код цикла сработает 9 раз, пока x не станет равным 10. При этом цикл `do` гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции `while` не будет истинно.

=== Операторы `continue` и `break`

Иногда бывает необходимо выйти из цикла до его завершения. В этом случае можно воспользоваться оператором `break`:

[source, javascript]
----
var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
for (var i = 0; i < array.length; i++)
{
if (array[i] > 10)
break;
document.write(array[i] + "</br>");
}
----

Данный цикл перебирает все элементы массива, однако последние четыре элемента не будут выведены в браузере, поскольку поверка if (array[i] > 10) прервет выполнение цикла с помощью оператора `break`, когда перебор массива дойдет до элемента 12.

Если необходимо просто пропустить итерацию, но не выходить из цикла, можно применять оператор `continue`.

[source, javascript]
----
var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
for (var i = 0; i < array.length; i++)
{
if (array[i] > 10)
continue;
document.write(array[i] + "</br>");
}
----

В этом случае, если программа встретит в массиве число, больше 10, то это число не будет выводиться в браузере.

== Функциональное программирование
=== Функции

*Функции* представляют собой набор инструкций, выполняющих определенное действие или вычисляющих определенное значение.

*Синтаксис определения функции:*

[source, javascript]
----
function имя_функции([параметр [, ...]]){

    // Инструкции
}
----

Определение функции начинается с ключевого слова `function`, после которого следует имя функции. Наименование функции подчиняется тем же правилам, что и наименование переменной: оно может содержать только цифры, буквы, символы подчеркивания и доллара `$` и должно начинаться с буквы, символа подчеркивания или доллара.

После имени функции в скобках идет перечисление параметров. Даже если параметров у функции нет, то просто идут пустые скобки. Затем в фигурных скобках идет тело функции, содержащее набор инструкций.

*Определим простейшую функцию:*

[source, javascript]
----
function display(){

    document.write("функция в JavaScript");
}
----

Данная функция называется `display()`. Она не принимает никаких параметров и все, что она делает, это пишет на веб-страницу строку.

Однако простого определения функции еще недостаточно, чтобы она заработала. На надо еще ее вызвать:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
<script>
function display(){

    document.write("функция в JavaScript");
}
display();
</script>
</body>
</html>
----

Необязательно давать функциям определенное имя. Можно использовать *анонимные функции*:

[source, javascript]
----
var display = function(){  // определение функции

    document.write("функция в JavaScript");
}
display();
----

Фактически определяем переменную `display` и присваиваем ей ссылку на функцию. А затем по имени переменной функция вызывается.

Также можно динамически присваивать функции для переменной:

[source, javascript]
----
function goodMorning(){

    document.write("Доброе утро");
}
function goodEvening(){

    document.write("Добрый вечер");
}
var message = goodMorning;
message(); // Доброе утро
message = goodEvening;
message(); // Добрый вечер
----

=== Параметры функции

*Рассмотрим передачу параметров:*

[source, javascript]
----
function display(x){  // определение функции

    var z = x * x;
    document.write(x + " в квадрате равно " + z);
}
display(5); // вызов функции
----

Функция `display` принимает один параметр - `x`. Поэтому при вызове функции можно передать для него значение, например, число 5, как в данном случае.

Если функция принимает несколько параметров, то с помощью `spread-оператора ...` можно передать набор значений для этих параметров из массива:
[source, javascript]
----
function sum(a, b, c){
let d = a + b + c;
console.log(d);
}
sum(1, 2, 3);
let nums = [4, 5, 6];
sum(...nums);
----
Во втором случае в функцию передается числа из массива `nums`. Но чтобы передавался не просто массив, как одно значение, а именно числа из этого массива, применяется `spread-оператор (многоточие ...)`.

=== Необязательные параметры

Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если для параметров не передается значение, то по умолчанию они имеют значение `"undefined"`.
[source, javascript]
----
function display(x, y){

    if(y === undefined) y = 5;
    if(x === undefined) x = 8;
    let z = x * y;
    console.log(z);
}
display();  // 40
display(6); // 30
display(6, 4) // 24
----
Здесь функция `display` принимает два параметра. При вызове функции можно проверить их значения. При этом, вызывая функцию, необязательно передавать для этих параметров значения. Для проверки наличия значения параметров используется сравнение со значением `undefined`.

Есть и другой способ определения значения для параметров по умолчанию:
[source, javascript]
----
function display(x = 5, y = 10){
let z = x * y;
console.log(z);
}
display();      // 50
display(6);     // 60
display(6, 4)   // 24
----
Если параметрам `x` и `y` не передаются значения, то они получаются в качестве значений числа 5 и 10 соответствено. Такой способ более лаконичен и интуитивен, чем сравнение с `undefined`.

При этом значение параметра по умолчанию может быть производным, представлять выражение:

[source, javascript]
----
function display(x = 5, y = 10 + x){
let z = x * y;
console.log(z);
}
display();      // 75
display(6);     // 96
display(6, 4)   // 24
----

В данном случае значение параметра y зависит от значения `x`.

При необходимости можно получить все переданные параметры через глобально доступный массив `arguments`:

[source, javascript]
----
function display(){
var z = 1;
for(var i=0; i<arguments.length; i++)
z *= arguments[i];
console.log(z);
}
display(6); // 6
display(6, 4) // 24
display(6, 4, 5) // 120
----

При этом даже неважно, что при определении функции не указаны параметры, все равно можно их передать и получить значения через массив `arguments`.

=== Неопределенное количество параметров

С помощью `spread-оператора` можно указать, что с помощью параметра можно передать переменное количество значений:

[source, javascript]
----
function display(season, ...temps){
console.log(season);
for(index in temps){
console.log(temps[index]);
}
}
display("Весна", -2, -3, 4, 2, 5);
display("Лето", 20, 23, 31);
----
В данном случае второй параметр `...temps` указывает, что вместо него можно передать разное количество значений. В самой функции `temps` фактически представляет массив переданных значений, которые можно получить. При этом несмотря на это, при вызове функции в нее передается не массив, а именно отдельные значения.

*Консольный вывод:*

_Весна -2 -3 4 2 5;_

_Лето 20 23 31;_

Но нужно учесть, что каждое значение будет выведено с новой строки.

=== Результат функции

Функция может возвращать результат. Для этого используется оператор `return`:
[source, javascript]
----
var y = 5;
var z = square(y);
document.write(y + " в квадрате равно " + z);

function square(x) {
return x * x;
}
----
После оператора `return` идет значение, которое надо возвратить из метода. В данном случае это квадрат числа `х`.

После получения результата функции можно присвоить его какой-либо другой переменной:

[source, javascript]
----
var z = square(y);
----

=== Функции в качестве параметров

Функции могут выступать в качестве параметров других функций:
[source, javascript]
----
function sum(x, y){
return x + y;
}

function subtract(x, y){
return x - y;
}

function operation(x, y, func){

    var result = func(x, y);
    console.log(result);
}

console.log("Sum");
operation(10, 6, sum);  // 16

console.log("Subtract");
operation(10, 6, subtract); // 4
----

Функция `operation` принимает три параметра: `x`, `y` и `func`. `func` - представляет функцию, причем на момент определения `operation` не важно, что это будет за функция. Единственное, что известно, что функция `func` может принимать два параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому можно определить различные функции (например, функции `sum` и `subtract` в данном случае) и передавать их в вызов функции `operation`.

=== Возвращение функции из функции

Одна функция может возвращать другую функцию:

[source, javascript]
----
function menu(n){

    if(n==1) return function(x, y){ return x+y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return undefined;
}

for(var i=1; i < 5; i++){
var action = menu(i);
if(action!==undefined){
var result = action(5, 4);
console.log(result);
}
}
----
В данном случае функция `menu` в зависимости от переданного в нее значения возвращает одну из трех функций или `undefined`.

== Область видимости переменных

Все переменные в *JavaScrip* имеют определенную область видимости, в пределах которой они могут действовать.

=== Глобальные переменные

Все переменные, которые объявлены вне функций, являются *глобальными*:
[source, html]
----
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
</head>
<body>
<script>
var x = 5;
let d = 8;
function displaySquare(){

    var z = x * x;
    console.log(z);
}
</script>
</body>
</html>
----

Здесь переменные `x` и `d` являются глобальными. Они доступны из любого места программы. А вот переменная `z` глобальной не является, так как она определена внутри функции.

=== Локальные переменные

Переменная, определенная внутри функции, является *локальной*:

[source, javascript]
----
function displaySquare(){

    var z = 10;
    console.log(z);

    let b = 8;
    console.log(b);
}
----

Переменные `z` и `b` являются локальными, они существуют только в пределах функции. Вне функции их нельзя использовать:

[source, javascript]
----
function displaySquare(){

    var z = 10;
    console.log(z);
}
console.log(z); //ошибка, так как z не определена
----

Когда функция заканчивает свою работу, то все переменные, определенные в функции, уничтожаются.

=== Сокрытие переменных

Что если у нас есть две переменных - одна глобальная, а другая локальная, которые имеют одинаковое имя:
[source, javascript]
----
var z = 89;
function displaySquare(){

    var z = 10;
    console.log(z); // 10
}
displaySquare(); // 10
----
В этом случае в функции будет использоваться та переменная `z`, которая определена непосредственно в функции. То есть локальная переменная скроет глобальную.

=== `var` или `let`

*При использовании оператора `let`* каждый блок кода определяет новую область видимости, в которой существует переменная. Например, можно одновременно определить переменную на уровне блока и на уровне функции:

[source, javascript]
----
let z = 10;
function displayZ(){

    let z = 20;

    {
        let z = 30;
        console.log("Block:", z);
    }

    console.log("Function:", z);
}

displayZ();
console.log("Global:", z);
----

Здесь внутри функции ``displayZ ``определен блок кода, в котором определена переменная `z`. Она скрывает глобальную переменную и переменную `z`, определенную на уровне функции. В реальной программе блок мог быть предеставлять вложенную функцию, блок цикла `for` или конструкции `if`. Но в любом случае такой блок определяет новую область видимости, вне которого переменная не существует.

И в данном случае *получим следующий консольный вывод:*

_Block: 30 Function: 20 Global: 10_

*С помощью оператора `var`* нельзя определить одновременно переменную с одним и тем же именем и в функции, и в блоке кода в этой функции:

[source, javascript]
----
function displaySquare(){

    var z = 20;

    {
        var z = 30; // Ошибка ! Переменная z уже определена
        console.log("Block:", z);
    }
    console.log("Function:", z);
}
----

То есть с помощью `var` можно определить переменную с одним именем либо на уровне функции, либо на уровне блока кода.

=== Константы

Все, что относится к оператору `let`, относится и к оператору `const`, который позволяет определить константы. Блоки кода задают область видимости констант, а константы, определенные на вложенных блоках кода, скрывают внешние константы с тем же именем:

[source, javascript]
----
const z = 10;
function displayZ(){

    const z = 20;

    {
        const z = 30;
        console.log("Block:", z);   // 30
    }
    console.log("Function:", z);    // 20
}

displayZ();
console.log("Global:", z);  // 10
----

=== Необъявленные переменные

Если не используется ключевое слово при определении переменной в функции, то такая переменная будет *глобальной*. *Например:*
[source, javascript]
----
function bar(){
foo = "25";
}
bar();
console.log(foo);   // 25
----

Несмотря на то, что вне функции `bar` переменная `foo` нигде не определяется, тем не менее она доступна вне функции во внешнем контексте.

Иначе, если не только присвоить значение переменной, но и переопределить ее:

[source, javascript]
----
function bar(){
var foo = "25";
}

bar();
console.log(foo);   // ошибка
----

=== strict mode

Определение глобальных переменных в функциях может вести к потенциальным ошибкам. Чтобы их избежать используется строгий режим или `strict mode`:

[source, javascript]
----
"use strict";
function bar(){
foo = "25";
}

bar();
console.log(foo);
----

В этом случае получим ошибку `SyntaxError: Unexpected identifier`, которая говорит о том, что переменная `foo` не определена.

*Установить режим `strict mode` можно двумя способами*:

* Добавить выражение `"use strict"` в начало кода `JavaScript`, тогда `strict mode` будет применяться для всего кода

* Добавить выражение `"use strict"` в начало тела функции, тогда `strict mode` будет применяться только для этой функции

== Замыкания и функции `IIFE`

*Замыкание (closure)* представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том случае, когда она выполняет вне своей области видимости.

*Замыкание технически включает три компонента:*

* Внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение

* Переменные (лексическое окружение), которые определены во внешней функции

* Вложенная функция, которая использует эти переменные

[source, javascript]
----
function outer(){       // внешняя функция
var n;              // некоторая переменная
return inner(){     // вложенная функция
// действия с переменной n
}
}
----

*Рассмотрим замыкания на простейшем примере:*

[source, javascript]
----
function outer(){
let x = 5;
function inner(){
x++;
console.log(x);
};
return inner;
}
let fn = outer();   // fn = inner, так как функция outer возвращает функцию inner
// вызываем внутреннюю функцию inner
fn();   // 6
fn();   // 7
fn();   // 8
----

Здесь функция `outer` задает область видимости, в которой определены внутренняя функция `inner` и переменная `x`. Переменная `x` представляет лексическое окружение для функции `inner`. В самой функции `inner` инкрементируем переменную `x` и выводим ее значение на консоль. В конце функция `outer` возвращает функцию `inner`.

Далее вызываем функцию `outer`:

[source, javascript]
----
let fn = outer();
----

Поскольку функция `outer` возвращает функцию `inner`, то переменная `fn` будет хранить ссылку на функцию `inner`. При этом эта функция запомнила свое окружение - то есть внешнюю переменную `x`.

Далее фактически три раза вызываем функцию `Inner`, и видно, что переменная `x`, которая определена вне функции `inner`, инкрементируется:

[source, javascript]
----
fn();   // 6
fn();   // 7
fn();   // 8
----

То есть несмотря на то, что переменная `x` определена вне функции `inner`, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции `outer`, в которой была определена. В этом и суть замыканий.

*Рассмотрим еще один пример:*

[source, javascript]
----
function multiply(n){
var x = n;
return function(m){ return x * m;};
}
var fn1 = multiply(5);
var result1 = fn1(6); // 30
console.log(result1); // 30

var fn2= multiply(4);
var result2 = fn2(6); // 24
console.log(result2); // 24
----

Итак, здесь вызов функции `multiply()` приводит к вызову другой внутренней функции. Внутренняя же функция:

[source, javascript]
----
function(m){ return x * m;};
----

Запоминает окружение, в котором она была создана, в частности, значение переменной `x`.

В итоге при вызове функции `multiply` определяется переменная `fn1`, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной, которая была в области действия функции `multiply` во время создания замыкания.

То есть `fn1` — это замыкание, которое содержит и внутреннюю функцию `function(m){ return x * m;}`, и переменную `x`, которая существовала во время создания замыкания.

При создании двух замыканий: `fn1` и `fn2`, для каждого из этих замыканий создается свое окружение.

При этом важно не запутаться в параметрах. При определении замыкания:

[source, javascript]
----
var fn1 = multiply(5);
----
Число *5* передается для параметра `n` функции `multiply`.

При вызове внутренней функции:

[source, javascript]
----
var result1 = fn1(6);
----

Число *6* передается для параметра `m` во внутреннюю функцию `function(m){ return x * m;};`.

*Также можно использовать другой вариант для вызова замыкания:*

[source, javascript]
----
function multiply(n){
var x = n;
return function(m){ return x * m;};
}
var result = multiply(5)(6); // 30
console.log(result);
----

=== Самовызывающиеся функции

Обычно определение функции отделяется от ее вызова: сначала определяем функцию, а потом вызываем. Но это необязательно. Также можем создать такие** функции, которые будут вызываться сразу при определении**. Такие функции еще называют `Immediately Invoked Function Expression (IIFE)`.

[source, javascript]
----
(function(){
console.log("Привет мир");
}());

(function (n){

    var result = 1;
    for(var i=1; i<=n; i++)
        result *=i;
    console.log("Факториал числа " + n + " равен " + result);
}(4));
----
Подобные функции заключаются в скобки, и после определения функции идет в скобках передача параметров.

== Паттерн Модуль

*Паттерн "Модуль"* базируется на замыканиях и состоит из двух компонентов: *внешняя функция*, которая определяет лексическое окружение, и *возвращаемый набор внутренних функций*, которые имеют доступ к этому окружению.

*Определим простейший модуль:*
[source, javascript]
----
let foo = (function(){
let obj = {greeting: "hello"};

    return {
        display: function(){
            console.log(obj.greeting);
        }
    }
})();
foo.display();  // hello
----

Здесь определена переменная `foo`, которая представляет результат анонимной функции. Внутри подобной функции определен объект `obj` с некоторыми данными.

Сама анонимная функция возвращает объект, который определяет функцию `display`. Возвращаемый объект определяет общедоступый *API*, через который можно обращаться к данным, определенным внутри модуля.

[source, javascript]
----
return {
display: function(){
console.log(obj.greeting);
}
}
----

Такая конструкция позволяет закрыть некоторый набор данных в рамках функции-модуля и опосредовать доступ к ним через определенный *API* - возвращаемые внутренние функции.

*Рассмотрим чуть более сложный пример:*

[source, javascript]
----
let calculator = (function(){
let data = { number: 0};

    return {
        sum: function(n){
            data.number += n;
        },
        subtract: function(n){
            data.number -= n;
        },
        display: function(){
            console.log("Result: ", data.number);
        }
    }
})();
calculator.sum(10);
calculator.sum(3);
calculator.display();   // Result: 13
calculator.subtract(4);
calculator.display();   // Result: 9
----

Данный модуль представляет примитивный калькулятор, который выполняет три операции: сложение, вычитание и вывод результата.

Все данные инкапсулированы в объекте `data`, который хранит результат операции. Все операции представлены тремя возвращаемыми функциями: `sum`, `subtract` и `display`. Через эти функции можно управлять результатом калькулятора извне.

== Рекурсивные функции

Среди функций отдельно можно выделить *рекурсивные функции*. Их суть состоит в том, что *функция вызывает саму себя*.

*Например*, рассмотрим функцию, определяющую факториал числа:

[source, javascript]
----
function getFactorial(n){
if (n === 1){
return 1;
}
else{

        return n * getFactorial(n - 1);
    }
}
var result = getFactorial(4);
console.log(result); // 24
----

Функция `getFactorial()` возвращает значение 1, если параметр `n` равен 1, либо возвращает результат опять же функции `getFactorial`, то в нее передается значение `n-1`. Например, при передаче числа 4, у нас образуется следующая цепочка вызовов:

[source, javascript]
----
var result = 4 * getFactorial(3);
var result = 4 * 3 * getFactorial(2);
var result = 4 * 3 * 2 * getFactorial(1);
var result = 4 * 3 * 2 * 1; // 24
----

Рассмотрим другой пример - определение чисел Фибоначчи:

[source, javascript]
----
function getFibonachi(n)
{
if (n === 0){
return 0;
}
if (n === 1){
return 1;
}
else{
return getFibonachi(n - 1) + getFibonachi(n - 2);
}
}
var result = getFibonachi(8); //21
console.log(result); // 21
----

== Переопределение функций

*Функции* обладают возможностью для переопределения поведения. Переопределение происходит с помощью присвоения анонимной функции переменной, которая называется так же, как и переопределяемая функция:

[source, javascript]
----
function display(){
console.log("Доброе утро");
display = function(){
console.log("Добрый день");
}
}

display(); // Доброе утро
display(); // Добрый день
----

При первом срабатывании функции действует основной блок операторов функции, в частности, в данном случае выводится сообщение *"Доброе утро"*. И при первом срабатывании функции `display` также происходит ее переопределение. Поэтому при всех последующих вызовах функции срабатывает ее переопределенная версия, а на консоль будет выводиться сообщение *"Добрый день"*.

Но при переопределении функции надо учитывать некоторые нюансы. В частности, попробуем присвоить ссылку на функцию переменной и через эту переменную вызвать функцию:

[source, javascript]
----
function display(){
console.log("Доброе утро");
display = function(){
console.log("Добрый день");
}
}
// присвоение ссылки на функцию до переопределения
var displayMessage = display;
display(); // Доброе утро
display(); // Добрый день
displayMessage(); // Доброе утро
displayMessage(); // Доброе утро
----

Здесь переменная `displayMessage` получает ссылку на функцию `display` до ее переопределения. Поэтому при вызове `displayMessage()` будет вызываться непереопределенная версия функции `display`.

Но допустим, определили переменную `displayMessage` уже после вызова функции `display`:

[source, javascript]
----
display(); // Доброе утро
display(); // Добрый день
var displayMessage = display;
displayMessage(); // Добрый день
displayMessage(); // Добрый день
----

В этом случае переменная `displayMessage` будет указывать на переопределенную версию функции `display`.

== Hoisting

*Hoisting* представляет процесс доступа к переменным до их определения. Возможно, данная концепция выглядит немного странно, но она связана с работой компилятора *JavaScript*. Компиляция кода происходит в два прохода. При первом проходе компилятор получает все объявления переменных, все идентификаторы. При этом никакой код не выполняется, методы не вызываются. При втором проходе собственно происходит выполнение. И даже если переменная определена после непосредственного использования, ошибки не возникнет, так как при первом проходе компилятору уже известны все переменные.

То есть как будто происходит поднятие кода с определением переменных и функций вверх до их непосредственного использования. Поднятие на английский переводится как *hoisting*, сообственно поэтому данный процесс так и называется.

Переменные, которые попадают под *hoisting*, получают значение `undefined`.

Например, возьмем следующий простейший код:

[source, javascript]
----
console.log(foo);
----

Его выполнение вызовет ошибку `ReferenceError: foo is not defined`

Добавим определение переменной:

[source, javascript]
----
console.log(foo);   // undefined
var foo = "Tom";
----

В этом случае консоль выведет значение `"undefined"`. При первом проходе компилятор узнает про существование переменной `foo`. Она получает значение `undefined`. При втором проходе вызывается метод `console.log(foo)`.

Возьмем другой пример:

[source, javascript]
----
var c = a * b;
var a = 7;
var b = 3;
console.log(c); // NaN
----

Здесь та же ситуация. Переменные `a` и `b` используются до опеределения. По умолчанию им присваиваются значения `undefined`. А если умножить `undefined` на `undefined`, то получим `Not a Number (NaN)`.

Все то же самое относится и к использованию функций. Можно сначала вызвать функцию, а потом уже ее определить:

[source, javascript]
----
display();

function display(){
console.log("Hello Hoisting");
}
----

Здесь функция `display` благополучно отработает, несмотря на то, что она определена после вызова.

Но от этой ситуации надо отличать тот случай, когда функция определяется в виде переменной:

[source, javascript]
----
display();

var display = function (){
console.log("Hello Hoisting");
}
----

В данном случае получим ошибку `TypeError: display is not a function`. При первом проходе компилятор также получит переменную `display` и присвоет ей значение `undefined`. При втором проходе, когда надо будет вызывать функцию, на которую будет ссылаться эта переменная, компилятор увидит, что вызывать то нечего: переменная `display` пока еще равна `undefined`. И будет выброшена ошибка.

Поэтому при определении переменных и функций следует учитывать перепетии такого аспекта как `hoisting`.

== Передача параметров по значению и по ссылке
=== Передача параметров по значению

*Строки, числа, логические значения передаются в функцию по значению.* Иными словами при передаче значения в функцию, эта функция получает копию данного значения. Рассмотрим, что это значит в практическом плане:

[source, javascript]
----
function change(x){
x = 2 * x;
console.log("x in change:", x);
}

var n = 10;
console.log("n before change:", n); // n before change: 10
change(n);                          // x in change: 20
console.log("n after change:", n);  // n after change: 10
----

Функция `change` получает некоторое число и увеличивает его в два раза. При вызове функции `change` ей передается число `n`. Однако после вызова функции видно, что число `n` не изменилось, хотя в самой функции произошло увеличение значения параметра. Потому что при вызове функция `change` получает копию значения переменной `n`. И любые изменения с этой копией никак не затрагивают саму переменную `n`.

=== Передача по ссылке

*Объекты и массивы передаются по ссылке.* То есть функция получает сам объект или массив, а не их копию.

[source, javascript]
----
function change(user){
user.name = "Tom";
}

var bob ={
name: "Bob"
};
console.log("before change:", bob.name);    // Bob
change(bob);
console.log("after change:", bob.name);     // Tom
----

В данном случае функция `change` получает объект и меняет его свойство `name`. В итоге увидим, что после вызова функции изменился оригинальный объект `bob`, который передавался в функцию.

Однако если переустановить объект или массив полностью, оригинальное значение не изменится.

[source, javascript]
----
function change(user){
// полная переустановка объекта
user= {
name:"Tom"
};
}

var bob ={
name: "Bob"
};
console.log("before change:", bob.name);    // Bob
change(bob);
console.log("after change:", bob.name);     // Bob
----

То же самое касается массивов:

[source, javascript]
----
function change(array){
array[0] = 8;
}
function changeFull(array){
array = [9, 8, 7];
}

var numbers = [1, 2, 3];

console.log("before change:", numbers);     // [1, 2, 3]
change(numbers);
console.log("after change:", numbers);      // [8, 2, 3]
changeFull(numbers);
console.log("after changeFull:", numbers);  // [8, 2, 3]
----

== Стрелочные функции

*Стрелочные функции (arrow functions)* представляют сокращенную версию обычных функций. Стрелочные функции образуются с помощью знака стрелки `=>`, перед которым в скобках идут параметры функции, а после - собственно тело функции. *Например:*

[source, javascript]
----
let sum = (x, y) => x + y;
let a = sum(4, 5);      // 9
let b = sum(10, 5);     // 15
----

В данном случае функция `(x, y) => x + y` осуществляет сложение двух чисел и присваивается переменной `sum`. Функция принимает два параметра - `x` и `y`. Ее тело составляет сложение значений этих параметров. И поскольку после стрелки фактически идет конкретное значение, которое представляет сумму чисел, то функция возвращает это значение. И можно через переменную `sum` вызвать данную функцию и получить ее результат в переменные `a` и `b`.

Если после стрелки идет операция или выражение, которое возвращает значение, то это значение фактически возвращается из стрелочной функции. Но также в качестве тела функции может примяться выражение, которое ничего не возвращает и просто выполняет некоторое действие:

[source, javascript]
----
let sum = (x, y) => console.log(x + y);
sum(4, 5);      // 9
sum(10, 5);     // 15
----

В данном случае функция `console.log()` ничего не возвращает, и соответственно функция `sum` также не возвращает никакого результата.

Если функция принимает один параметр, то скобки вокруг него можно опустить:

[source, javascript]
----
var square = n => n * n;

console.log(square(5));     // 25
console.log(square(6));     // 36
console.log(square(-7));    // 49
----

Если тело функции представляет набор выражений, то они облекаются в фигурные скобки:

[source, javascript]
----
var square = n => {
let result = n * n;
return result;
}

console.log(square(5));     // 25
----

Для возвращения результата из функции в таком случае применяется стандартный оператор `return`.

Особо следует остановиться на случае, когда стрелочная функция возвращает объект:

[source, javascript]
----
let user = (userName, userAge) => ({name: userName, age: userAge});

let tom = user("Tom", 34);
let bob = user("Bob", 25);

console.log(tom.name, tom.age);     // "Tom", 34
console.log(bob.name, bob.age);     // "Bob", 25
----

Объект также определяется с помощью фигурных скобок, но при этом он заключается в круглые скобки.

Если стрелочная функция не принимает никаких параметров, то ставятся пустые скобки:

[source, javascript]
----
var hello = ()=> console.log("Hello World");
hello();    // Hello World
hello();    // Hello World
----
