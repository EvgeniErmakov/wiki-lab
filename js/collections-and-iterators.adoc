= Коллекции и итераторы

== Итераторы

Итераторы применяются для организации последовательного доступа к элементам коллекции — массивам, объектам `Set` и `Map`. Итераторы предоставляют метод `next()`, который возвращает два значения: `value` и `done`. `value` хранит собственно значение текущего перебираемого элемента. А свойство `done` указывает, есть ли еще в коллекции объекты, доступные для перебора.

Некоторые методы коллекций возвращают итераторы. Например, метод `entries()`, который есть у коллекций `Array`, `Set`, `Map`:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
let items = users.entries();
console.log(items.next());
----

Метод `next` возвратит следующий объект на консоль:

[source]
----
{value: Array(2), done: false}
done:	false
value:	Array(2)
0:	0
1:	"Tom"
length:	2
__proto__:	Array(0)
__proto__:	Object
----

Здесь мы видим, что свойство `done` имеет значение `false`, так как мы перебрали только один элемент в множестве, и там еще есть два элемента.

Свойство `value` представляет массив из двух значений. Первое значение представляет ключ или индекс элемента массива, а второй элемент — значение по этому индексу. имеет ключ и значение.

Соответственно мы можем организовать и перебор всей коллекции:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
let items = users.entries();
var result = items.next();
while(result.done === false){
    console.log(result.value[0], result.value[1]);
    result = items.next();
}
----

Консольный вывод:

[source]
----
0 "Tom"
1 "Bob"
2 "Sam"
----

Но в этом нет смысла, поскольку все коллекции, возвращающие итераторы, поддерживают перебор с помощью цикла `for...of`, который как раз и использует итератор для получения элементов:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
for(let val of users)
    console.log(val);
----

Если мы хотим извлечь еще и индекс элемента в массиве, то мы можем использовать для перебора итератор из `entries()`:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
for(let user of users.entries()){
    console.log(user[0], user[1]);
}
----

Консольный вывод:

[source]
----
0 "Tom"
1 "Bob"
2 "Sam"
----

== Генераторы

Генераторы представляют особый тип функции, которые используются для генерации значений. Для определения генераторов применяется символ звездочки `*`, который ставится после ключевого слова `function`. Например, определим простейший генератор:

[source, javascript]
----
function* getNumber(){
    yield 5;
}
let numberGenerator = getNumber();
let next = numberGenerator.next();
console.log(next);
----

Функция `getNumber` представляет генератор. Функция генератора возвращает итератор. Для получения значения из генератора применяется оператор `yield`. То есть фактически в данном случае генератор генерирует число 5.

Далее с помощью вызова этой функции создается объект итератора в виде переменной `numberGenerator`. Используя этот объект, мы можем получать из генератора значения.

Для перехода к следующему значению применяется метод `next()`. Если мы посмотрим на консольный вывод, то мы увидим, что данный метод возвращает следующие данные:

[source]
----
{value: 5, done: false}
----

То есть по сути возвращается объект, свойство `value` которого содержит собственно сгенерированное значение. А свойство `done` указывает, достигли ли мы конца генератора.

Теперь изменим код:

[source, javascript]
----
function* getNumber(){
    yield 5;
}
let numberGenerator = getNumber();
let next = numberGenerator.next();
console.log(next);
next = numberGenerator.next();
console.log(next);
----

Здесь обращение к методу `next()` происходит два раза:

[source]
----
{value: 5, done: false}
{value: undefined, done: true}
----

Но функция генератора `getNumber` генерирует только одно значение — число 5. Поэтому при повторном вызове свойство `value` будет иметь значение `undefined`, а свойство `done - true`, то есть работа генератора завершена.

Генератор может создавать множество значений:

[source, javascript]
----
function* getNumber(){
    yield 5;
    yield 25;
    yield 125;
}
let numberGenerator = getNumber();
console.log(numberGenerator.next());
console.log(numberGenerator.next());
console.log(numberGenerator.next());
console.log(numberGenerator.next());
----

Консольный вывод:

[source]
----
{value: 5, done: false}
{value: 25, done: false}
{value: 125, done: false}
{value: undefined, done: true}
----

То есть при первом вызове метода `next()` из итератора извлекается значение, которое идет после первого оператора `yield`, при втором вызове метода `next()` - значение после второго оператора `yield` и так далее.

Поскольку для получения значений применяется итератор, то мы можем использовать цикл `for...of`:

[source, javascript]
----
function* getNumber(){
    yield 5;
    yield 25;
    yield 125;
}
let numberGenerator = getNumber();
for(let num of numberGenerator){
    console.log(num);
}
----

Консольный вывод:

[source]
----
5
25
125
----

Генератор необязательно содержит только определение операторов `yield`. Он также может содержать более сложную логику.

С помощью генераторов удобно создавать бесконечные последовательности:

[source, javascript]
----
function* points() {
    let x = 0;
    let y = 0;
    while(true){
        yield {x:x, y:y};
        x += 2;
        y += 1;
    }
}
let pointGenerator = points();
console.log(pointGenerator.next().value);
console.log(pointGenerator.next().value);
console.log(pointGenerator.next().value);
----

Консольный вывод:

[source]
----
{x: 0, y: 0}
{x: 2, y: 1}
{x: 4, y: 2}
----

=== Передача данных в генератор

С помощью `next()` можно передать в генератор данные.

[source, javascript]
----
function* getNumber() {
    let n = yield 5;
    console.log("n:", n);
    let m = yield 25 * n;
    console.log("m:", m);
    yield 125 * m;
}
let numberGenerator = getNumber();
console.log(numberGenerator.next().value);
console.log(numberGenerator.next(2).value);
console.log(numberGenerator.next(3).value);
----

Консольный вывод:

[source]
----
5
n: 2
50
m: 3
375
----

При втором вызове метода `next()`:

[source, javascript]
----
numberGenerator.next(2).value
----

Мы можем получить переданные через него данные, присвоив результат *первого* оператора `yield`:

[source, javascript]
----
let n = yield 5;
----

То есть здесь переменная `n` будет равна `2`, так как в метод `next()` передается число `2`.

Далее мы можем использовать это значение, например, для генерации нового значения:

[source, javascript]
----
let m = yield 25 * n;
----

Соответственно, переменная `m` получить значение, переданное через третий вызов метода `next()`, то есть число `3`.

=== Инициализация генератора

Есть также другой способ передачи данных в генератор, когда мы передаем некоторые данные в саму функцию генератора, то есть фактически инициализируем генератор некоторыми начальными данными:

[source, javascript]
----
function* takeItem(arr){
    for(var i=0; i < arr.length; i++){
        yield arr[i];
    }
}
var users = ["Tom", "Bob", "Sam", "Alice", "Kate", "Ann"];
var userGenerator = takeItem(users);
var timer = setInterval(function() {
    var user = userGenerator.next();
    if(user.done){
        clearInterval(timer);
        console.log("The End...");
    } else{
        console.log(user.value);
    }
}, 500);
----

В данном случае в генератор передается массив, который используется для генерации значений в таймере.

== Множества Set

`Множества (sets)` представляют структуру данных, которая может хранить только уникальные значения. В `JavaScript` функционал множества определяет объект `Set`. Для создания множества применяется конструктор этого объекта:

[source, javascript]
----
let mySet = new Set();
----

Также можно передать в конструктор массив значений, которыми будет инициализировано множество:

[source, javascript]
----
let arr = [1, 1, 2, 3, 4, 5, 2, 4];
let numbers = new Set(arr);
console.log(numbers);           // Set(5) {1, 2, 3, 4, 5}
----

В данном случае в множество передаются данные из массива. Однако поскольку множество может хранить только уникальные значения, то при его создании повторяющиеся значения, которые есть в массиве, удаляются.

Для проверки количества элементов можно использовать свойство `size`.

[source, javascript]
----
let arr = [1, 1, 2, 3, 4, 5, 2, 4];
let numbers = new Set(arr);
console.log(numbers.size);      // 5
----

=== Добавление

Для добавления применяется метод `add()`. Его результатом является измененное множество:

[source, javascript]
----
let numbers = new Set();
numbers.add(1);
numbers.add(3);
numbers.add(5);
numbers.add(3);     // не добавляется
numbers.add(1);     // не добавляется
console.log(numbers);       // Set(3) {1, 3, 5}
----

При этом, поскольку множество хранит только уникальные значения, то добавление элементов, которые уже в нем есть, не имеет смысла.

Так как метод `add` возвращает ссылку на это же множество, то мы можем вызывать методы по цепочке:

[source, javascript]
----
let numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers);       // Set(3) {1, 3, 5}
----

=== Удаление

Для удаления элементов применяется метод `delete()`:

[source, javascript]
----
let numbers = new Set();
numbers.add(1).add(3).add(5);
numbers.delete(3);
console.log(numbers);       // Set(2) {1, 5}
----

Причем данный метод возвращает булево значение: `true` - если элемент удален и `false` - если удаление не произошло (например, когда удаляемого элемента нет в множестве):

[source, javascript]
----
let numbers = new Set();
numbers.add(1).add(3).add(5);
let isDeleted = numbers.delete(3);
console.log(isDeleted);         // true
isDeleted = numbers.delete(54);
console.log(isDeleted);         // false
----

Если необходимо удалить вообще все элементы из множества, то применяется метод `clear()`:

[source, javascript]
----
let numbers = new Set();
numbers.add(1).add(3).add(5);
numbers.clear();
console.log(numbers);           // Set(0) {}
----

=== Проверка наличия элемента

Если нужно проверить, если ли элемент в множестве, то используется метод `has()`. Если элемент есть, то метод возвращает `true`, иначе возвращает `false`:

[source, javascript]
----
let numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers.has(3));    // true
console.log(numbers.has(32));   // false
----

=== Перебор множества

Для перебора элементов множества применяется метод `forEach()`:

[source, javascript]
----
let arr = [1, 2, 3, 5];
let numbers = new Set(arr);
numbers.forEach(function(value1, value2, set){
    console.log(value1);
})
----

Для совместимости с массивами, которые тоже имеют метод `forEach`, в данный метод передается функция обратного вызова, которая принимает три параметра. Непосредственно для множества первый и второй параметры представляют текущий перебираемый элемент, а третий параметр — перебираемое множество.

Также для перебора множества можно использовать цикл `for...of`:

[source, javascript]
----
let numbers = new Set([1, 2, 3, 5]);
for(n of numbers){
    console.log(n);
}
----

== Map

`Map` или карта (отображение, словарь) представляет структуру данных, где каждый элемент имеет *ключ* и *значение*. Ключи в рамках карты являются уникальными, то есть с одним ключом может быть сопоставлен только один элемент. Для создания карты применяется конструктор объекта `Map`:

[source, javascript]
----
let myMap = new Map();
----

Также можно инициализировать карту начальными значениями. Для этого в конструктор передается массив, элементы которого представляют массивы из двух элементов — первый элемент будет выступать в качестве ключа, а второй - в качестве значения:

[source, javascript]
----
let myMap = new Map([[1, "a"], [2, "b"], [3, "c"]]);
console.log(myMap);     // Map(3) {1 => "a", 2 => "b", 3 => "c"}
----

В данном случае числа 1, 2, 3 являются ключами, а строки "a", "b", "c" - значениями.

При этом ключи и значения необязательно должны быть одного типа:

[source, javascript]
----
let myMap = new Map([["a", 1], [2, "b"], ["c", true]]);
console.log(myMap);     // Map(3) {"a" => 1, 2 => "b", "c" => true}}
----

=== Добавление и изменение элементов

Для добавления или изменения значения применяется метод `set()`:

[source, javascript]
----
let myMap = new Map([[1, "a"], [2, "b"], [3, "c"]]);
myMap.set(4, "d");      // добавление элемента
myMap.set(2, "v");      // изменение элемента
console.log(myMap);     // Map(4) {1 => "a", 2 => "v", 3 => "c", 4 => "d"}
----

Первый параметр метода `set()` представляет ключ, а второй параметр — значение элемента. Если по такому ключу нет элементов, то добавляется новый элемент. Если ключ уже есть, то уже имеющийся элемент изменяет свое значение.

=== Получение элементов

Для получения элемента по ключу применяется метод `get()`, в который передается ключ элемента:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
console.log(myMap.get(2));  // Bob
console.log(myMap.get(7));  // undefined
----

Если `map` не содержит элемента по заданному ключу, то метод возвращает `undefined`.

Чтобы избежать возвращения `undefined`, мы можем проверить наличие элемента по ключу с помощью метода `has()`. Если элемент по ключу имеется, то метод возвращает `true`, иначе возвращается `false`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
console.log(myMap.has(2));  // true
console.log(myMap.has(7));  // false
----

=== Удаление элементов

Для удаления одного элемента по ключу применяется метод `delete()`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
myMap.delete(2);
console.log(myMap);     // Map(2) {1 => "Tom", 3 => "Sam"}
----

Для удаления всех элементов используется метод `clear()`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
myMap.clear();
console.log(myMap);     // Map(0) {}
----

=== Перебор элементов

Для перебора элементов используется метод `forEach`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
myMap.forEach(function(value1, value2, map){
    console.log(value2, value1);
})
----

Метод `forEach` в качестве параметра получает функцию обратного вызова, которая имеет три параметра. Первый и второй параметры — это соответственно значение и ключ текущего перебираемого элемента, а третий параметр — перебираемый объект Map.

Консольный вывод данного примера:

[source]
----
1 Tom
2 Bob
3 Sam
----

Также для перебора объекта `Map` можно использовать цикл `for...of`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);
for(item of myMap){
    console.log(item[0], item[1]);
}
----

Каждый элемент из `Map` помещается в переменную `item`, которая в свою очередь представляет массив. Первый элемент этого массива — ключ, а второй элемент — значение элемента.

Также объект `Map` имеет два дополнительных метода: `keys()` позволяет перебрать только ключи и `values()` позволяет перебирать значения элементов. Оба метода возвращают итераторы, поэтому для перебора ключей и значений по отдельности также можно использовать цикл `for...of`:

[source, javascript]
----
let myMap = new Map([[1, "Tom"], [2, "Bob"], [3, "Sam"]]);

for(item of myMap.keys()){
    console.log(item);
}
for(item of myMap.values()){
    console.log(item);
}
----

== WeakSet и WeakMap

=== WeakSet

Объект `WeakSet` во многом похож на обычное множество. Он также может хранить только уникальные значения, но каждый его элемент должен представлять объект.

Для создания объекта `WeakSet` используется его конструктор, в который можно передать начальные значения:

[source, javascript]
----
// пустой WeakSet
let weakSet1 = new WeakSet();
// инициализация начальными значениями
let weakSet2 = new WeakSet([{name:"Tom"}, {age: 34}]);
----

Для инициализации как в случае с объектом `Set` в конструктор передается массив, но данный массив содержит именно объекты, а не скалярные значения, типа чисел или строк.

Для добавления данных в `WeakSet` применяется метод `add()`:

[source, javascript]
----
let weakSet = new WeakSet();
weakSet.add({lang: "JavaScript"});
weakSet.add({lang: "TypeScript"});
// weakSet.add(34); // так нельзя - 34 - число, а не объект
console.log(weakSet);   // {{lang: "JavaScript"}, {lang: "TypeScript"}}
----

Причем опять же добавить мы можем только объект, а не скалярные значения типа чисел или строк.

Для удаления применяется метод `delete()`, в который передается ссылка на удаляемый объект:

[source, javascript]
----
let weakSet = new WeakSet();
var js = {lang: "JavaScript"};
var ts = {lang: "TypeScript"};
weakSet.add(js);
weakSet.add(ts);
weakSet.delete(js);
console.log(weakSet);   // {{lang: "TypeScript"}}
----

Если надо проверить, имеется ли объект в `WeakSet`, то можно использовать метод `has()`, который возвращает true при наличии объекта:

[source, javascript]
----
var js = {lang: "JavaScript"};
var ts = {lang: "TypeScript"};
var java = {lang: "Java"};
let weakSet = new WeakSet([js, ts]);
console.log(weakSet.has(ts));       // true
console.log(weakSet.has(java));     //  false
----

=== WeakMap

`WeakMap` представляет развитие коллекции `Map`. Особенностью WeakMap является то, что все ее элементы должны представлять объекты. При этом объектами должны быть как ключи, так и значения.

Создание `WeakMap`:

[source, javascript]
----
// пустой WeakMap
let weakMap1 = new WeakMap();
// WeakMap с инициализацией данными
var key1 = {key:1};
var key2 = {key:2};
var value1 = {name: "Tom"};
var value2 = {name: "Sam"};
let weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
----

Для получения объектов по ключу из WeakMap применяется метод `get()`:

[source, javascript]
----
var key1 = {key:1};
var key2 = {key:2};
var value1 = {name: "Tom"};
var value2 = {name: "Sam"};
let weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.get(key1));    // {name: "Tom"}
----

Для добавления новых объектов или изменения старых применяется метод `set()`:

[source, javascript]
----
var key1 = {key:1};
var key2 = {key:2};
var value1 = {name: "Tom"};
var value2 = {name: "Sam"};

let weakMap2 = new WeakMap([[key1, value1]]);
weakMap2.set(key2, value2);
weakMap2.set(key1, {name: "Kate"});
console.log(weakMap2.get(key1));    //{name: "Kate"}
console.log(weakMap2.get(key2));    //{name: "Sam"}
----

Чтобы проверить наличие элемента по определенному ключу, применяется метод `has(`), который возвращает `true` при наличии элемента:

[source, javascript]
----
var key1 = {key:1},
    key2 = {key:2};
var value1 = {name: "Tom"},
    value2 = {name: "Sam"};
let weakMap2 = new WeakMap([[key1, value1]]);
console.log(weakMap2.has(key1));    // true
console.log(weakMap2.has(key2));    // false
----

Для удаления элемента по ключу применяется метод `delete()`:

[source, javascript]
----
var key1 = {key:1},
    key2 = {key:2};
var value1 = {name: "Tom"},
    value2 = {name: "Sam"};
let weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.has(key1));    // true
weakMap2.delete(key1);
console.log(weakMap2.has(key1));    // false
----