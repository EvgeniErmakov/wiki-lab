= Функциональное программирование

== Функции

*Функции* представляют собой набор инструкций, выполняющих определенное действие или вычисляющих определенное значение.

*Синтаксис определения функции*:

[source, javascript]
----
function имя_функции([параметр [, ...]]) {
    // Инструкции
}
----

Определение функции начинается с ключевого слова `function`, после которого следует *имя функции*. Наименование функции подчиняется тем же правилам, что и наименование переменной: оно может содержать только цифры, буквы, символы подчеркивания и доллара `$` и должно начинаться с буквы, символа подчеркивания или доллара.

После имени функции в скобках идет перечисление параметров. Даже если параметров у функции нет, то просто идут пустые скобки. Затем в фигурных скобках идет тело функции, содержащее набор инструкций.

Определим простейшую функцию:

[source, javascript]
----
function display() {
    console.log("функция в JavaScript");
}
----

Данная функция называется `display()`. Она не принимает никаких параметров и все, что она делает, это пишет на web-страницу строку.

Однако простого определения функции еще недостаточно, чтобы она заработала. На надо еще ее вызвать:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <script>
        function display() {
            console.log("функция в JavaScript");
        }
        display();
    </script>
</body>
</html>
----

Необязательно давать функциям определенное имя. Можно использовать *анонимные функции*:

[source, javascript]
----
var display = function() { // определение функции
    console.log("функция в JavaScript");
}
display();
----

----
функция в JavaScript
----

Фактически определяем переменную `display` и присваиваем ей ссылку на функцию. А затем по имени переменной функция вызывается.

Также можно динамически присваивать функции для переменной:

[source, javascript]
----
function goodMorning() {
    console.log("Доброе утро");
}

function goodEvening() {
    console.log("Добрый вечер");
}

var message = goodMorning;
message();
message = goodEvening;
message();
----

----
Доброе утро
Добрый вечер
----

=== Параметры функции

Рассмотрим передачу параметров:

[source, javascript]
----
function display(x) { // определение функции
    var z = x * x;
    console.log(x + " в квадрате равно " + z);
}
display(5); // вызов функции
----

----
5 в квадрате равно 25
----

Функция `display` принимает один параметр - `x`. Поэтому при вызове функции можно передать для него значение, например, число `5`, как в данном случае.

Если функция принимает несколько параметров, то с помощью *spread-оператора* `...` можно передать набор значений для этих параметров из массива:

[source, javascript]
----
function sum(a, b, c) {
    let d = a + b + c;
    console.log(d);
}

sum(1, 2, 3);
let nums = [4, 5, 6];
sum(...nums);
----

----
6
15
----

Во втором случае в функцию передается числа из массива `nums`. Но чтобы передавался не просто массив, как одно значение, а именно числа из этого массива, применяется `spread-оператор` `...`.

=== Необязательные параметры

Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если для параметров не передается значение, то по умолчанию они имеют значение `undefined`.

[source, javascript]
----
function display(x, y) {
    if(y === undefined) y = 5;
    if(x === undefined) x = 8;
    let z = x * y;
    console.log(z);
}
display();
display(6);
display(6, 4);
----

----
40
30
24
----

Здесь функция `display` принимает два параметра. При вызове функции можно проверить их значения. При этом, вызывая функцию, необязательно передавать для этих параметров значения. Для проверки наличия значения параметров используется сравнение со значением `undefined`.

Есть и другой способ определения значения для параметров по умолчанию:

[source, javascript]
----
function display(x = 5, y = 10) {
    let z = x * y;
    console.log(z);
}
display();
display(6);
display(6, 4);
----

----
50
60
24
----

Если параметрам `x` и `y` не передаются значения, то они получаются в качестве значений числа `5` и `10` соответственно. Такой способ более лаконичен и интуитивен, чем сравнение с `undefined`.

При этом значение параметра по умолчанию может быть производным, представлять выражение:

[source, javascript]
----
function display(x = 5, y = 10 + x) {
    let z = x * y;
    console.log(z);
}
display();
display(6);
display(6, 4);
----

----
75
96
24
----

В данном случае значение параметра y зависит от значения `x`.

При необходимости можно получить все переданные параметры через глобально доступный массив `arguments`:

[source, javascript]
----
function display() {
    var z = 1;
    for (var i = 0; i < arguments.length; i++) {
        z *= arguments[i];
    }
    console.log(z);
}
display(6);
display(6, 4);
display(6, 4, 5);
----

----
6
24
120
----

При этом даже неважно, что при определении функции не указаны параметры, все равно можно их передать и получить значения через массив `arguments`.

=== Неопределенное количество параметров

С помощью `spread-оператора` можно указать, что с помощью параметра можно передать переменное количество значений:

[source, javascript]
----
function display(season, ...temps) {
    console.log(season);
    for (index in temps) {
        console.log(temps[index]);
    }
}
display("Весна", -2, -3, 4, 2, 5);
display("Лето", 20, 23, 31);
----

В данном случае второй параметр `...temps` указывает, что вместо него можно передать разное количество значений. В самой функции `temps` фактически представляет массив переданных значений, которые можно получить. При этом несмотря на это, при вызове функции в нее передается не массив, а именно отдельные значения.

.Консольный вывод
----
Весна
-2
-3
4
2
5
Лето
20
23
31
----

Но нужно учесть, что каждое значение будет выведено с новой строки.

=== Результат функции

Функция может возвращать результат. Для этого используется оператор `return`:

[source, javascript]
----
var y = 5;
var z = square(y);
console.log(y + " в квадрате равно " + z);

function square(x) {
    return x * x;
}
----

----
5 в квадрате равно 25
----

После оператора `return` идет значение, которое надо возвратить из метода. В данном случае это квадрат числа `х`.

После получения результата функции можно присвоить его какой-либо другой переменной:

[source, javascript]
----
var z = square(y);
----

=== Функции в качестве параметров

Функции могут выступать в качестве параметров других функций:

[source, javascript]
----
function sum(x, y) {
    return x + y;
}

function subtract(x, y) {
    return x - y;
}

function operation(x, y, func) {
    var result = func(x, y);
    console.log(result);
}

console.log("Sum");
operation(10, 6, sum);
console.log("Subtract");
operation(10, 6, subtract);
----

----
Sum
16
Subtract
4
----

Функция `operation` принимает три параметра: `x`, `y` и `func`. `func` - представляет функцию, причем на момент определения `operation` не важно, что это будет за функция. Единственное, что известно, что функция `func` может принимать два параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому можно определить различные функции (например, функции `sum` и `subtract` в данном случае) и передавать их в вызов функции `operation`.

=== Возвращение функции из функции

Одна функция может возвращать другую функцию:

[source, javascript]
----
function menu(n) {
    if (n == 1)
        return function(x, y) { return x + y;}
    else if(n == 2)
        return function(x, y) { return x - y;}
    else if(n == 3)
        return function(x, y) { return x * y;}
    return undefined;
}

for (var i=1; i < 5; i++) {
    var action = menu(i);
    if (action !== undefined) {
        var result = action(5, 4);
        console.log(result);
    }
}
----

----
9
1
20
----

В данном случае функция `menu` в зависимости от переданного в нее значения возвращает одну из трех функций или `undefined`.

== Область видимости переменных

Все переменные в *JavaScript* имеют определенную *область видимости*, в пределах которой они могут действовать.

=== Глобальные переменные

Все переменные, которые объявлены вне функций, являются *глобальными*:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <script>
        var x = 5;
        let d = 8;
        function displaySquare() {
            var z = x * x;
            console.log(z);
        }
    </script>
</body>
</html>
----

Здесь переменные `x` и `d` являются глобальными. Они доступны из любого места программы. А вот переменная `z` глобальной не является, так как она определена внутри функции.

=== Локальные переменные

Переменная, определенная внутри функции, является *локальной*:

[source, javascript]
----
function displaySquare() {
    var z = 10;
    console.log(z);

    let b = 8;
    console.log(b);
}
----

Переменные `z` и `b` являются локальными, они существуют только в пределах функции. Вне функции их нельзя использовать:

[source, javascript]
----
function displaySquare() {
    var z = 10;
    console.log(z);
}
console.log(z); // ошибка, так как z не определена
----

Когда функция заканчивает свою работу, то все переменные, определенные в функции, уничтожаются.

=== Сокрытие переменных

Что если у нас есть две переменных - одна глобальная, а другая локальная, которые имеют одинаковое имя:

[source, javascript]
----
var z = 89;
function displaySquare() {
    var z = 10;
    console.log(z);
}
displaySquare();
----

----
10
----

В этом случае в функции будет использоваться та переменная `z`, которая определена непосредственно в функции. То есть локальная переменная скроет глобальную переменную.

=== `var` или `let`

При использовании *оператора `let`* каждый блок кода определяет новую область видимости, в которой существует переменная. Например, можно одновременно определить переменную на уровне блока и на уровне функции:

[source, javascript]
----
let z = 10;
function displayZ() {
    let z = 20;
    {
        let z = 30;
        console.log("Block: ", z);
    }
    console.log("Function: ", z);
}

displayZ();
console.log("Global: ", z)
----

Здесь внутри функции `displayZ()` определен блок кода, в котором определена переменная `z`. Она скрывает глобальную переменную и переменную `z`, определенную на уровне функции. В реальной программе блок мог быть предоставлять вложенную функцию, блок цикла `for` или конструкции `if`. Но в любом случае такой блок определяет новую область видимости, вне которого переменная не существует.

И в данном случае получим следующий консольный вывод:

----
Block: 30
Function: 20
Global: 10
----

С помощью *оператора `var`* можно определить одновременно переменную с одним и тем же именем и в функции, и в блоке кода в этой функции:

[source, javascript]
----
var c = 10;
function displaySquare() {
    var c = 20;
    {
        var c = 30;
        console.log("Block:", c);
    }
    console.log("Function:", c);
}
displaySquare()
console.log("Global:", c)
----

----
Block: 30
Function: 30
Global: 10
----

Но стоит обратить внимание, что переменная введенная в общем коде и на уровне функции/блока функции - это переменные с разным уровнем видимости (глобальным и на уровни функции соответственно).

=== Константы

Все, что относится к оператору `let`, относится и к оператору `const`, который позволяет определить константы. Блоки кода задают область видимости констант, а константы, определенные на вложенных блоках кода, скрывают внешние константы с тем же именем:

[source, javascript]
----
const d = 10;
function displayZ() {
    const d = 20;
    {
        const d = 30;
        console.log("Block:", d);
    }
    console.log("Function:", d);
}

displayZ();
console.log("Global:", d);
----

----
Block: 30
Function: 20
Global: 10
----

=== Необъявленные переменные

Если не используется ключевое слово при определении переменной в функции, то такая переменная будет *глобальной*.

[source, javascript]
----
function bar() {
    foo = "25";
}
bar();
console.log(foo);
----

----
25
----

Несмотря на то, что вне функции `bar` переменная `foo` нигде не определяется, тем не менее она доступна вне функции во внешнем контексте.

Иначе, если не только присвоить значение переменной, но и переопределить ее:

[source, javascript]
----
function bar() {
    var foo = "25";
}

bar();
console.log(foo);
----

----
Uncaught ReferenceError: foo is not defined
----

=== strict mode

Определение глобальных переменных в функциях может вести к потенциальным ошибкам. Чтобы их избежать используется *строгий режим* или *strict mode*:

[source, javascript]
----
"use strict";
function bar() {
    foo = "25";
}

bar();
console.log(foo);
----

----
Uncaught ReferenceError: assignment to undeclared variable foo
----

*Установить режим `strict mode`* можно двумя способами:

* Добавить выражение `"use strict"` в начало кода `*JavaScript*, тогда *strict mode* будет применяться для всего кода.
* Добавить выражение `"use strict"` в начало тела функции, тогда *strict mode* будет применяться только для этой функции.

== Замыкания

*Замыкание* (*closure*) представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том случае, когда она выполняет вне своей области видимости.

*Замыкание технически включает три компонента*:

* *Внешняя функция*, которая определяет некоторую область видимости и в которой определены некоторые переменные - *лексическое окружение*
* *Переменные* (*лексическое окружение*), которые определены во внешней функции
* *Вложенная функция*, которая использует эти переменные

[source, javascript]
----
function outer() { // внешняя функция
    var n; // некоторая переменная
    return inner() { // вложенная функция
        // действия с переменной n
    }
}
----

=== Пример

Рассмотрим замыкания на простейшем примере:

[source, javascript]
----
function outer() {
    let x = 5;
    function inner() {
        x++;
        console.log(x);
    };
    return inner;
}
let fn = outer(); // fn = inner, так как функция outer возвращает функцию inner
// вызываем внутреннюю функцию inner
fn();
fn();
fn();
----

----
6
7
8
----

Здесь функция `outer` задает область видимости, в которой определены внутренняя функция `inner` и переменная `x`. Переменная `x` представляет лексическое окружение для функции `inner`. В самой функции `inner` инкрементируем переменную `x` и выводим ее значение на консоль. В конце функция `outer` возвращает функцию `inner`.

Далее вызываем функцию `outer`:

[source, javascript]
----
let fn = outer();
----

Поскольку функция `outer` возвращает функцию `inner`, то переменная `fn` будет хранить ссылку на функцию `inner`. При этом эта функция запомнила свое окружение - то есть внешнюю переменную `x`.

Далее фактически три раза вызываем функцию `Inner`, и видно, что переменная `x`, которая определена вне функции `inner`, инкрементируется:

[source, javascript]
----
fn();
fn();
fn();
----

----
6
7
8
----

То есть несмотря на то, что переменная `x` определена вне функции `inner`, эта функция запомнила свое окружение и может его использовать, несмотря на то, что она вызывается вне функции `outer`, в которой была определена. В этом и суть замыканий.

=== Пример

Рассмотрим следующий пример:

[source, javascript]
----
function multiply(n) {
    var x = n;
    return function(m) { return x * m;};
}
var fn1 = multiply(5);
var result1 = fn1(6);
console.log(result1);

var fn2= multiply(4);
var result2 = fn2(6);
console.log(result2);
----

----
30
24
----

Итак, здесь вызов функции `multiply()` приводит к вызову другой внутренней функции. Внутренняя же функция:

[source, javascript]
----
function(m) { return x * m;};
----

Запоминает окружение, в котором она была создана, в частности, значение переменной `x`.

В итоге при вызове функции `multiply` определяется переменная `fn1`, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной, которая была в области действия функции `multiply` во время создания замыкания.

То есть `fn1` — это замыкание, которое содержит и внутреннюю функцию `function(m) { return x * m;}`, и переменную `x`, которая существовала во время создания замыкания.

При создании двух замыканий: `fn1` и `fn2`, для каждого из этих замыканий создается свое окружение.

При этом важно не запутаться в параметрах. При определении замыкания:

[source, javascript]
----
var fn1 = multiply(5);
----

Число `5` передается для параметра `n` функции `multiply`.

При вызове внутренней функции:

[source, javascript]
----
var result1 = fn1(6);
----

Число `6` передается для параметра `m` во внутреннюю функцию `function(m) { return x * m;};`.

Также можно использовать другой вариант для вызова замыкания:

[source, javascript]
----
function multiply(n) {
    var x = n;
    return function(m) { return x * m;};
}
var result = multiply(5)(6);
console.log(result);
----

----
30
----

== Функции IIFE (Самовызывающиеся функции)

Обычно определение функции отделяется от ее вызова: сначала определяем функцию, а потом вызываем. Но это необязательно. Также можем создать такие *функции, которые будут вызываться сразу при определении*. Такие функции еще называют *Immediately Invoked Function Expression* (*IIFE*).

[source, javascript]
----
(function() {
    console.log("Привет мир");
}());

(function (n) {
    var result = 1;
    for (var i = 1; i <= n; i++)
        result *=i;
    console.log("Факториал числа " + n + " равен " + result);
}(4));
----

----
Привет мир
Факториал числа 4 равен 24
----

Подобные функции заключаются в скобки, и после определения функции идет в скобках передача параметров.

== Паттерн Модуль

*Паттерн Модуль* базируется на замыканиях и состоит из двух компонентов: *внешняя функция*, которая определяет лексическое окружение, и *возвращаемый набор внутренних функций*, которые имеют доступ к этому окружению.

Определим простейший модуль:
[source, javascript]
----
let foo = (function() {
    let obj = {greeting: "hello"};
    return {
        display: function() {
            console.log(obj.greeting);
        }
    }
})();
foo.display();
----

----
hello
----

Здесь определена переменная `foo`, которая представляет результат анонимной функции. Внутри подобной функции определен объект `obj` с некоторыми данными.

Сама анонимная функция возвращает объект, который определяет функцию `display()`. Возвращаемый объект определяет общедоступный *API*, через который можно обращаться к данным, определенным внутри модуля.

[source, javascript]
----
return {
    display: function() {
        console.log(obj.greeting);
    }
}
----

Такая конструкция позволяет закрыть некоторый набор данных в рамках функции-модуля и опосредовать доступ к ним через определенный *API* - возвращаемые внутренние функции.

Рассмотрим чуть более сложный пример:

[source, javascript]
----
let calculator = (function() {
    let data = { number: 0};

    return {
        sum: function(n) {
            data.number += n;
        },
        subtract: function(n) {
            data.number -= n;
        },
        display: function() {
            console.log("Result: ", data.number);
        }
    }
})();
calculator.sum(10);
calculator.sum(3);
calculator.display();
calculator.subtract(4);
calculator.display();
----

----
Result: 13
Result: 9
----

Данный модуль представляет примитивный калькулятор, который выполняет три операции: сложение, вычитание и вывод результата.

Все данные сокрыты в объекте `data`, который хранит результат операции. Все операции представлены тремя возвращаемыми функциями: `sum()`, `subtract()` и `display()`. Через эти функции можно управлять результатом калькулятора извне.

== Рекурсивные функции

Среди функций отдельно можно выделить *рекурсивные функции*. Их суть состоит в том, что *функция вызывает саму себя*.

Например, рассмотрим функцию, определяющую факториал числа:

[source, javascript]
----
function getFactorial(n) {
    if (n === 1) {
        return 1;
    } else {
        return n * getFactorial(n - 1);
    }
}
var result = getFactorial(4);
console.log(result);
----

----
24
----

Функция `getFactorial()` возвращает значение 1, если параметр `n` равен `1`, либо возвращает результат опять же функции `getFactorial`, то в нее передается значение `n-1`. Например, при передаче числа `4`, у нас образуется следующая цепочка вызовов:

[source, javascript]
----
var result = 4 * getFactorial(3);
var result = 4 * 3 * getFactorial(2);
var result = 4 * 3 * 2 * getFactorial(1);
var result = 4 * 3 * 2 * 1; // 24
----

Рассмотрим другой пример - определение *чисел Фибоначчи*:

[source, javascript]
----
function getFibonachi(n) {
    if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    } else {
        return getFibonachi(n - 1) + getFibonachi(n - 2);
    }
}
var result = getFibonachi(8);
console.log(result);
----

----
21
----

== Переопределение функций

*Функции* обладают возможностью для *переопределения поведения*. Переопределение происходит с помощью присвоения анонимной функции переменной, которая называется так же, как и переопределяемая функция:

[source, javascript]
----
function display() {
    console.log("Доброе утро");
    display = function() {
        console.log("Добрый день");
    }
}

display();
display();
----

----
Доброе утро
Добрый день
----

При первом срабатывании функции действует основной блок операторов функции, в частности, в данном случае выводится сообщение `Доброе утро`. И при первом срабатывании функции `display()` также происходит ее переопределение. Поэтому при всех последующих вызовах функции срабатывает ее переопределенная версия, а на консоль будет выводиться сообщение `Добрый день`.

Но при переопределении функции надо учитывать некоторые нюансы. В частности, попробуем присвоить ссылку на функцию переменной и через эту переменную вызвать функцию:

[source, javascript]
----
function display() {
    console.log("Доброе утро");
    display = function() {
        console.log("Добрый день");
    }
}
// присвоение ссылки на функцию до переопределения
var displayMessage = display;
display();
display();
displayMessage();
displayMessage();
----

----
Доброе утро
Добрый день
Доброе утро
Доброе утро
----

Здесь переменная `displayMessage` получает ссылку на функцию `display()` до ее переопределения. Поэтому при вызове `displayMessage()` будет вызываться не переопределенная версия функции `display`.

Но допустим, определили переменную `displayMessage` уже после вызова функции `display()`:

[source, javascript]
----
display();
display();
var displayMessage = display;
displayMessage();
displayMessage();
----

----
Доброе утро
Добрый день
Добрый день
Добрый день
----

В этом случае переменная `displayMessage` будет указывать на переопределенную версию функции `display()`.

== Hoisting

*Hoisting* представляет процесс доступа к переменным до их определения. Возможно, данная концепция выглядит немного странно, но она связана с работой компилятора *JavaScript*. Компиляция кода происходит в два прохода. При первом проходе компилятор получает все объявления переменных, все идентификаторы. При этом никакой код не выполняется, методы не вызываются. При втором проходе собственно происходит выполнение. И даже если переменная определена после непосредственного использования, ошибки не возникнет, так как при первом проходе компилятору уже известны все переменные.

То есть как будто происходит *поднятие кода с определением переменных и функций вверх* до их непосредственного использования. Поднятие на английский переводится как *hoisting*, сообственно поэтому данный процесс так и называется.

Переменные, которые попадают под *hoisting*, получают значение `undefined`.

Например, возьмем следующий простейший код:

[source, javascript]
----
console.log(foo);
----

Его выполнение вызовет ошибку

----
Uncaught ReferenceError: foo is not defined
----

Добавим определение переменной:

[source, javascript]
----
console.log(foo);
var foo = "Tom";
----

----
undefined
----

В этом случае консоль выведет значение `undefined`. При первом проходе компилятор узнает про существование переменной `foo`. Она получает значение `undefined`. При втором проходе вызывается метод `console.log(foo)`.

Возьмем другой пример:

[source, javascript]
----
var c = a * b;
var a = 7;
var b = 3;
console.log(c);
----

----
NaN
----

Здесь та же ситуация. Переменные `a` и `b` используются до определения. По умолчанию им присваиваются значения `undefined`. А если умножить `undefined` на `undefined`, то получим *Not a Number* (`NaN`).

Все то же самое относится и к использованию функций. Можно сначала вызвать функцию, а потом уже ее определить:

[source, javascript]
----
display();

function display() {
    console.log("Hello Hoisting");
}
----

----
Hello Hoisting
----

Здесь функция `display` благополучно отработает, несмотря на то, что она определена после вызова.

Но от этой ситуации надо отличать тот случай, когда функция определяется в виде переменной:

[source, javascript]
----
display();

var display = function () {
    console.log("Hello Hoisting");
}
----

В данном случае получим ошибку

----
TypeError: display is not a function
----

При первом проходе компилятор также получит переменную `display` и присвоит ей значение `undefined`. При втором проходе, когда надо будет вызывать функцию, на которую будет ссылаться эта переменная, компилятор увидит, что вызывать то нечего: переменная `display` пока еще равна `undefined`. И будет выброшена ошибка.

Поэтому при определении переменных и функций следует учитывать такой аспект как *hoisting*.

== Передача параметров по значению и по ссылке

=== Передача параметров по значению

*Строки, числа, логические значения передаются в функцию по значению*. Иными словами при передаче значения в функцию, эта функция получает копию данного значения. Рассмотрим, что это значит в практическом плане:

[source, javascript]
----
function change(x) {
    x = 2 * x;
    console.log("x in change:", x);
}

var n = 10;
console.log("n before change:", n);
change(n);
console.log("n after change:", n);
----

----
n before change: 10
x in change: 20
n after change: 10
----

Функция `change` получает некоторое число и увеличивает его в два раза. При вызове функции `change` ей передается число `n`. Однако после вызова функции видно, что число `n` не изменилось, хотя в самой функции произошло увеличение значения параметра. Потому что при вызове функция `change` получает копию значения переменной `n`. И любые изменения с этой копией никак не затрагивают саму переменную `n`.

=== Передача по ссылке

*Объекты и массивы передаются по ссылке*. То есть функция получает сам объект или массив, а не их копию.

[source, javascript]
----
function change(user) {
    user.name = "Tom";
}

var bob = {
    name: "Bob"
};
console.log("before change:", bob.name);
change(bob);
console.log("after change:", bob.name);
----

----
Bob
Tom
----

В данном случае функция `change` получает объект и меняет его свойство `name`. В итоге увидим, что после вызова функции изменился оригинальный объект `bob`, который передавался в функцию.

Однако если переустановить объект или массив полностью, оригинальное значение не изменится.

[source, javascript]
----
function change(user) {
    // полная переустановка объекта
    user= {
        name:"Tom"
    };
}

var bob = {
    name: "Bob"
};
console.log("before change:", bob.name);
change(bob);
console.log("after change:", bob.name);
----

----
Bob
Bob
----

То же самое касается массивов:

[source, javascript]
----
function change(array) {
    array[0] = 8;
}

function changeFull(array) {
    array = [9, 8, 7];
}

var numbers = [1, 2, 3];

console.log("before change: ", numbers);
change(numbers);
console.log("after change: ", numbers);
changeFull(numbers);
console.log("after changeFull: ", numbers);
----

----
before change: [ 1, 2, 3 ]
after change: [ 8, 2, 3 ]
after changeFull: [ 8, 2, 3 ]
----

== Стрелочные функции

*Стрелочные функции* (*arrow functions*) представляют сокращенную версию обычных функций. *Стрелочные функции* образуются с помощью знака стрелки `\=>`, перед которым в скобках идут параметры функции, а после - собственно тело функции.

[source, javascript]
----
let sum = (x, y) => x + y;
let a = sum(4, 5); // 9
let b = sum(10, 5); // 15
----

В данном случае функция `(x, y) \=> x + y` осуществляет сложение двух чисел и присваивается переменной `sum`. Функция принимает два параметра - `x` и `y`. Ее тело составляет сложение значений этих параметров. И поскольку после стрелки фактически идет конкретное значение, которое представляет сумму чисел, то функция возвращает это значение. И можно через переменную `sum` вызвать данную функцию и получить ее результат в переменные `a` и `b`.

Если после стрелки идет операция или выражение, которое возвращает значение, то это значение фактически возвращается из стрелочной функции. Но также в качестве тела функции может примяться выражение, которое ничего не возвращает и просто выполняет некоторое действие:

[source, javascript]
----
let sum = (x, y) => console.log(x + y);
sum(4, 5); // 9
sum(10, 5); // 15
----

В данном случае функция `console.log()` ничего не возвращает, и соответственно функция `sum` также не возвращает никакого результата.

Если функция принимает один параметр, то скобки вокруг него можно опустить:

[source, javascript]
----
var square = n => n * n;

console.log(square(5));
console.log(square(6));
console.log(square(-7));
----

----
25
36
49
----

Если тело функции представляет набор выражений, то они облекаются в фигурные скобки:

[source, javascript]
----
var square = n => {
    let result = n * n;
    return result;
}

console.log(square(5));
----

----
25
----

Для возвращения результата из функции в таком случае применяется стандартный оператор `return`.

Особо следует остановиться на случае, когда стрелочная функция возвращает объект:

[source, javascript]
----
let user = (userName, userAge) => ({name: userName, age: userAge});

let tom = user("Tom", 34);
let bob = user("Bob", 25);

console.log(tom.name, tom.age);
console.log(bob.name, bob.age);
----

----
Tom 34
Bob 25
----

Объект также определяется с помощью фигурных скобок, но при этом он заключается в круглые скобки.

Если стрелочная функция не принимает никаких параметров, то ставятся пустые скобки:

[source, javascript]
----
var hello = () => console.log("Hello World");
hello();
hello();
----

----
Hello World
Hello World
----
