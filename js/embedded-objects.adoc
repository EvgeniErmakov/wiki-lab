= Встроенные объекты

Кроме возможности создавать свои объекты *JavaScript* также предоставляет набор *встроенных типов объектов*, которые можно применять в различных ситуациях.

== Объект `Date`. Работа с датами

Объект `Date` позволяет работать с датами и временем в *JavaScript*.

Существуют *различные способы создания объекта* `Date`. *Первый способ* заключается в использовании пустого конструктора без параметров:

[source,js]
----
var currentDate = new Date();
document.write(currentDate);
----

В этом случае объект будет указывать *на текущую дату компьютера*.

*Второй способ* заключается в передаче в (конструктор) `Date` количества миллисекунд, которые прошли с начала *эпохи Unix*, то есть с *1 января 1970 года 00:00:00 GMT*:

[source,js]
----
var myDate = new Date(1359270000000);
document.write(myDate); // Sun Jan 27 2013 10:00:00 GMT+0300 (RTZ 2 (зима))
----

Третий способ состоит в передаче в *конструктор* `Date` *дня, месяца* и *года*:

[source,js]
----
var myDate = new Date("27 March 2008");
// или так
// var myDate = new Date("3/27/2008");
document.write(myDate); // Thu Mar 27 2008 00:00:00 GMT+0300 (RTZ 2 (зима))
----

Если используется *полное название месяца*, то оно пишется в *по-английски*, если используем *сокращенный вариант*, тогда используется формат *месяц/день/год*.

Четвертый способ состоит в передаче в *конструктор* `Date` *всех параметров даты и времени*:

[source,js]
----
var myDate = new Date(2012, 11, 25, 18, 30, 20, 10); // Tue Dec 25 2012 18:30:20 GMT+0300 (RTZ 2 (зима))
----

При этом надо учитывать, что отсчет месяцев начинается *с нуля*, то есть *январь - 0*, а *декабрь - 11*.

=== Получение даты и времени

Для получения различных компонентов даты применяется ряд методов:

* `getDate()`: возвращает день месяца
* `getDay()`: возвращает день недели (отсчет начинается с `0` - воскресенье, и последний день - `6` - суббота)
* `getMonth()`: возвращает номер месяца (отсчет начинается с нуля, то есть месяц с номер `0` - январь)
* `getFullYear()`: возвращает год
* `toDateString()`: возвращает полную дату в виде строки
* `getHours()`: возвращает час (от `0` до `23`)
* `getMinutes()`: возвращает минуты (от `0` до `59`)
* `getSeconds()`: возвращает секунды (от `0` до `59`)
* `getMilliseconds()`: возвращает миллисекунды (от `0` до `999`)
* `toTimeString()`: возвращает полное время в виде строки

=== Установка даты и времени

Коме задания параметров даты в конструкторе для установки мы также можем использовать дополнительные *методы* объекта `Date`:

* `setDate()`: установка дня в дате
* `setMonth()`: уставовка месяца (отсчет начинается с нуля, то есть месяц с номер 0 - январь)
* `setFullYear()`: устанавливает год
* `setHours()`: установка часа
* `setMinutes()`: установка минут
* `setSeconds()`: установка секунд
* `setMilliseconds()`: установка миллисекунд

При установке значений есть возможность передать величину, большую, чем максимальное допустимое значение. В данном случае из значения будет высчитано количество целых величин большего порядка.

== Объект `Math`.

=== Математические операции

*Объект* `Math` предоставляет ряд математических функций, которые можно использовать при вычислениях. Рассмотрим основные математические функции.

* `abs()`: возвращает *абсолютное значение* числа.
* `min()` и `max()`: возвращают соответственно *минимальное* и *максимальное* значение из набора чисел.
* `ceil()`: округляет число до *следующего наибольшего целого числа*.
* `floor()`: округляет число до *следующего наименьшего целого числа*.
* `round()`: округляет число до *следующего наименьшего целого числа*, если его десятичная часть *меньше 0.5*. Если же десятичная часть *равна или больше 0.5*, то округление идет до *ближайшего наибольшего целого числа*.
* `random()`: возвращает *случайное число с плавающей точкой* из диапазона *от 0 до 1*.
* `pow()`: возвращает *число в определенной степени*.
* `sqrt()`: возвращает *квадратный корень числа*.
* `log()`: возвращает *натуральный логарифм числа*.

=== Тригонометрические функции

Целый ряд функций представляют *тригонометрические функции*:

* `sin()` - вычисляет синус угла
* `cos()` - вычисляет косинус угла
* `tan()` - вычисляет тангенс угла

в качестве значения они принимают значение *в радианах*.

=== Константы

Кроме методов *объект* `Math` также определяет *набор встроенных констант*, которые можно использовать в различных вычислениях:

* `Math.PI` - число PI: `3.141592653589793`
* `Math.SQRT2` - квадратный корень из двух:` 1.4142135623730951`
* `Math.SQRT1_2` - половина от квадратного корня из двух: `0.7071067811865476`
* `Math.E` - число e или число Эйлера: `2.718281828459045`
* `Math.LN2` - натуральный логарифм числа 2: `0.6931471805599453`
* `Math.LN10` - натуральный логарифм числа 10: `2.302585092994046`
* `Math.LOG2E` - двоичный логарифм числа e: `1.4426950408889634`
* `Math.LOG10E` - десятичный логарифм числа e: `0.4342944819032518`

== Объект `Array`. Работа с массивами

*Объект* `Array` представляет *массив* и предоставляет ряд свойств и методов, с помощью которых мы можем *управлять массивом*.

=== Инициализация массива

Можно создать *пустой массив*, используя *квадратные скобки* или *конструктор* `Array`:

[source,js]
----
var users = new Array();
var people = [];

console.log(users); // Array[0]
console.log(people); // Array[0]
----

Можно сразу же *инициализировать массив* некоторым количеством элементов:

[source,js]
----
var users = new Array("Tom", "Bill", "Alice");
var people = ["Sam", "John", "Kate"];

console.log(users); // ["Tom", "Bill", "Alice"]
console.log(people); // ["Sam", "John", "Kate"]
----

Можно *определить массив* и по ходу определять в него новые элементы:

[source,js]
----
var users = new Array();
users[1] = "Tom";
users[2] = "Kate";
console.log(users[1]);
console.log(users[0]);
----

----
Tom
undefined
----

При этом *не важно*, что по умолчанию массив создается с *нулевой длиной*. С помощью *индексов* мы можем подставить на конкретный индекс в массиве тот или иной элемент.

=== `length`

Чтобы узнать длину массива, используется *свойство* `length`:

[source,js]
----
var fruit = new Array();
fruit[0] = "яблоки";
fruit[1] = "груши";
fruit[2] = "сливы";

console.log("В массиве fruit " + fruit.length + " элемента: <br/>");
for (var i = 0; i < fruit.length; i++) {
    console.log(fruit[i]);
}
----

=== Копирование массива. `slice()`

*Копирование массива* может быть *поверхностным* или *неглубоким* (*shallow copy*) и *глубоким* (*deep copy*).

При *неглубоком копировании* достаточно присвоить переменной значение другой переменной, которая *хранит массив*:

[source,js]
----
var users = ["Tom", "Sam", "Bill"];
console.log(users);
var people = users; // неглубокое копирование

people[1] = "Mike"; // изменяем второй элемент
console.log(users);
----

----
["Tom", "Sam", "Bill"]
["Tom", "Mike", "Bill"]
----

Такое поведение не всегда является желательным. Например, необходимо, чтобы после копирования переменные указывали на отдельные массивы. И в этом случае можно использовать глубокое копирование с помощью *метода* `slice()`:

[source,js]
----
var users = ["Tom", "Sam", "Bill"];
console.log(users);
var people = users.slice(); // глубокое копирование

people[1] = "Mike"; // изменяем второй элемент
console.log(users);
console.log(people);
----

----
["Tom", "Sam", "Bill"]
["Tom", "Sam", "Bill"]
["Tom", "Mike", "Bill"]
----

Также *метод* `slice()` позволяет скопировать *часть массива*:

[source,js]
----
ar users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var people = users.slice(1, 4);
console.log(people);
----

----
["Sam", "Bill", "Alice"]
----

=== `push()`

Метод `push()` добавляет элемент в конец массива.

=== `pop()`

Метод `pop()` удаляет последний элемент из массива.

=== `shift()`

Метод `shift()` извлекает и удаляет первый элемент из массива.

=== `unshift()`

Метод `unshift()` добавляет новый элемент в начало массива.

=== Удаление элемента по индексу. `splice()`

Метод `splice()` удаляет элементы *с определенного индекса*. Например, удаление элементов с третьего индекса:

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(3);
console.log(deleted);
console.log(users);
----

----
["Alice", "Kate"]
["Tom", "Sam", "Bill"]
----

Метод `splice()` возвращает удаленные элементы.

Если в метод передать отрицательный индекс, то удаление будет производиться с конца массива.

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(-1);
console.log(deleted);
console.log(users);
----

----
[ "Kate" ]
[ "Tom", "Sam", "Bill", "Alice" ]
----

Дополнительная версия *метода* позволяет задать *количество* элементов для удаления.

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(1, 3);
console.log(deleted);
console.log(users);
----

----
[ "Sam", "Bill", "Alice" ]
[ "Tom", "Kate" ]
----

Еще одна версия *метода* `splice()` позволяет вставить вместо удаляемых элементов новые элементы:

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(1, 3, "Ann", "Bob");
console.log(deleted);
console.log(users);
----

----
[ "Sam", "Bill", "Alice" ]
[ "Tom", "Ann", "Bob", "Kate" ]
----

=== `concat()`

Метод `concat()` служит для объединения массивов:

[source,js]
----
var fruit = ["яблоки", "груши", "сливы"];
var vegetables = ["помидоры", "огурцы", "картофель"];
var products = fruit.concat(vegetables);

for (var i = 0; i < products.length; i++) {
    console.log(products[i] );
}
----

Также можно объединять разнотипные массивы.

=== `join()`

*Метод* ё объединяет все элементы массива в одну строку:

[source,js]
----
var fruit = ["яблоки", "груши", "сливы", "абрикосы", "персики"];
var fruitString = fruit.join(", ");
console.log(fruitString);
----

В метод `join()` передается *разделитель* между элементами массива. В данном случае в качестве разделителя будет использоваться запятая `,` и пробел ` `).

=== `sort()`

Метод `sort()` сортирует массив по возрастанию.

=== `reverse()`

Метод `reverse()` переворачивает массив задом наперед. В сочетании с методом `sort()` можно отсортировать массив по убыванию.

=== Поиск индекса элемента

==== `indexOf()` и `lastIndexOf()`

Методы `indexOf()` и `lastIndexOf()` возвращают индекс первого и последнего включения элемента в массиве.

==== `every()`

Метод `every()` проверяет, все ли элементы соответствуют определенному условию:

[source,js]
----
var numbers = [ 1, -12, 8, -4, 25, 42 ];
function condition(value, index, array) {
    var result = false;
    if (value > 0) {
        result = true;
    }
    return result;
};
var passed = numbers.every(condition);
console.log(passed);
----

----
false
----

В метод `every()` в качестве параметра передается функция, представляющая условие.

[source,js]
----
function condition(value, index, array) {
}
----

Параметр `value` представляет *текущий перебираемый элемент* массива, параметр `index` представляет *индекс* этого элемента, а параметр `array` передает *ссылку на массив*.

==== `some()`

*Метод* `some()` похож на *метод* `every()`, только он проверяет, соответствует ли *хотя бы один элемент условию*. И в этом случае *метод* `some()` возвращает `true`. Если элементов, соответствующих условию, в массиве нет, то возвращается значение `false`.

==== `filter()`

Метод `filter()`, как `some()` и `every()`, принимает *функцию условия*. Но при этом *возвращает массив* тех элементов, которые соответствуют этому условию.

==== `forEach()` и `map()`

Методы `forEach()` и `map()` осуществляют *перебор элементов* и выполняют с ними определенный операции. Например, для вычисления квадратов чисел в массиве можно использовать следующий код:

[source,js]
----
var numbers = [ 1, 2, 3, 4, 5, 6];
for (var i = 0; i<numbers.length; i++) {
    var result = numbers[i] * numbers[i];
    console.log("Квадрат числа " + numbers[i] + " равен " + result );
}
----

Но с помощью метода `forEach()` можно упростить эту конструкцию:

[source,js]
----
var numbers = [ 1, 2, 3, 4, 5, 6];

function square(value) {
    var result = value * value;
    console.log("Квадрат числа " + value + " равен " + result );
};

numbers.forEach(square);
----

Метод `forEach()` в качестве параметра принимает все ту же функцию, в которую при переборе элементов передается текущий перебираемый элемент и над ним выполняются операции.

Метод `map()` похож на метод `forEach()`, он также в качестве параметра принимает функцию, с помощью которой выполняются операции над перебираемыми элементами массива, но при этом метод `map()` возвращает новый массив с результатами операций над элементами массива.

== Объект `Number`

*Объект `Number`* представляет числа. Чтобы создать число, надо передать в *конструктор* `Number` число или стоку, представляющую число:

[source,js]
----
var x = new Number(34);
var y = new Number('34');
document.write(x + y); // 68
----

Однако *создавать объект* `Number` можно и просто присвоив переменной определенное число:

[source,js]
----
var z = 34;
----

*Объект `Number`* предоставляет ряд свойств и методов. Некоторые его свойства:

* `Number.MAX_VALUE`: наибольшее возможное число. *Приблизительно равно 1.79E+308*. Числа, которые больше этого значения, рассматриваются как `Infinity`
* `Number.MIN_VALUE`: наименьшее возможное положительное число. *Приблизительно равно 5e-324* (где-то около нуля)
* `Number.NaN`: специальное значение, которое указывает, что объект *не является числом*
* `Number.NEGATIVE_INFINITY`: значение, которое обозначает *отрицательную неопределенность* и которое возникает при переполнении. Например, если складывать два отрицательных числа, которые по модулю равны `Number.MAX_VALUE`
* `Number.POSITIVE_INFINITY`: положительная неопределенность. Также, как и отрицательная неопределенность, возникает при переполнении, только теперь в положительную сторону
* `parseFloat()`: преобразует строку в число с плавающей точкой.
* `parseInt():` преобразует строку в целое число.
* `toFixed()`: оставляет в числе с плавающей точкой определенное количество знаков в дробной части.
* `isNaN()`: определяет, *является ли объект числом*. Если объект *не является числом*, то возвращается значение `true`.

Но следующее выражение вернет `false`, хотя значение не является числом:

[source,js]
----
var f = Number.isNaN("hello"); // false
----

Чтобы избежать подобных ситуаций, лучше применять глобальную функцию `isNaN()`:

[source,js]
----
var f = isNaN("hello"); // true
----
