= Основы синтаксиса
:imagesdir: ../assets/img/js

== Инструкции

Код *JavaScript* состоит из инструкций, каждая из которых завершается точкой запятой:

[source, javascript]
----
alert("Вычисление выражения"); var a = 5 + 8; alert(a);
----

Однако современные браузеры вполне могут различать отдельные инструкции, если они просто располагаются на отдельных строках без точки запятой:

[source, javascript]
----
alert("Вычисление выражения")
var a = 5 + 8
alert(a)
----

Но чтобы улучшить читабельность кода и снизить число возможных ошибок, рекомендуется определять каждую инструкцию *JavaScript* на отдельной строчке и завершать ее точкой с запятой.

[source, javascript]
----
alert("Вычисление выражения");
var a = 5 + 8;
alert(a);
----

== Комментарии

В коде *JavaScript* могут использоваться *комментарии*, они не обрабатываются интерпретатором *JavaScript* и никак не учитываются в работе программы. *Комментарии* предназначен для ориентации по коду, чтобы указать, что делает тот или иной код.

*Комментарии* могут быть *однострочными*, для которых используется двойной слэш `//`:

[source, javascript]
----
// вывод сообщения
alert("Вычисление выражения");
// арифметическая операция
var a = 5 + 8;
alert(a);
----

Кроме *однострочных* комментариев могут использоваться и *многострочные* комментарии. Такие комментарии заключаются между символами `/* текст комментария */`. Например:

[source, javascript]
----
// вывод сообщения
/* вывод сообщения и
арифметическая операция */
alert("Вычисление выражения");
var a = 5 + 8;
alert(a);
----

== Переменные

Для хранения данных в программе используются *переменные*, они предназначены для хранения каких-нибудь временных данных или таких данных, которые в процессе работы могут менять свое значение.

Для создания переменных применяются ключевые слова `var` и `let`. Например, объявим переменную `myIncome`:

[source, javascript]
----
var myIncome;
// другой вариант
let myIncome2;
----

Каждая *переменная имеет имя*, оно представляет собой произвольный набор алфавитно-цифровых символов, знака подчеркивания `_` или знака доллара `$`, причем названия не должны начинаться с цифровых символов. То есть можно использовать в названии буквы, цифры, подчеркивание. Однако все остальные символы запрещены.

*Например*, правильные названия переменных:

[source, javascript]
----
$commision
someVariable
product_Store
income2
myIncome_from_deposit
----

Следующие названия являются некорректными и не могут использоваться:

[source, javascript]
----
222lol
@someVariable
my%percent
----

Также нельзя давать переменным такие имена, которые совпадают с зарезервированными ключевыми словами. В *JavaScript* не так много ключевых слов, поэтому данное правило несложно соблюдать. Например, следующее название будет некорректным, так как `for` - ключевое слово в *JavaScript*:

[source, javascript]
----
var for;
----

*Список зарезервированных слов* в JavaScript:

[source, javascript]
----
abstract, boolean, break, byte, case, catch, char, class, const, continue, debugger, default, delete, do, double, else, enum, export, extends, false, final, finally, float, for, function, goto, if, implements, import, in, instanceof, int, inteface, long, native, new, null, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, true, try, typeof, var, volatile, void, while, with
----

При названии переменных надо учитывать, что *JavaScript* является *регистрозависимым языком*, то есть в следующем коде объявлены две разные переменные:

[source, javascript]
----
var myIncome;
var MyIncome;
----

Через запятую можно определить сразу несколько переменных:

[source, javascript]
----
var myIncome, procent, sum;
let a, b, c;
----

С помощью знака равно `=` можно присвоить переменной какое-либо значение:

[source, javascript]
----
var income = 300;
let price = 76;
----

Процесс присвоения переменной начального значения называется *инициализацией*. Теперь переменная `income` будет хранить число `300`, а переменная `price` - число `76`. Отличительной чертой переменных является то, что можно изменить их значение:

[source, javascript]
----
var income = 300;
income = 400;
console.log(income);

let price = 76;
price = 54;
console.log(price);
----

== Константы

С помощью ключевого слова `const` можно определить *константу*, которая, как и переменная, хранит значение, однако это значение не может быть изменено.

[source, javascript]
----
const rate = 10;
----

Если попробовать изменить ее значение, то возникнет ошибка:

[source, javascript]
----
const rate = 10;
rate = 23;  // ошибка, rate - константа, поэтому  нельзя изменить ее значение
----

Также стоит отметить, что поскольку нельзя изменить значение константы, то *константа должна быть инициализирована*, то есть при ее определении необходимо предоставить ей начальное значение. Если этого не сделать, возникнет ошибка:

[source, javascript]
----
const rate; // ошибка, rate не инициализирована
----

== Типы данных

Все используемые данные в *JavaScript* имеют определенный тип. В *JavaScript* имеется *пять примитивных* типов данных:

* `String`: представляет строку
* `Number`: представляет числовое значение
* `Boolean`: представляет логическое значение `true` или `false`
* `undefined`: указывает, что значение не установлено
* `null`: указывает на неопределенное значение

Все данные, которые не попадают под вышеперечисленные пять типов, относятся к типу `object`.

=== Числовые данные

Числа в *JavaScript* могут иметь две формы:

* *Целые числа*, например, `35`. Можно использовать как положительные, так и отрицательные числа. Диапазон используемых чисел: *от* `-2^53` *до* `2^53`.
* *Дробные числа* (*числа с плавающей точкой*), например, `3.5575`. Опять же можно использовать как положительные, так и отрицательные числа. Для чисел с плавающей точкой используется тот же диапазон: *от* `-2^53` *до* `2^53`.

[source, javascript]
----
var x = 45;
var y = 23.897;
----

В качестве разделителя между целой и дробной частями, как и в других языках программирования, используется точка.

=== Строки

Тип `string` представляет *строки*, то есть такие данные, которые заключены в кавычки. Причем можно использовать как двойные, так и одинарные кавычки.

[source, javascript]
----
var helloWorld = "Привет мир";
var helloWorld2 = 'Привет мир';
----

Единственно ограничение: тип закрывающей кавычки должен быть тот же, что и тип открывающей, то есть либо обе двойные, либо обе одинарные кавычки.

[source, javascript]
----
var helloWorld = 'Привет мир"; // ошибка
----

Если внутри строки встречаются кавычки, то их нужно экранировать слэшем `\`. Например, пусть у нас есть текст `Бюро "Рога и копыта`. Теперь экранируем кавычки:

[source, javascript]
----
var companyName = "Бюро \"Рога и копыта\"";
----

Также можно внутри стоки использовать другой тип кавычек:

[source, javascript]
----
var companyName1 = "Бюро 'Рога и копыта'";
var companyName2 = 'Бюро "Рога и копыта"';
----

=== Тип `Boolean`

*Тип `Boolean`* представляет булевы или логические значения `true` и `false` (то есть да или нет):

[source, javascript]
----
var isAlive = true;
var isDead = false;
----

=== `null` и `undefined`

Нередко возникает путаница между `null` и `undefined`. Итак, когда только определяется переменная без присвоения ей начального значения, она представляет тип `undefined`:

[source, javascript]
----
var isAlive;
console.log(isAlive);
----

----
undefined
----

Присвоение значение `null` означает, что переменная имеет некоторое неопределенное значение (не число, не строка, не логическое значение), но все-таки имеет значение. `undefined` означает, что переменная не имеет значения.

[source, javascript]
----
var isAlive;
console.log(isAlive); // undefined
isAlive = null;
console.log(isAlive); // null
isAlive = undefined;  // снова установим тип undefined
console.log(isAlive); // undefined
----

=== `object`

*Тип `object`* представляет сложный объект. Простейшее определение объекта представляют фигурные скобки:

[source, javascript]
----
var user = {};
----

Объект может иметь различные свойства и методы:

[source, javascript]
----
var user = {name: "Tom", age:24};
console.log(user.name);
----

----
Tom
----

В данном случае объект называется `user`, и он имеет два свойства: `name` и `age`. Это краткое описание объектов.

=== Слабая типизация

*JavaScript* является *языком со слабой типизацией*. Это значит, что переменные могут динамически менять тип.

[source, javascript]
----
var xNumber; // тип `undefined`
console.log(xNumber);
xNumber = 45; // тип `number`
console.log(xNumber);
xNumber = "45"; // тип `string`
console.log(xNumber);
----

----
undefined
45
45
----

Несмотря на то, что во втором и третьем случае консоль выведет число `45`, но во втором случае переменная `xNumber` будет представлять число, а в третьем случае - строку.

Это важный момент, который надо учитывать. От этого зависит поведение переменной в программе:

[source, javascript]
----
var xNumber = 45; // тип `number`
var yNumber = xNumber + 5;
console.log(yNumber);

xNumber = "45"; // тип `string`
var zNumber = xNumber + 5
console.log(zNumber);
----

----
50
455
----

Выше в обоих случая к переменной `xNumber` применяется операция сложения `+`. Но в первом случае `xNumber` представляет число, поэтому результатом операции `xNumber + 5` будет число `50`.

Во втором случае `xNumber` представляет строку. Но операция сложения между строкой и числом `5` невозможна. Поэтому число `5` будет преобразовываться к строке, и будет происходить операция объединения строк. И результатом выражения `xNumber + 5` будет стока `"455"`.

== Операторы

=== Оператор `typeof`

С помощью оператора `typeof` можно получить тип переменной:

[source, javascript]
----
var name = "Tom";
console.log(typeof name);
var income = 45.8;
console.log(typeof income);
var isEnabled = true;
console.log(typeof isEnabled);
var undefVariable;
console.log(typeof undefVariable);
----

----
string
number
boolean
undefined
----

=== Математические операторы

`JavaScript` поддерживает все базовые математические операции:

* *Сложение*:

[source, javascript]
----
var x = 10;
var y = x + 50;
----

* *Вычитание*:

[source, javascript]
----
var x = 100;
var y = x - 50;
----

* *Умножение*:

[source, javascript]
----
var x = 4;
var y = 5;
var z = x * y;
----

* *Деление*:

[source, javascript]
----
var x = 40;
var y = 5;
var z = x / y;
----

* *Деление по модулю* (оператор `%`) возвращает остаток от деления:

[source, javascript]
----
var x = 40;
var y = 7;
var z = x % y;
console.log(z);
----

----
5
----

Результатом будет `5`, так как наибольшее целое число, которое меньше или равно `40` и при этом делится на `7` равно `35`, а `40 - 35 = 5`.

==== Инкремент

[source, javascript]
----
var x = 5;
x++;
console.log(x);
----

----
6
----

Оператор инкремента `++` увеличивает переменную на единицу. Существует *префиксный инкремент*, который сначала увеличивает переменную на единицу, а затем возвращает ее значение:

[source, javascript]
----
var x = 5;
var z = ++x;
console.log(x);
console.log(z);
----

----
6
6
----

И есть *постфиксный инкремент*, который сначала возвращает значение переменной, а затем увеличивает его на единицу:

[source, javascript]
----
var a = 5;
var b = a++;
console.log(a);
console.log(b);
----

----
6
5
----

*Постфиксный инкремент аналогичен операции*:

[source, javascript]
----
a = a + 1; // a++
----

==== Декремент

*Декремент* уменьшает значение переменной на единицу. Также есть *префиксный и постфиксный декремент*:

[source, javascript]
----
// префиксный декремент
var x = 5;
var z = --x;
console.log(x);
console.log(z);
----

----
4
4
----

[source, javascript]
----
// постфиксный декремент
var a = 5;
var b = a--;
console.log(a);
console.log(b);
----

----
4
5
----

Как и принято в математике, все операции выполняются слева направо и различаются по приоритетам: сначала операции инкремента и декремента, затем выполняются умножение и деление, а потом сложение и вычитание. Чтобы изменить стандартный ход выполнения операций, часть выражений можно поместить в скобки:

[source, javascript]
----
var x = 10;
var y = 5 + (6 - 2) * --x;
console.log(y); //41
----

=== Операции присваивания

* `=` +
*Приравнивает* переменной определенное значение: `var x = 5`;

* `+=` +
*Сложение* с последующим присвоением результата. *Например:* +

[source, javascript]
----
var a = 23;
a += 5; // аналогично a = a + 5
console.log(a);
----

----
28
----

* `-=` +
*Вычитание* с последующим присвоением результата. *Например:*

[source, javascript]
----
var a = 28;
a -= 10; // аналогично a = a - 10
console.log(a);
----

----
18
----

* `\*=` +
*Умножение* с последующим присвоением результата:

[source, javascript]
----
var x = 20;
x *= 2; // аналогично x = x * 2
console.log(x);
----

----
40
----

* `/=` +
*Деление* с последующим присвоением результата:

[source, javascript]
----
var x = 40;
x /= 4; // аналогично x = x / 4
console.log(x);
----

----
10
----

* `%=` +
*Получение остатка от деления* с последующим присвоением результата:

[source, javascript]
----
var x = 10;
x %= 3; // аналогично x = x % 3
console.log(x);
----

----
1
----

=== Операторы сравнения

Как правило, для проверки условия используются *операторы сравнения*. Операторы сравнения сравнивают два значения и возвращают значение `true` или `false`:

* `==` +
Оператор равенства сравнивает два значения, и если они равны, возвращает `true`, иначе возвращает `false`: `x == 5`

* `===` +
Оператор тождественности также сравнивает два значения и их тип, и если они равны, возвращает `true`, иначе возвращает `false`: `x === 5`

* `!=` +
Сравнивает два значения, и если они не равны, возвращает `true`, иначе возвращает``false`: `x != 5`

* `!==` +
Сравнивает два значения и их типы, и если они не равны, возвращает `true`, иначе возвращает `false`: `x !== 5`

* `>`

Сравнивает два значения, и если первое больше второго, то возвращает `true`, иначе возвращает `false`: `x > 5`

* `<`

Сравнивает два значения, и если первое меньше второго, то возвращает `true`, иначе возвращает `false`: `x < 5`

* `>=`

Сравнивает два значения, и если первое больше или равно второму, то возвращает `true`, иначе возвращает `false`: `x >= 5`

* `\<=`

Сравнивает два значения, и если первое меньше или равно второму, то возвращает `true`, иначе возвращает `false`: `x \<= 5`

Все операторы довольно просты, наверное, за исключением оператора равенства и оператора тождественности. Они оба сравнивают два значения, но оператор тождественности также принимает во внимание и тип значения. *Например:*

[source, javascript]
----
var income = 100;
var strIncome = "100";
var result = income == strIncome;
console.log(result);
----

----
true
----

Переменная `result` здесь будет равна `true`, так как фактически и `income`, и `strIncome` представляют число `100`.

Но оператор тождественности возвратит в этом случае `false`, так как данные имеют разные тип:

[source, javascript]
----
var income = 100;
var strIncome = "100";
var result = income === strIncome;
console.log(result);
----

----
false
----

Аналогично работают операторы неравенства `!=` и `!==`.

=== Логические операции

*Логические операции* применяются для объединения результатов двух операций сравнения. В *JavaScript* есть следующие логические операции:

* `&&`

Возвращает `true`, если обе операции сравнения возвращают `true`, иначе возвращает `false`:

[source, javascript]
----
var income = 100;
var percent = 10;
var result = income > 50 && percent < 12;
console.log(result);
----

----
true
----

* `||`

Возвращает `true`, если хотя бы одна операция сравнения возвращают `true`, иначе возвращает `false`:

[source, javascript]
----
var income = 100;
var isDeposit = true;
var result = income > 50 || isDeposit == true;
console.log(result);
----

----
true
----

* `!`

Возвращает `true`, если операция сравнения возвращает `false`:

[source, javascript]
----
var income = 100;
var result1 = !(income > 50);
console.log(result1);

var isDeposit = false;
var result2 = !isDeposit;
console.log(result2);
----

----
false
true
----

=== Операции со строками

Строки могут использовать оператор `+` для объединения.

[source, javascript]
----
var name = "Том";
var surname = "Сойер"
var fullname = name + " " + surname;
console.log(fullname);
----

----
Том Сойер
----

Если одно из выражений представляет строку, а другое - число, то число преобразуется к строке и выполняется операция объединения строк:

[source, javascript]
----
var name = "Том";
var fullname = name + 256;
console.log(fullname);
----

----
Том256
----

=== Пример

Программа, которая продемонстрирует работу с операциями над переменными.

[source, html]
----
<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8" />
    <title>JavaScript</title>
</head>
<body>
    <script>
        var sum = 500; // сумма вклада
        var percent = 10;  // процент по вкладу
        var income = sum * percent / 100;  // доход по вкладу
        sum = sum + income; // определяем новую сумму
        console.log("Доход по вкладу: " + income);
        console.log("Сумма вклада после первого года: " + sum);
    </script>
</body>
</html>
----

В скрипте объявляются три переменных: `sum`, `percent` и `income`. Переменная `income` вычисляется по остальным двум переменным с помощью операций умножения и деления. И в конце ее значение суммируется со значением переменной `sum`.

И консоль браузера выведет:

image::operations-with-variables.png[Результат операций с переменными, align=center]

== Преобразование данных

Нередко возникает необходимость преобразовать одни данные в другие. Например:

[source, javascript]
----
var number1 = "46";
var number2 = "4";
var result = number1 + number2;
console.log(result);
----

----
464
----

Обе переменных представляют строки, а точнее строковые представления чисел. И в итоге получим не число `50`, а строку `464`. Но было бы неплохо, если бы их тоже можно было бы складывать, вычитать, в общем работать как с обычными числами.

В этом случае можно использовать *операции преобразования*. Для преобразования строки в число применяется функция `parseInt()`:

[source, javascript]
----
var number1 = "46";
var number2 = "4";
var result = parseInt(number1) + parseInt(number2);
console.log(result);
----

----
50
----

Для преобразования строк в дробные числа применяется функция `parseFloat()`:

[source, javascript]
----
var number1 = "46.07";
var number2 = "4.98";
var result = parseFloat(number1) + parseFloat(number2);
console.log(result);
----

----
51.05
----

При этом строка может иметь смешанное содержимое, например, `123hello`, то есть в данном случае есть цифры, но есть и обычные символы. Но метод `parseInt()` все равно попытается выполнить преобразование:

[source, javascript]
----
var num1 = "123hello";
var num2 = parseInt(num1);
console.log(num2);
----

----
123
----

Если методу не удастся выполнить преобразование, то он возвращает значение `NaN` (*Not a Number*), которое говорит о том, что строка не представляет число и не может быть преобразована.

С помощью специальной функции `isNaN()` можно проверить, представляет ли строка число. Если строка не является числом, то функция возвращает `true`, если это число - то `false`:

[source, javascript]
----
var num1 = "javascript";
var num2 = "22";
var result = isNaN(num1);
console.log(result);

result = isNaN(num2);
console.log(result);
----

----
true
false
----

Выше был рассмотрен перевод строк в числа в десятичной системе. Однако можно переводить числа в любую систему. По умолчанию интерпретатор *JavaScript* сам определяет, в число из какой системы исчисления хотели преобразовать строку, как правило, выбирается десятичная система. Но можно с помощью второго параметра явно указать, что хотим преобразовать строку в число в определенной системе.

.Преобразование в число в двоичной системе
[source, javascript]
----
var num1 = "110";
var num2 = parseInt(num1, 2);
console.log(num2);
----

----
6
----

Результатом будет `6`, так как `110` в двоичной системе - это число `6` в десятичной.

=== Пример

Теперь напишем небольшую программу, в которой используем операции с переменными:

[source, html]
----
<!DOCTYPE html>
    <html>
        <head>
        <meta charset="utf-8" />
        <title>JavaScript</title>
        </head>
    <body>
        <script>
            var strSum = prompt("Введите сумму вклада", 1000);
            var strPercent = prompt("Введите процентную ставку", 10);
            var sum = parseInt(strSum);
            var procent = parseInt(strPercent);
            sum = sum + sum * procent / 100;
            alert("После начисления процентов сумма вклада составит: " + sum);
        </script>
    </body>
</html>
----

С помощью функции `prompt()` в браузере выводится диалоговое окно с предложением ввести некоторое значение. Второй аргумент в этой функции указывает на значение, которое будет использоваться по умолчанию.

Однако функция `prompt()` возвращает строку. Поэтому эту строку необходимо преобразовать в число, чтобы выполнить с ней операции.

После открытия страницы в браузере увидим приглашение к вводу суммы вклада:

image::invitation-enter-deposit-amount.png[приглашение к вводу суммы, align=center]

Затем подобное сообщение отобразится и для ввода процента. И в конце программа получит данные, преобразует их в числа и выполнит подсчет:

image::counting-results.png[результаты подсчета, align=center]

== Массивы

Для работы с наборами данных предназначены *массивы*. Для создания массива применяется выражение `new Array()`:

[source, javascript]
----
var myArray = new Array();
----

Существует также более короткий способ инициализации массива:

[source, javascript]
----
var myArray = [];
----

В данном случае создаётся пустой массив. Но можно также добавить в него начальные данные:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people);
----

В этом случае в массиве `myArray` будет три элемента. Его можно представить в виде таблицы так:

[options="header"]
|===
|Индекс|Элемент
|0|`Tom`
|1|`Alice`
|2|`Sam`
|===

Для обращения к отдельным элементам массива используются индексы. Отсчет начинается с нуля, то есть первый элемент будет иметь индекс *0*, а последний - *2*:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[0]);
var person3 = people[2];
console.log(person3);
----

----
Tom
Sam
----

Если попробовать обратиться к элементу по индексу больше размера массива, то получим `undefined`:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[7]);
----

----
undefined
----

Также по индексу осуществляется установка значений для элементов массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[0]);
people[0] = "Bob";
console.log(people[0]);
----

----
Tom
Bob
----

Причем в отличие от других языков, как *Java* или *C#*, можно установить элемент, который изначально не установлен:

[source, javascript]
----
var people = ["Tom", "Alice", "Sam"];
console.log(people[7]);
people[7] = "Bob";
console.log(people[7]);
----

----
undefined
Bob
----

Также стоит отметить, что в отличие от ряда языков программирования в *JavaScript* *массивы не являются строго типизированными*, один массив может хранить данные разных типов:

[source, javascript]
----
var objects = ["Tom", 12, true, 3.14, false];
console.log(objects);
----

=== spread-оператор

*spread-оператор* `...` позволяет взять значения из массива по отдельности:

[source, javascript]
----
let numbers = [1, 2, 3, 4];
console.log(...numbers);
console.log(numbers);
----

----
1 2 3 4
[1, 2, 3, 4]
----

*spread-оператор* указывается перед массивом. В результате выражение `...numbers` возвратит набор чисел, но это будет не массив, а именно отдельные значения.

=== Многомерные массивы

Массивы могут быть *одномерными* и *многомерными*. Каждый элемент в многомерном массиве может представлять собой отдельный массив. Выше рассмотрели одномерный массив, теперь создадим многомерный массив:

[source, javascript]
----
var numbers1 = [0, 1, 2, 3, 4, 5 ]; // одномерный массив
var numbers2 = [[0, 1, 2], [3, 4, 5]]; // двумерный массив
----

Визуально оба массива можно представить следующим образом:

.Одномерный массив numbers1
|===
|0|1|2|3|4|5
|===

.Двухмерный массив numbers2
|===
|0|1|2
|3|4|5
|===

Поскольку массив `numbers2` двухмерный, он представляет собой простую таблицу. Каждый его элемент может представлять отдельный массив.

Рассмотрим еще один двумерный массив:

[source, javascript]
----
var people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];

console.log(people[0]);
console.log(people[1]);
----

----
["Tom", 25, false]
["Bill", 38, true]
----

Массив `people` можно представить в виде следующей таблицы:

|===
|Tom|25|false
|Bill|38|true
|Alice|21|false
|===

Чтобы получить отдельный элемент массива, также используется индекс:

[source, javascript]
----
var tomInfo = people[0];
----

Только теперь переменная `tomInfo` будет представлять массив. Чтобы получить элемент внутри вложенного массива, необходимо использовать его вторую размерность:

[source, javascript]
----
var people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];

console.log("Имя: " + people[0][0]);
console.log("Возраст: " + people[0][1]);
----

----
Tom
25
----

То есть если визуально двумерный массив можно представить в виде таблицы, то элемент `people[0][1]` будет ссылаться на ячейку таблицы, которая находится на пересечении первой строки и второго столбца (первая размерность - `0` - *строка*, вторая размерность - `1` - *столбец*).

Также можно выполнить присвоение:

[source, javascript]
----
var people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];
people[0][1] = 56; // присваиваем отдельное значение
console.log(people[0][1]);

people[1] = ["Bob", 29, false]; // присваиваем массив
console.log(people[1][0]);
----

----
56
Bob
----

При создании многомерных массивов не ограничены только двумерными, но также можем использовать массивы больших размерностей:

[source, javascript]
----
var numbers = [];
numbers[0] = []; // теперь numbers - двумерный массив
numbers[0][0]=[]; // теперь numbers - трехмерный массив
numbers[0][0][0] = 5; // первый элемент трехмерного массива равен 5
console.log(numbers[0][0][0]);
----

== Условные конструкции

*Условные конструкции* позволяют выполнить те или иные действия в зависимости от определенных условий.

=== Выражение `if`

Конструкция `if` проверяет некоторое условие и если это условие верно, то выполняет некоторые действия. Общая форма конструкции `if`:

[source, javascript]
----
if (условие) действия;
----

*Например:*

[source, javascript]
----
var income = 100;
if (income > 50) alert("доход больше 50");
----

Здесь в конструкции `if` используется следующее условие: `income > 50`. Если это условие возвращает `true`, то есть переменная `income` имеет значение больше `50`, то браузер отображает сообщение. Если же значение `income` меньше `50`, то никакого сообщения не отображается.

Если необходимо выполнить по условию набор инструкций, то они помещаются в блок из фигурных скобок:

[source, javascript]
----
var income = 100;
if (income > 50) {
    var message = "доход больше 50";
    alert(message);
}
----

Причем условия могут быть сложными:

[source, javascript]
----
var income = 100;
var age = 19;
if (income < 150 && age > 18) {
    var message = "доход больше 50";
    alert(message);
}
----

Конструкция `if` позволяет *проверить наличие значения*.

[source, javascript]
----
var myVar = 89;
if (myVar) {
    // действия
}
----

Если переменная `myVar` имеет значение, то в условной конструкции она возвратит значение `true`.

Но нередко для проверки значения переменной используют альтернативный вариант - *проверяют на значение `undefined`*:

[source, javascript]
----
if (typeof myVar != "undefined") {
    // действия
}
----

В конструкции `if` также можно использовать блок `else`. Данный блок содержит инструкции, которые выполняются, если условие после `if` ложно, то есть равно `false`:

[source, javascript]
----
var age = 17;
if (age >= 18) {
    alert("Вы допущены к программе кредитования");
} else {
    alert("Вы не можете участвовать в программе, так как возраст меньше 18");
}
----

С помощью конструкции `else if`  можно добавить альтернативное условие к блоку `if`:

[source, javascript]
----
var income = 300;
if (income < 200) {
    alert("Доход ниже среднего");
} else if (income >= 200 && income <= 400) {
    alert("Средний доход");
} else {
    alert("Доход выше среднего");
}
----

В данном случае выполнится блок `else if`. При необходимости можно использовать несколько блоков `else if` с разными условиями:

[source, javascript]
----
if (income < 200) {
    alert("Доход ниже среднего");
} else if (income >= 200 && income < 300) {
    alert("Чуть ниже среднего");
} else if (income >= 300 && income < 400) {
    alert("Средний доход");
} else {
    alert("Доход выше среднего");
}
----

=== `true` или `false`

В *JavaScript* любая переменная может применяться в условных выражениях, но не любая переменная представляет тип `boolean`. Поэтому возникает вопрос, что возвратит та или иная переменная - `true` или `false`? Много зависит от типа данных, который представляет переменная:

* `undefined`

Возвращает `false`

* `null`

Возвращает `false`

* `Boolean`

Если переменная равна `false`, то возвращается `false`. Соответственно, если переменная равна `true`, то возвращается `true`

* `Number`

Возвращает `false`, если число равно `0` или `NaN` (*Not a Number*), в остальных случаях возвращается `true`


[source, javascript]
----
var x = NaN;
if (x) {  // false
}
----

* `String`

Возвращает `false`, если переменная равна пустой строке, то есть ее длина равна 0, в остальных случаях возвращается `true`

[source, javascript]
----
var y = ""; // false - так как пустая строка
var z = "javascript"; // true - строка не пустая
----

*  `Object`

Всегда возвращает `true`

[source, javascript]
----
var user = {name:"Tom"}; // true
var isEnabled = new Boolean(false); // true
var car = {}; // true
----

=== Конструкция `switch..case`

Конструкция `switch..case` является альтернативой использованию конструкции `if..else if..else` и также позволяет обработать сразу несколько условий:

[source, javascript]
----
var income = 300;
switch(income) {
    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 300 :
        console.log("Доход равен 300");
        break;
}
----

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.

В конце каждого блока `сase` ставится оператор `break`, чтобы избежать выполнения других блоков.

Если есть необходимость обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`:

[source, javascript]
----
var income = 300;
switch(income) {
    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 300 :
        console.log("Доход равен 300");
        break;
    default:
        console.log("Доход неизвестной величины");
        break;
}
----

=== Тернарная операция

*Тернарная операция* состоит из трех операндов и имеет следующее определение:

`[первый операнд - условие] *?* [второй операнд] *:* [третий операнд]`

В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно `true`, то возвращается второй операнд; если условие равно `false`, то третий. Например:

[source, javascript]
----
var a = 1;
var b = 2;
var result = a < b ? a + b : a - b;
console.log(result);
----

----
3
----

Если значение переменной `a` меньше значения переменной `b`, то переменная `result` будет равняться `a + b`. Иначе значение `result` будет равняться `a - b`.

== Циклы

Циклы позволяют в зависимости от определенных условий выполнять некоторое действие множество раз. В *JavaScript* имеются следующие виды циклов:

* `for`
* `for..in`
* `for..of`
* `while`
* `do..while`

=== Цикл `for`

Цикл `for` имеет следующее формальное определение:

[source, javascript]
----
for ([инициализация счетчика]; [условие]; [изменение счетчика]) {
    // действия
}
----

Например, используем цикл `for` для перебора элементов массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for (var i = 0; i<people.length; i++) {
    console.log(people[i]);
}
----

Первая часть объявления цикла - `var i = 0` - создает и инициализирует счетчик - переменную `i`. И перед выполнением цикла ее значение будет равно `0`. По сути это то же самое, что и объявление переменной.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока значение `i` не достигнет величины, равной длине массива `people`. Получить длину массива можно с помощью свойства `length: people.length`.

Третья часть - приращение счетчика на единицу.

И так как в массиве 4 элемента, то блок цикла сработает 4 раза, пока значение `i` не станет равным `people.length` (то есть `4`). И каждый раз это значение будет увеличиваться на 1. Каждое отдельное повторение цикла называется итерацией. Таким образом, в данном случае сработают 4 итерации.

А с помощью выражения `people[i]` можно получить элемент массива для его последующего вывода в браузере.

Необязательно увеличивать счетчик на единицу, можно производить с ним другие действия, например, уменьшать на единицу:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for (var i = people.length - 1; i >= 0; i--) {
    console.log(people[i]);
}
----

В данном случае массив выводится с конца, а перебор массива начинается с `i = 3` до `i = 0`.

=== Цикл `for..in`

Цикл `for..in` предназначен для перебора массивов и объектов. Его формальное определение:

[source, javascript]
----
for (индекс in массив) {
    // действия
}
----

Например, переберем элементы массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
for (var index in people) {
    console.log(people[index]);
}
----

=== Цикл `for...of`

Цикл `for...of` похож на цикл `for...in` и предназначен для перебора коллекций, например, массивов:

[source, javascript]
----
let users = ["Tom", "Bob", "Sam"];
for (let val of users)
    console.log(val);
----

Текущий перебираемый элемент коллекции помещается в переменную `val`, значение которой затем выводится на консоль.

=== Цикл `while`

Цикл `while` выполняется до тех пор, пока некоторое условие истинно. Его формальное определение:

[source, javascript]
----
while (условие) {
    // действия
}
----

Опять же выведем с помощью `while` элементы массива:

[source, javascript]
----
var people = ["Tom", "Alice", "Bob", "Sam"];
var index = 0;
while (index < people.length) {
    console.log(people[index]);
    index++;
}
----

Цикл `while` здесь будет выполняться, пока значение `index` не станет равным длине массива.

=== Цикл `do..while`

В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие истинно, цикл повторяется. *Например:*

[source, javascript]
----
var x = 1;
do {
    console.log(x * x);
    x++;
} while (x < 10)
----

Здесь код цикла сработает 9 раз, пока x не станет равным `10`. При этом цикл `do` гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции `while` не будет истинно.

=== Операторы `continue` и `break`

Иногда бывает необходимо выйти из цикла до его завершения. В этом случае можно воспользоваться оператором `break`:

[source, javascript]
----
var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
for (var i = 0; i < array.length; i++) {
    if (array[i] > 10)
        break;
    document.write(array[i] + "</br>");
}
----

Данный цикл перебирает все элементы массива, однако последние четыре элемента не будут выведены в браузере, поскольку поверка `if (array[i] > 10)` прервет выполнение цикла с помощью оператора `break`, когда перебор массива дойдет до элемента `12`.

Если необходимо просто пропустить итерацию, но не выходить из цикла, можно применять оператор `continue`.

[source, javascript]
----
var array = [ 1, 2, 3, 4, 5, 12, 17, 6, 7 ];
for (var i = 0; i < array.length; i++) {
    if (array[i] > 10)
        continue;
    document.write(array[i] + "</br>");
}
----

В этом случае, если программа встретит в массиве число, больше `10`, то это число не будет выводиться в браузере.
