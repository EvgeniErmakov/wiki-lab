== Реализация ООП в Java Script

=== Объекты
Для работы с сущностями в *JavaScript* используются *объекты*. Каждый *объект* может хранить свойства, которые описывают его *состояние*, и методы, которые описывают его *поведение*.

==== Создание нового объекта

Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора *Object*:

[source,js]
----
var user = new Object();
----

В данном случае *объект* называется `user`. Он определяется также, как и любая обычная переменная с помощью ключевого слова `var`.

Выражение `new Object()` представляет *вызов конструктора* - функции, создающей новый объект. Для вызова конструктора применяется *оператор* `new`. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование *фигурных скобок*:

[source,js]
----
var user = {};
----

Более распространенным является второй способ создания объекта.

==== Свойства объекта
После создания объекта можно определить в нем *свойства*. Чтобы *определить свойство*, надо после названия объекта через точку указать *имя свойства* и присвоить ему *значение*:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
----

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого появляется возможность *использовать* эти свойства:

[source,js]
----
console.log(user.name);
console.log(user.age);
----

Также можно определить свойства *при определении объекта*:

[source,js]
----
var user = {

    name: "Tom",
    age: 26
};
----

В этом случае для присвоения значения свойству используется символ *двоеточия*, а после определения свойства ставится *запятая* (а не точка с запятой).

Кроме того, доступен *сокращенный* способ определения свойств:

[source,js]
----
var name = "Tom";
var age = 34;
var user = {name, age};
console.log(user.name);
console.log(user.age);
----

=== Методы объекта

*Методы объекта* определяют его *поведение* или *действия*, которые он производит. *Методы* представляют собой *функции*. Например, определим метод, который бы выводил имя и возраст человека:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
----

Как и в случае с функциями *методы сначала определяются, а потом уже вызываются*.

Также методы могут определяться непосредственно *при определении объекта*:

[source,js]
----
var user = {

    name: "Tom",
    age: 26,
    display: function(){

        console.log(this.name);
        console.log(this.age);
    }
};
----

Как и в случае со свойствами, методу присваивается *ссылка на функцию* с помощью знака *двоеточия*.

Чтобы *обратиться* к *свойствам* или *методам* объекта *внутри* этого объекта, используется ключевое слово `this`. Оно означает *ссылку на текущий объект*.

Также можно использовать *сокращенный способ определения методов*, когда *двоеточие* и слово *function* *опускаются*:

[source,js]
----
var user = {

    name: "Tom",
    age: 26,
    display(){

        console.log(this.name, this.age);
    },
    move(place){
        console.log(this.name, "goes to", place);
    }
};
user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
----

==== Синтаксис массивов

Cуществует также * альтернативный* способ определения свойств и методов с помощью *синтаксиса массивов*:

[source,js]
----
var user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
----

Название каждого свойства или метода *заключается в кавычки и в квадратные скобки*, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо *нотацию точки (`user.name`)*, либо обращаться так: `user["name"]`.

==== Строки в качестве свойств и методов

Названия свойств и методов объекта всегда представляют *строки*. То есть предыдущее определение объекта можно переписать так:

[source,js]
----
var user = {
    "name": "Tom",
    "age": 26,
    "display": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
----

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных *пробелом*:

[source,js]
----
var user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
----

В этом случае *для обращения* к подобным свойствам и методам мы должны использовать *синтаксис массивов*.

==== Удаление свойств

Удалять свойства и методы необходимо с помощью оператора `delete`. Как и в случае с добавлением удалять свойства можно двумя способами. *Певый* способ - *использование нотации точки*:

[source,js]
----
delete объект.свойство
----

Либо использовать *синтаксис массивов*:

[source,js]
----
delete объект["свойство"]
----

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
----

После удаления свойство будет *не определено*, поэтому *при попытке обращения к нему*, *программа вернет* значение `undefined`.

=== Вложенные объекты и массивы в объектах
Одни объекты могут содержать в *качестве свойств другие объекты*. Например, есть объект страны, у которой можно выделить ряд свойств. Одно из этих свойств может представлять столицу. Но у столицы мы также можем выделить свои свойства, например, название, численность населения, год основания:

[source,js]
----
var country = {

    name: "Германия",
    language: "немецкий",
    capital:{

        name: "Берлин",
        population: 3375000,
        year: 1237
    }
};
console.log("Столица: " + country.capital.name); // Берлин
console.log("Население: " + country["capital"]["population"]); // 3375000
console.log("Год основания: " + country.capital["year"]); // 1237
----

Для *доступа к свойствам* таких вложенных объектов мы можем использовать *стандартную нотацию точки*:

[source,js]
----
country.capital.name
----

Либо обращаться к ним как к *элементам массивов*:

[source,js]
----
country["capital"]["population"]
----

Также допустим *смешанный* вид обращения:

[source,js]
----
country.capital["year"]
----

В качестве свойств также могут использоваться *массивы*, в том числе *массивы других объектов*:

[source,js]
----
capital:{

        name: "Берн",
        population: 126598
    },
    cities: [
        { name: "Цюрих", population: 378884},
        { name: "Женева", population: 188634},
        { name: "Базель", population: 164937}
    ]
};

// вывод всех элементов из country.languages
document.write("<h3>Официальные языки Швейцарии</h3>");
for(var i=0; i < country.languages.length; i++)
    document.write(country.languages[i] + "<br/>");

// вывод всех элементов из country.cities
document.write("<h3>Города Швейцарии</h3>");
for(var i=0; i < country.cities.length; i++)
    document.write(country.cities[i].name + "<br/>");
----

В объекте `country` имеется свойство `languages,` содержащее *массив строк*, а также свойство `cities`, хранящее *массив однотипных объектов*.

С этими массивами можно работать также, как и с любыми другими, например, перебрать с помощью цикла `for`.

*При переборе* массива объектов каждый текущий элемент будет представлять *отдельный объект*, поэтому мы можем обратиться к его *свойствам* и *методам*:

[source,js]
----
country.cities[i].name
----

=== Проверка наличия и перебор методов и свойств

При *динамическом определении* *в объекте* новых *свойств* и *методов* перед их использованием бывает важно проверить, а есть ли уже такие методы и свойства. Для этого в *javascript* может использоваться оператор `in`:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};
var hasNameProp = "name" in user;
console.log(hasNameProp); // true - свойство name есть в user
var hasWeightProp = "weight" in user;
console.log(hasWeightProp); // false - в user нет свойства или метода под названием weight
----

Оператор `in` имеет следующий синтаксис: `"свойство|метод" in объект` - в кавычках идет *название свойства или метода*, а после `in` - *название объекта*. Если свойство или метод с подобным именем *имеется*, то оператор возвращает `true`. Если *нет* - то возвращается `false`.

*Альтернативный* способ заключается на значение `undefined`. Если свойство или метод равен `undefined`, то эти свойство или метод *не определены*:

[source,js]
----
var hasNameProp = user.name!==undefined;
console.log(hasNameProp); // true
var hasWeightProp = user.weight!==undefined;
console.log(hasWeightProp); // false
----

И так как объекты представляют тип `Object`, а значит, имеет *все его методы и свойства*, то *объекты* также могут использовать метод `hasOwnProperty()`, который определен в типе `Object`:

[source,js]
----
var hasNameProp = user.hasOwnProperty('name');
console.log(hasNameProp); // true
var hasDisplayProp = user.hasOwnProperty('display');
console.log(hasDisplayProp); // true
var hasWeightProp = user.hasOwnProperty('weight');
console.log(hasWeightProp); // false
----

==== Перебор свойств и методов

С помощью цикла *for* мы можем перебрать *объект как обычный массив* и получить все его свойства и методы и их значения:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function() {

    console.log(user.name);
    console.log(user.age);
};
for(var key in user) {
    console.log(key + " : " + user[key]);
}
----

=== Объекты в функциях

*Функции* могут возвращать *значения*. Но эти значения не обязательно должны представлять примитивные данные - *числа*, *строки*, но также могут быть сложными *объектами*.

Например, вынесем создание объекта user в отдельную функцию:

[source,js]
----
function createUser(pName, pAge) {
    return {
        name: pName,
        age: pAge,
        displayInfo: function() {
            document.write("Имя: " + this.name + " возраст: " + this.age + "<br/>");
        }
    };
};
var tom = createUser("Tom", 26);
tom.displayInfo();
var alice = createUser("Alice", 24);
alice.displayInfo();
----

Здесь функция `createUser()` получает значения `pName` и `pAge` и по ним *создает новый объект*, который является возвращаемым результатом.

*Преимуществом* вынесения создания объекта в функцию является то, что далее мы можем создать несколько *однотипных объектов* с *разными значениями*.

Кроме того *объект* может передаваться *в качестве параметра в функцию*:

[source,js]
----
function createUser(pName, pAge) {
return {
name: pName,
age: pAge,
displayInfo: function() {
document.write("Имя: " + this.name + " возраст: " + this.age + "<br/>");
},
driveCar: function(car){
document.write(this.name + " ведет машину " + car.name + "<br/>");
}
};
};

function createCar(mName, mYear) {
return {
name: mName,
year: mYear
};
};
var tom = createUser("Том", 26);
tom.displayInfo();
var bently = createCar("Бентли", 2004);
tom.driveCar(bently);
----

=== Конструкторы объектов

Кроме создания новых объектов *JavaScript* предоставляет возможность *создавать новые типы объектов* с помощью конструкторов. Так, одним из способов *создания объекта* является применение конструктора типа `Object`:

[source,js]
----
var tom = new Object();
----

После создания переменной `tom` она будет вести себя как объект типа `Object`.

*Конструктор* позволяет определить *новый тип объекта*. *Можно еще провести следующую аналогию.

Определение типа может состоять из *функции конструктора*, *методов* и *свойств*.

[source,js]
----
function User(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.displayInfo = function(){
        document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
    };
}
----

*Конструктор* - это обычная функция за тем исключением, что в ней мы можем установить *свойства* и *методы*. Для установки свойств и методов используется ключевое слово `this`:

Чтобы вызвать *конструктор*, то есть создать объект типа `User`, надо использовать ключевое слово `new`:

[source,js]
----
var tom = new User("Том", 26);
console.log(tom.name); // Том
tom.displayInfo();
----

==== Оператор instanceof

Оператор `instanceof` позволяет проверить, с помощью какого конструктора создан объект. Если объект создан с помощью определенного конструктора, то оператор возвращает `true`:

[source,js]
----
var tom = new User("Том", 26);
var isUser = tom instanceof User;
var isCar = tom instanceof Car;
console.log(isUser);    // true
console.log(isCar);     // false
----

=== Расширение объектов. `Prototype`

Кроме непосредственного определения свойств и методов в конструкторе мы также можем использовать *свойство* `prototype`. Каждая функция имеет свойство `prototype`, представляющее *прототип функции*. То есть свойство `User.prototype` представляет *прототип объектов* `User`. И любые *свойства и методы*, которые будут определены в `User.prototype`, будут *общими* для всех объектов `User`.

Например, после определения объекта `User` необходимо добавить к нему метод и свойство:

[source,js]
----
function User(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.displayInfo = function(){
        document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
    };
};

User.prototype.hello = function(){
    document.write(this.name + " говорит: 'Привет!'<br/>");
};
User.prototype.maxAge = 110;

var tom = new User("Том", 26);
tom.hello();
var john = new User("Джон", 28);
john.hello();
console.log(tom.maxAge); // 110
console.log(john.maxAge); // 110
----

В то же время можно определить в объекте *свойство*, которое будет назваться также, как и *свойство прототипа*. В этом случае собственное *свойство объекта* будет иметь приоритет перед *свойством прототипа*.

=== Инкапсуляция

*Инкапсуляция* является одним из ключевых понятий объектно-ориентированного программирования и представляет *сокрытие состояния объекта от прямого доступа извне*. По умолчанию все свойства объектов являются *публичными*, общедоступными, и мы к ним можем обратиться из любого места программы.

Но есть возможность их скрыть от доступа извне, сделав свойства *локальными переменными*:

[source,js]
----
function User (name) {
    this.name = name;
    var _age = 1;
    this.displayInfo = function(){
        console.log("Имя: " + this.name + "; возраст: " + _age);
    };
    this.getAge = function() {
        return _age;
    }
    this.setAge = function(age) {
        if(typeof age === "number" && age >0 && age<110){
            _age = age;
        } else {
            console.log("Недопустимое значение");
        }
    }
}

var tom = new User("Том");
console.log(tom._age); // undefined - _age - локальная переменная
console.log(tom.getAge()); // 1
tom.setAge(32);
console.log(tom.getAge()); // 32
tom.setAge("54"); // Недопустимое значение
tom.setAge(123); // Недопустимое значение
----

В конструкторе `User` объявляется **локальная переменна**я `_age` вместо *свойства* `age`. Как правило, названия локальных переменных в конструкторах начинаются со знака *подчеркивания*.

Для того, чтобы работать с возрастом пользователя извне, определяются два метода. Метод `getAge()` предназначен *для получения значения переменной* `_age`. Этот метод еще называется *геттер (getter)*. Второй метод - `setAge`, который еще называется *сеттер (setter)*, предназначен для установки значения переменной `_age`.

=== Функция как объект. Методы `call` и `apply`

В *JavaScript* функция тоже является *объектом* - *объектом Function* и тоже имеет *прототип*, *свойства*, *методы*. *Все функции*, которые используются в программе, являются *объектами Function* и имеют все его *свойства и методы*.

Например, мы можем создать функцию с помощью конструктора `Function`:

[source,js]
----
var square = new Function('n', 'return n * n;');
console.log(square(5));
----

В конструктор `Function` может передаваться ряд параметров. Последний параметр представляет собой само *тело функции в виде строки*. Фактически строка содержит *код javascript*. Предыдущие аргументы содержат *названия параметров*.

Среди свойств объекта Function можно выделить следующие:

* *arguments*: массив аргументов, передаваемых в функцию
* *length*: определяет количество аргументов, которые ожидает функция
* *caller*: определяет функцию, вызвавшую текущую выполняющуюся функцию
* *name*: имя функции
* *prototype*: прототип функции

С помощью *прототипа* можно определить дополнительные свойства:

[source,js]
----
function display(){

    console.log("привет мир");
}
Function.prototype.program ="Hello";

console.log(display.program); // Hello
----

Среди методов надо отметить методы `call()` и `apply()`.

Метод `call()` вызывает функцию с указанным значением `this` и аргументами:

[source,js]
----
function add(x, y){

    return x + y;
}
var result = add.call(this, 3, 8);

console.log(result); // 11
----

`this` указывает на *объект*, для которого вызывается функция - в данном случае это *глобальный объект* `window`. После `this` передаются *значения для параметров*.

При передаче объекта через первый параметр, мы можем ссылаться на него через ключевое слово `this`:

[source,js]
----
function User (name, age) {
    this.name = name;
    this.age = age;
}
var tom = new User("Том", 26);
function display(){
    console.log("Ваше имя: " + this.name);
}
display.call(tom); // Ваше имя: Том
----

Если нам не важен объект, для которого вызывается функция, то можно передать значение null.

На метод `call()` похож метод `apply()`, который также *вызывает функцию* и в качестве первого параметра также получает *объект*, для которого функция вызывается. Только теперь в качестве второго параметра передается *массив аргументов*:

[source,js]
----
function add(x, y){

    return x + y;
}
var result = add.apply(null, [3, 8]);

console.log(result); // 11
----

=== Наследование

*JavaScript* поддерживает *наследование*, что позволяет при создании новых типов объектов при необходимости *унаследовать функционал от уже существующих*. Например, у нас может быть объект `User`, представляющий отдельного пользователя. И также может быть объект `Employee`, который представляет работника. Но работник также может являться пользователем и поэтому должен иметь все его свойства и методы.

[source,js]
----
// конструктор пользователя
function User (name, age) {
this.name = name;
this.age = age;
this.go = function(){document.write(this.name + " идет <br/>");}
this.displayInfo = function(){
document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
};
}
User.prototype.maxage = 110;

// конструктор работника
function Employee(name, age, comp){
User.call(this, name, age);
this.company = comp;
this.displayInfo = function(){
document.write("Имя: " + this.name + "; возраст: " + this.age + "; компания: " + this.company + "<br/>");
};
}
Employee.prototype = Object.create(User.prototype);

var tom = new User("Том", 26);
var bill = new Employee("Билл", 32, "Google");
tom.go();
bill.go();
tom.displayInfo();
bill.displayInfo();
console.log(bill.maxage);
----

В конструкторе `Employee` происходит обращение к конструктору `User` с помощью вызова:

[source,js]
----
User.call(this, name, age);
----

Передача первого параметра `this` позволяет вызвать функцию *конструктора* `User` для *объекта*, создаваемого *конструктором* `Employee`. Благодаря этому *все свойства и методы*, определенные в *конструкторе* `User`, также переходят на *объект* `Employee`.

Кроме того, необходимо унаследовать также и *прототип* `User`. Для этого служит вызов:

[source,js]
----
Employee.prototype = Object.create(User.prototype);
----

Метод `Object.create()` позволяет создать *объект прототипа* `User`, который затем присваивается *прототипу* `Employee`. При этом при необходимости в прототипе `Employee` мы также можем определить дополнительные свойства и методы.

При наследовании мы можем *переопределять наследуемый функционал*.

=== Ключевое слово `this`
*Поведение* ключевого слова `this` зависит *от контекста*, в котором оно используется, и от того, *в каком режиме оно используется* - *строгом* или *нестрогом*.

==== Глобальный контекст
В глобальном контексте `this` ссылается на *глобальный объект*. В данном случае *поведение не зависит от режима* (строгий или нестрогий):

[source,js]
----
this.alert("global alert");
this.console.log("global console");

var currentDocument = this.document;
----

==== Контекст функции
*В пределах функции* `this` ссылается на *внешний контекст*. Для функций, определенных *в глобальном контексте*, - это объект `Window`, который представляет окно браузера.

[source,js]
----
function foo(){
    var bar = "bar2";
    console.log(this.bar);
}

var bar = "bar1";

foo();  // bar1
----

Если не использовать `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

[source,js]
----
function foo(){
    var bar = "bar2";
    console.log(bar);
}

var bar = "bar1";

foo();  // bar2
----

Но если использовать *строгий режим* (`strict mode`), то `this` в этом случае имело бы значение `undefined`:

[source,js]
----
"use strict";
var obj = {
function foo(){
var bar = "bar2";
console.log(this.bar);
}
}

var bar = "bar1";

foo();  // ошибка - this - undefined
----

==== Контекст объекта

*В контексте объекта*, в том числе *в его методах*, ключевое слово `this` ссылается на `этот же объект`:

[source,js]
----
var o = {
bar: "bar3",
foo: function(){
console.log(this.bar);
}
}
var bar = "bar1";
o.foo();    // bar3
----

==== Явная привязка

С помощью методов *call()* и *apply()* можно задать явную привязку функции к *определенному контексту*:

[source,js]
----
function foo(){
    console.log(this.bar);
}

var o3 = {bar: "bar3"}
var bar = "bar1";
foo();  // bar1
foo.apply(o3);  // bar3
// или
// foo.call(o3);
----

==== Метод `bind`

Метод `f.bind(o)` позволяет создать *новую функцию* с тем же телом и областью видимости, что и функция f, но *с привязкой к объекту o*:

[source,js]
----
function foo(){
console.log(this.bar);
}

var o3 = {bar: "bar3"}
var bar = "bar1";
foo();  // bar1
var func = foo.bind(o3);
func(); // bar3
----

==== `this` и стрелочные функции

При работе с несколькими контекстами необходимо учитывать, в каком контексте определяется переменная.

[source,js]
----
var school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses: function(){
        this.courses.forEach(function(course){
            console.log(this.title, course);
        })
    }
}
school.printCourses();
----

[source,shell script]
----
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
----
Видно, что значение `this.title` не определено, так как `this` как контекст объекта *замещается глобальным контекстом*. В этом случае нам надо передать подобное значение `this.title` или *весь контекст объекта*.

[source,js]
----
var school ={
title: "Oxford",
courses: ["JavaScript", "TypeScript", "Java", "Go"],
printCourses: function(){
var that = this;
this.courses.forEach(function(course){
console.log(that.title, course);
})
}
}
school.printCourses();
----

*Стрелочные функции* также позволяют решить данную проблему:

[source,js]
----
var school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses: function(){
        this.courses.forEach((course)=>console.log(this.title, course))
    }
}
school.printCourses();
----

*Контекстом для стрелочной функции* в данном случае будет выступать *контекст объекта school*. Соответственно,не надо определять дополнительные переменные для передачи данных в функцию.

=== Декомпозиция

*Декомпозиция* (`destructuring`) позволяет извлечь из объекта *отдельные значения в переменные*:

[source,js]
----
let user = {
name: "Tom",
age: 24,
phone: "+367438787",
email: "tom@gmail.com"
};
let {name, email} = user;
console.log(name);      // Tom
console.log(email);     // tom@gmail.com
----

Для *декомпозиции объекта* *переменные* помещаются *в фигурные скобки* и им присваивается *объект*. *Сопоставление* между свойствами объекта и переменными идет *по имени*.

Так же можно указать, что необходимо получить значения свойств объекта в переменные с другим именем:

[source,js]
----
let user = {
name: "Tom",
age: 24,
phone: "+367438787",
email: "tom@gmail.com"
};
let {name: userName, email: mailAddress} = user;
console.log(userName);      // Tom
console.log(mailAddress);       // tom@gmail.com
----

==== Декомпозиция массивов

Также можно декомпозировать *массивы*:

[source,js]
----
let users = ["Tom", "Sam", "Bob"];
let [a, b, c] = users;

console.log(a);     // Tom
console.log(b);     // Sam
console.log(c);     // Bob
----

Для *декомпозиции массива* переменные помещаются *в квадратные скобки* и *последовательно* получают значения элементов массива.

При этом можно пропустить ряд элементов массива, оставив вместо имен переменных пропуски:

[source,js]
----
let users = ["Tom", "Sam", "Bob", "Ann", "Alice", "Kate"];
let [first,,,,fifth] = users;

console.log(first);     // Tom
console.log(fifth);     // Alice
----

==== Декомпозиция параметров

Если в *функцию* в качестве параметра передается *массив* или *объект*, то его также можно подобным образом декомпозировать:

[source,js]
----
function display({name:userName, age:userAge}){
    console.log(userName, userAge);
}
function sum([a, b, c]){
    var result = a + b + c;
    console.log(result);
}
let user = {name:"Alice", age:33, email: "alice@gmail.com"};


let numbers = [3, 5, 7, 8];

display(user);  // Alice 33
sum(numbers);   // 15
----

=== Классы

С внедрением стандарта *ES2015 (ES6)* в *JavaScript* появился новый способ определения объектов - с помощью классов. Класс представляет описание объекта, его состояния и поведения, а объект является конкретным воплощением или экземпляром класса.

Для *определения класса* используется ключевое слово `class`:

[source,js]
----
class Person{
}
----

Также можно определить анонимный класс и присвоить его переменной:

[source,js]
----
let Person = class{}
----

После этого можно создать объекты класса с помощью конструктора:

[source,js]
----
class Person{}

let tom = new Person();
let bob = new Person();
----

*Для создания объекта* с помощью конструктора сначала ставится *ключевое слово* `new`. Затем собственно идет *вызов конструктора* - по сути вызов функции по имени класса. По умолчанию классы имеют *один конструктор без параметров*. Поэтому в данном случае при вызове конструктора в него не передается никаких аргументов.

Также можно определить в классе свои конструкторы. Также класс может содержать свойства и методы:

[source,js]
----
class Person{
constructor(name, age){
this.name = name;
this.age = age;
}
display(){
console.log(this.name, this.age);
}
}

let tom = new Person("Tom", 34);
tom.display();          // Tom 34
console.log(tom.name);  // Tom
----

*Конструктор* определяется с помощью метода с именем `constructor`. По сути это обычный метод, который может принимать параметры. Основная цель конструктора - *инициализировать объект начальными данными*. И в данном случае в конструктор передаются два значения - для имени и возраста пользователя.

Для хранения состояния в классе *определяются свойства*. Для их определения используется ключевое слово `this`. В данном случае в классе два свойства: `name` и `age`.

Поведение *класса* определяют *методы*. В данном случае определен метод `display()`, который выводит значения свойств на консоль.

==== Наследование

Одни классы могут наследоваться от других. Наследование позволяет сократить объем кода в классах-наследниках:

[source,js]
----
class Person{
constructor(name, age){
this.name = name;
this.age = age;
}
display(){
console.log(this.name, this.age);
}
}
class Employee extends Person{
constructor(name, age, company){
super(name, age);
this.company = company;
}
display(){
super.display();
console.log("Employee in", this.company);
}
work(){
console.log(this.name, "is hard working");
}
}

let tom = new Person("Tom", 34);
let bob = new Employee("Bob", 36, "Google");
tom.display();
bob.display();
bob.work();
----

Для *наследования* одного класса от другого в определении класса применяется *оператор* `extends`, после которого идет название базового класса. То есть в данном случае класс `Employee` наследуется от класса `Person`. Класс `Person` еще называется *базовым классом*, *классом-родителем*, *суперклассом*, а класс `Employee` - *классом-наследником*, *подклассом*, *производным классом*.

*Производный класс*, как и *базовый*, может определять *конструкторы*, *свойства*, *методы*. Вместе с тем с помощью слова `super` *производный класс* может ссылаться на функционал, определенный *в базовом*.

==== Статические методы

*Статические методы* вызываются для *всего класса* в целом, а не для отедельного объекта. Для их определения применяется оператор `static`.

[source,js]
----
class Person{
constructor(name, age){
this.name = name;
this.age = age;
}
static nameToUpper(person){
return person.name.toUpperCase();
}
display(){
console.log(this.name, this.age);
}
}
let tom = new Person("Tom Soyer", 34);
let personName = Person.nameToUpper(tom);
console.log(personName);        // TOM SOYER
----

== Встроенные объекты

Кроме возможности *создавать* свои объекты *JavaScript* также предоставляет набор *встроенных типов объектов*, которые можно применять в различных ситуациях.

=== Объект Date. Работа с датами

Объект `Date` позволяет работать с *датами и временем в JavaScript*.

Существуют различные способы создания объекта `Date`. Первый способ заключается в использовании *пустого конструктора без параметров*:

[source,js]
----
var currentDate = new Date();
document.write(currentDate);
----

В этом случае объект будет указывать *на текущую дату компьютера*.

Второй способ заключается в передаче в (конструктор) `Date` *количества миллисекунд*, *которые прошли с начала эпохи Unix*, то есть *с 1 января 1970 года 00:00:00 GMT*:

[source,js]
----
var myDate = new Date(1359270000000);
document.write(myDate); // Sun Jan 27 2013 10:00:00 GMT+0300 (RTZ 2 (зима))
----

Третий способ состоит в передаче в *конструктор* `Date` *дня, месяца* и *года*:

[source,js]
----
var myDate = new Date("27 March 2008");
// или так
// var myDate = new Date("3/27/2008");
document.write(myDate); // Thu Mar 27 2008 00:00:00 GMT+0300 (RTZ 2 (зима))
----

Если используется *полное название месяца*, то оно пишется в *по-английски*, если используем *сокращенный вариант*, тогда используется формат *месяц/день/год*.

Четвертый способ состоит в передаче в *конструктор* `Date` *всех параметров даты и времени*:

[source,js]
----
var myDate = new Date(2012,11,25,18,30,20,10); // Tue Dec 25 2012 18:30:20 GMT+0300 (RTZ 2 (зима))
----

При этом надо учитывать, что отсчет месяцев начинается *с нуля*, то есть *январь - 0*, а *декабрь - 11*.

==== Получение даты и времени

Для получения различных компонентов даты применяется ряд методов:

* `getDate()`: возвращает день месяца

* `getDay()`: возвращает день недели (отсчет начинается с 0 - воскресенье, и последний день - 6 - суббота)

* `getMonth()`: возвращает номер месяца (отсчет начинается с нуля, то есть месяц с номер 0 - январь)

* `getFullYear()`: возвращает год

* `toDateString()`: возвращает полную дату в виде строки

* `getHours()`: возвращает час (от 0 до 23)

* `getMinutes()`: возвращает минуты (от 0 до 59)

* `getSeconds()`: возвращает секунды (от 0 до 59)

* `getMilliseconds()`: возвращает миллисекунды (от 0 до 999)

* `toTimeString()`: возвращает полное время в виде строки

==== Установка даты и времени

Коме задания параметров даты в конструкторе для установки мы также можем использовать дополнительные *методы объекта Date*:

* `setDate()`: установка дня в дате

* `setMonth()`: уставовка месяца (отсчет начинается с нуля, то есть месяц с номер 0 - январь)

* `setFullYear()`: устанавливает год

* `setHours()`: установка часа

* `setMinutes()`: установка минут

* `setSeconds()`: установка секунд

* `setMilliseconds()`: установка миллисекунд

При установке значений есть возможность передать величину, большую, чем максимальное допустимое значение. В данном случае из значения будет высчитано количество целых величин большего порядка.

=== Объект Math. Математические операции

*Объект* `Math` предоставляет ряд математических функций, которые можно использовать при вычислениях. Рассмотрим основные математические функции.

==== abs()

Функция `abs()` возвращает *абсолютное значение* числа.

==== min() и max()

Функции `min()` и `max()` возвращают соответственно *минимальное* и *максимальное* значение из набора чисел.

==== ceil()

Функция `ceil()` округляет число до *следующего наибольшего целого числа*.

==== floor()

Функция `floor()` округляет число до *следующего наименьшего целого числа*.

==== round()

Функция `round()` округляет число до *следующего наименьшего целого числа*, если его десятичная часть *меньше 0.5*. Если же десятичная часть *равна или больше 0.5*, то округление идет до *ближайшего наибольшего целого числа*.

==== random()

Функция `random()` возвращает *случайное число с плавающей точкой* из диапазона *от 0 до 1*.

==== pow()

Функция `pow()` возвращает *число в определенной степени*.

==== sqrt()

Функция `sqrt()` возвращает *квадратный корень числа*.

==== log()

Функция `log()` возвращает *натуральный логарифм числа*.

==== Тригонометрические функции

Целый ряд функций представляют *тригонометрические функции*: `sin()` - *вычисляет синус угла*, `cos()` - *вычисляет косинус угла*, `tan()` - *вычисляет тангенс угла*. В качестве значения они принимают значение *в радианах*.

==== Константы

Кроме методов *объект* `Math` также определяет *набор встроенных констант*, которые можно использовать в различных вычислениях:

* `Math.PI` (число PI): 3.141592653589793

* `Math.SQRT2` (квадратный корень из двух): 1.4142135623730951

* `Math.SQRT1_2` (половина от квадратного корня из двух): 0.7071067811865476

* `Math.E` (число e или число Эйлера): 2.718281828459045

* `Math.LN2` (натуральный логарифм числа 2): 0.6931471805599453

* `Math.LN10` (натуральный логарифм числа 10): 2.302585092994046

* `Math.LOG2E` (двоичный логарифм числа e): 1.4426950408889634

* `Math.LOG10E` (десятичный логарифм числа e): 0.4342944819032518

=== Объект Array. Работа с массивами

*Объект* `Array` представляет *массив* и предоставляет ряд свойств и методов, с помощью которых мы можем *управлять массивом*.

==== Инициализация массива

Можно создать *пустой массив*, используя *квадратные скобки* или *конструктор* `Array`:

[source,js]
----
var users = new Array();
var people = [];

console.log(users); // Array[0]
console.log(people); // Array[0]
----

Можно сразу же *инициализировать массив* некоторым количеством элементов:

[source,js]
----
var users = new Array("Tom", "Bill", "Alice");
var people = ["Sam", "John", "Kate"];

console.log(users); // ["Tom", "Bill", "Alice"]
console.log(people); // ["Sam", "John", "Kate"]
----

Можно *определить массив* и *по ходу определять в него новые элементы*:

[source,js]
----
var users = new Array();
users[1] = "Tom";
users[2] = "Kate";
console.log(users[1]); // "Tom"
console.log(users[0]); // undefined
----

При этом *не важно*, что по умолчанию массив создается с *нулевой длиной*. С помощью *индексов* мы можем подставить на конкретный индекс в массиве тот или иной элемент.

==== length

Чтобы узнать длину массива, используется *свойство* `length`:

[source,js]
----
var fruit = new Array();
fruit[0] = "яблоки";
fruit[1] = "груши";
fruit[2] = "сливы";

console.log("В массиве fruit " + fruit.length + " элемента: <br/>");
for(var i=0; i < fruit.length; i++)
console.log(fruit[i]);
----

==== Копирование массива. `slice()`

*Копирование массива* может быть *поверхностным* или *неглубоким* (*shallow copy*) и *глубоким* (*deep copy*).

При *неглубоком копировании* достаточно *присвоить* переменной *значение* другой переменной, которая *хранит массив*:

[source,js]
----
var users = ["Tom", "Sam", "Bill"];
console.log(users);     //  ["Tom", "Sam", "Bill"]
var people = users;     //  неглубокое копирование

people[1] = "Mike";     //  изменяем второй элемент
console.log(users);     //  ["Tom", "Mike", "Bill"]
----

Такое поведение не всегда является желательным. Например, необходимо, чтобы после копирования переменные указывали на отдельные массивы. И в этом случае можно использовать глубокое копирование с помощью *метода* `slice()`:

[source,js]
----
var users = ["Tom", "Sam", "Bill"];
console.log(users);             //  ["Tom", "Sam", "Bill"]
var people = users.slice();     //  глубокое копирование

people[1] = "Mike";             //  изменяем второй элемент
console.log(users);             //  ["Tom", "Sam", "Bill"]
console.log(people);            //  ["Tom", "Mike", "Bill"]
----

Также *метод* `slice()` позволяет скопировать *часть массива*:

[source,js]
----
ar users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var people = users.slice(1, 4);
console.log(people);        // ["Sam", "Bill", "Alice"]
----

==== push()

*Метод* `push()` добавляет элемент в *конец массива*.

==== pop()

*Метод* `pop()` удаляет п**оследний элемент** из массива.

==== shift()

*Метод* `shift()` *извлекает* и *удаляет* *первый* элемент из массива.

==== unshift()

*Метод* `unshift()` добавляет новый элемент в *начало массива*.

==== Удаление элемента по индексу. splice()

*Метод* `splice()` удаляет элементы *с определенного индекса*. Например, удаление элементов с третьего индекса:

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(3);
console.log(deleted);       // [ "Alice", "Kate" ]
console.log(users);         // [ "Tom", "Sam", "Bill" ]
----

*Метод* `splice()` возвращает удаленные элементы.

Если в метод передать отрицательный индекс, то удаление будет производиться с конца массива.

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(-1);
console.log(deleted);       // [ "Kate" ]
console.log(users);         // [ "Tom", "Sam", "Bill", "Alice" ]
----

Дополнительная версия *метода* позволяет задать *количество* элементов для удаления.

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(1,3);
console.log(deleted);       // [ "Sam", "Bill", "Alice" ]
console.log(users);         // [ "Tom", "Kate" ]
----

Еще одна версия *метода* `splice()` позволяет вставить вместо удаляемых элементов новые элементы:

[source,js]
----
var users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
var deleted = users.splice(1,3, "Ann", "Bob");
console.log(deleted);       // [ "Sam", "Bill", "Alice" ]
console.log(users);         // [ "Tom", "Ann", "Bob", "Kate" ]
----

==== concat()

*Метод* `concat()` служит для объединения массивов:

[source,js]
----
var fruit = ["яблоки", "груши", "сливы"];
var vegetables = ["помидоры", "огурцы", "картофель"];
var products = fruit.concat(vegetables);

for(var i=0; i < products.length; i++)
    console.log(products[i] );
----
Также можно объединять разнотипные массивы.

==== join()

*Метод* ё объединяет все элементы массива в одну строку:

[source,js]
----
var fruit = ["яблоки", "груши", "сливы", "абрикосы", "персики"];
var fruitString = fruit.join(", ");
console.log(fruitString);
----

В *метод* `join()` передается разделитель `между элементами массива`. В данном случае в качестве разделителя будет использоваться запятая и пробел (", ").

==== sort()

*Метод* `sort()` сортирует массив по возрастанию.

==== reverse()

*Метод* `reverse()` переворачивает массив задом наперед.

В сочетании с *методом*`sort()` можно отсортировать массив по убыванию.

==== Поиск индекса элемента

===== indexOf() и lastIndexOf()

*Методы* `indexOf()` и `lastIndexOf()` возвращают индекс *первого* и *последнего* включения элемента в массиве.

===== every()

*Метод* `every()` проверяет, все ли элементы соответствуют определенному условию:

[source,js]
----
var numbers = [ 1, -12, 8, -4, 25, 42 ];
function condition(value, index, array) {
    var result = false;
    if (value > 0) {
        result = true;
    }
    return result;
};
var passed = numbers.every(condition);
console.log(passed); // false
----

В *метод* `every()` в качестве параметра передается функция, представляющая условие.

[source,js]
----
function condition(value, index, array) {

}
----

Параметр `value` представляет *текущий перебираемый элемент* массива, параметр `index` представляет *индекс* этого элемента, а параметр `array` передает *ссылку на массив*.

===== some()

*Метод* `some()` похож на *метод* `every()`, только он проверяет, соответствует ли *хотя бы один элемент условию*. И в этом случае *метод* `some()` возвращает `true`. Если элементов, соответствующих условию, в массиве нет, то возвращается значение `false`.

===== filter()

*Метод* `filter()`, как `some()` и `every()`, принимает *функцию условия*. Но при этом *возвращает массив* тех элементов, которые соответствуют этому условию.

===== forEach() и map()

*Методы* `forEach()` и `map()` осуществляют *перебор элементов* и выполняют с ними определенный операции. Например, для вычисления квадратов чисел в массиве можно использовать следующий код:

[source,js]
----
var numbers = [ 1, 2, 3, 4, 5, 6];
for(var i = 0; i<numbers.length; i++){

    var result = numbers[i] * numbers[i];

    console.log("Квадрат числа " + numbers[i] + " равен " + result );
}
----

Но с помощью *метода* `forEach()` можно упростить эту конструкцию:

[source,js]
----
var numbers = [ 1, 2, 3, 4, 5, 6];

function square(value) {

    var result = value * value;
    console.log("Квадрат числа " + value + " равен " + result );
};

numbers.forEach(square);
----

*Метод* `forEach()` в качестве параметра принимает все ту же функцию, в которую при переборе элементов передается текущий перебираемый элемент и над ним выполняются операции.

*Метод* `map()` похож на метод `forEach()`, он также в качестве параметра принимает функцию, с помощью которой выполняются операции над перебираемыми элементами массива, но при этом *метод* `map()` возвращает *новый массив* с результатами операций над элементами массива.

=== Объект Number

*Объект* `Number` представляет *числа*. Чтобы создать число, надо передать в *конструктор* `Number` *число или стоку*, представляющую число:

[source,js]
----
var x = new Number(34);
var y = new Number('34');
document.write(x+y); // 68
----

Однако *создавать объект* `Number` можно и просто *присвоив переменной определенное число*:

[source,js]
----
var z = 34;
----

*Объект* `Number` предоставляет ряд свойств и методов. Некоторые его свойства:

* `Number.MAX_VALUE`: наибольшее возможное число. *Приблизительно равно 1.79E+308*. Числа, которые больше этого значения, рассматриваются как `Infinity`

* `Number.MIN_VALUE`: наименьшее возможное положительное число. *Приблизительно равно 5e-324* (где-то около нуля)

* `Number.NaN`: специальное значение, которое указывает, что объект *не является числом*

* `Number.NEGATIVE_INFINITY`: значение, которое обозначает *отрицательную неопределенность* и которое возникает при переполнении. Например, если складывать два отрицательных числа, которые по модулю равны `Number.MAX_VALUE`

* `Number.POSITIVE_INFINITY`: положительная неопределенность. Также, как и отрицательная неопределенность, возникает при переполнении, только теперь в положительную сторону

* `isNaN()`: определяет, *является ли объект числом*. Если объект *не является числом*, то возвращается значение `true` +
Но следующее выражение вернет `false`, хотя значение не является числом: +
[source,js]
----
var f = Number.isNaN("hello"); // false
----

Чтобы избежать подобных ситуаций, лучше применять глобальную функцию isNaN:

[source,js]
----
var f = isNaN("hello"); // true
----

* `parseFloat()`: преобразует строку в число с плавающей точкой.

* `parseInt():` преобразует строку в целое число.

* `toFixed()`: оставляет в числе с плавающей точкой определенное количество знаков в дробной части.

=== Строки

==== Строки и объект String

Для создания *строк* можно как *напрямую присваивать* переменной строку:

[source,js]
----
let name = "Tom";
----

Для работы со *строками* предназначен *объект* `String`, поэтому также можно использовать *конструктор* `String`:

[source,js]
----
var name = new String("Tom");
----

Но как правило, используется *первый* более краткий способ. В первом случае *JavaScript* при необходимости *автоматически преобразует* переменную примитивного типа в *объект* `String`.

*Объект* `String` имеет большой набор *свойств* и *методов*, с помощью которых мы можем манипулировать строками.

Свойство `length` указывает на длину строки:

[source,js]
----
var hello = "привет мир";
console.log("В строке '" + hello + "' " + hello.length + " символов");
----

==== Шаблоны строк

*Шаблоны строк* позволяют вставлять в строку *различные* значения. Для этого *строки* заключаются в *косые кавычки*:

[source,js]
----
let name = "Tom";
let hello = `Hello ${name}`;
console.log(hello);     // Hello Tom

let age = 23;
let info = `${name} is ${age} years old`;
console.log(info);      // Tom is 23 years old
----

Для *вставки* значения в строку оно заключается в *фигурные скобки*, перед которыми ставится *знак доллара*.

Также вместо *скалярных значений* могут добавляться *свойства сложных объектов* или *результаты выражений*.

==== Поиск в строке

Для *поиска в строке* некоторой *подстроки* используются методы `indexOf()` (*индекс первого вхождения подстроки*) и `lastIndexOf()` (*индекс последнего вхождения подстроки*). Эти методы принимают *два параметра*:

* *Подстроку, которую надо найти*

* Необязательный параметр, который указывает, *с какого символа* следует проводить поиск подстроки в строке

Оба этих метода возвращают *индекс символа*, с которого в строке *начинается* подстрока. Если подстрока *не найдена*, то возвращается *число -1*.

Еще один метод - `includes()` возвращает `true`, если *строка содержит определенную подстроку*. С помощью второго дополнительного параметра можно определить *индекс, с которого будет начинаться поиск подстроки*.

==== Выбор подстроки

Для того, чтобы *вырезать из строки подстроку*, применяются методы `substr()` и `substring()`.

*Метод* `substring()` принимает два параметра:

* *индекс символа в строке*, начиная с которого надо проводить обрезку строки

* *индекс*, до которого надо обрезать строку

*Метод* `substr()` также в качестве первого параметра принимает *начальный индекс* подстроки, а в качестве второго - *длину вырезаемой подстроки*. Если второй параметр *не указывается*, то *обрезается вся остальная часть строки*.

==== Управление регистром

Для *изменения регистра* имеются методы `toLowerCase()` (*для перевода в нижний регистр*) и `toUpperCase()` (*для перевода в верхний регистр*).

==== Получение символа по индексу

Чтобы *получить* определенный символ в строке *по индексу*, можно применять методы `charAt()` и `charCodeAt()`. Оба этих метода в качестве параметра принимают *индекс символа*.

Но если в качестве *результата* метод `charAt()` возвращает сам *символ*, то метод `charCodeAt()` возвращает *числовой код* этого символа.

==== Удаление пробелов

Для удаления *начальных* и *концевых пробелов* в стоке используется метод `trim()`.

==== Объединение строк

Метод `concat()` объединяет две строки.

==== Замена подстроки

Метод `replace()` заменяет первое вхождение одной подстроки на другую.

==== Разделение строки

*Метод* `split()` разбивает строку на *массив подстрок* по *определенному разделителю*. В качестве разделителя используется *строка*, которая *передается в метод*.

==== Проверка начала и окончания строки

*Метод* `startsWith()` возвращает `true`, если строка *начинается* с определенной подстроки. А *метод* `endsWith()` возвращает `true`, если строка *оканчивается* на определенную подстроку. При этом играет роль *регистр* символов.

Дополнительный *второй параметр* позволяет указать *индекс* *относительно которого* будет проводиться *сравнение*.

=== Объект RegExp

==== Регулярные выражения

*Регулярные выражения* представляют *шаблон*, который используется для поиска или модификации строки. Для работы с регулярными выражениями в *JavaScript* определен объект `RegExp`.

Определить регулярное выражение можно *двумя способами*:

[source,js]
----
var myExp = /hello/;
var myExp = new RegExp("hello");
----

==== Методы RegExp

Чтобы определить, соответствует ли регулярное выражение строке, в объекте `RegExp` определен метод `test()`. Этот метод возвращает `true`, если строка *соответствует* регулярному выражению, и *false*, если *не соответствует*.

[source,js]
----
var initialText = "hello world!";
var exp = /hello/;
var result = exp.test(initialText);
document.write(result + "<br/>"); // true

initialText = "beautifull wheather";
result = exp.test(initialText);
document.write(result); // false - в строке initialText нет "hello"
----

Аналогично работает *метод* `exec()` - он также проверяет, соответствует ли строка регулярному выражению, только теперь данный метод возвращает ту часть строки, которая *соответствует выражению*. Если *соответствий нет*, то возвращается значение `null`.

==== Группы символов

*Регулярное выражение* не обязательно состоит из *обычных строк*, но также может включать *специальные элементы синтаксиса регулярных выражений*. Один из таких элементов представляют *группы символов*, заключенные в *квадратные скобки*.

[source,js]
----
var initialText = "обороноспособность";
var exp = /[абв]/;
----

Если нам надо определить *наличие* в строке буквенных символов из *определенного диапазона*, то можно разу задать этот *диапазон*:

[source,js]
----
var initialText = "обороноспособность";
var exp = /[а-я]/;
----

Если, наоборот, *не надо*, чтобы строка имела только определенные символы, то необходимо в квадратных скобках перед перечислением символов ставить знак `^`:

[source,js]
----
var initialText = "обороноспособность";
var exp = /[^а-я]/;
----

==== Свойства выражений

* Свойство `global` позволяет найти *все подстроки*, которые *соответствуют* регулярному выражению. *По умолчанию* при поиске подстрок регулярное выражение выбирает *первую* попавшуюся подстроку из строки, которая *соответствует выражению*. Хотя в строке может быть множество подстрок, которые также соответствуют выражению. Для этого применяется данное свойство в виде символа `g` в выражениях

* Свойство `ignoreCase` позволяет найти подстроки, которые соответствуют регулярному выражению, *вне зависимости от регистра символов* в строке. Для этого в регулярных выражениях применяется символ `i`

* Свойство `multiline` позволяет найти подстроки, которые соответствуют регулярному выражению, в *многострочном тексте*. Для этого в регулярных выражениях применяется символ `m`

[source,js]
----
var exp = /мир/i;
var exp = /мир/ig;
----

=== Регулярные выражения в методах String

Ряд методов объекта String могут использовать регулярные выражения в качестве параметра.

==== Разделение строки. Метод split

*Метод* `split()` может использовать регулярные выражения для разделения строк:

[source,js]
----
var initialText = "Сегодня была прекрасная погода";
var exp = /\s/;
var result = initialText.split(exp);
result.forEach(function(value, index, array){

    document.write(value + "<br/>");
})
----

==== Метод match

Для поиска *всех соответствий* в строке применяется метод `match()`:

[source,js]
----
var initialText = "Он пришел домой и сделал домашнюю работу";
var exp = /дом[а-я]*/gi;
var result = initialText.match(exp);
result.forEach(function(value, index, array){

    document.write(value + "<br/>");
})
----

==== Поиск в строке. Метод search

Метод `search()` находит индекс первого включения соответствия в строке:

[source,js]
----
var initialText = "hello world";
var exp = /wor/;
var result = initialText.search(exp);
document.write(result); // 6
----

==== Замена. Метод replace

Метод `replace()` позволяет заменить все соответствия регулярному выражению определенной строкой:

[source,js]
----
var menu = "Завтрак: каша, чай. Обед: суп, чай. Ужин: салат, чай.";
var exp = /чай/gi;
menu = menu.replace(exp, "кофе");
document.write(menu);
----




