= Работа с DOM
:imagesdir: ../assets/img/js

Одой из ключевых задач JavaScript является взаимодействие с пользователем и манипуляция элементами web-страницы. Для JavaScript web-страница доступна в виде *объектной модели документа* (*document object model*) или сокращенно *DOM*. *DOM* описывает структуру web-страницы в виде древовидного представления и предоставляет разработчикам способ получить доступ к отдельным элементам web-страницы.

Важно не путать понятия *BOM* (*Browser Object Model* - *объектная модель браузера*) и *DOM* (*объектная модель документа*). Если *BOM* предоставляет доступ к браузеру и его свойствам в целом, то *DOM* предоставляет доступ к отдельной web-странице или HTML-документу и его элементам.

Рассмотрим простейшую web-страницу:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
</head>
<body>
    <h2>Page Header</h2>
    <div>
        <h3>Block Header</h3>
        <p>Text</p>
    </div>
</body>
</html>
----

*Дерево DOM* для этой страницы будет выглядеть следующим образом:

image::domtree.png[дерево HTML страницы]

Все компоненты упорядочены в *DOM* иерархическим образом, где каждый компонент представляет отдельный *узел*.

Существует следующие *виды узлов*:

* *Element*: HTML-элемент
* *Attr*: атрибут HTML-элемента
* *Document*: корневой узел HTML-документа
* *DocumentType*: DTD или тип схемы XML-документа
* *DocumentFragment*: место для временного хранения частей документа
* *EntityReference*: ссылка на сущность XML-документа
* *ProcessingInstruction*: инструкция обработки web-страницы
* *Comment*: элемент комментария
* *Text*: текст элемента
* *CDATASection*: секция *CDATA* в документе *XML*
* *Entity*: необработанная сущность *DTD*
* *Notation*: нотация, объявленная в *DTD*

== Объект `document`

Для работы со структурой *DOM* в *JavaScript* предназначен *объект `document`*, который определен в глобальном объекте `window`. *Объект `document`* предоставляет ряд свойств и методов для управления элементами страницы.

=== Поиск элементов

Для поиска элементов на странице применяются следующие методы:

* `getElementById(value)`: выбирает элемент, у которого атрибут `id` равен `value`
* `getElementsByTagName(value)`: выбирает все элементы, у которых *тег* равен `value`
* `getElementsByClassName(value)`: выбирает все элементы, которые имеют *класс* `value`
* `querySelector(value)`: выбирает первый элемент, который соответствует *css-селектору* `value`
* `querySelectorAll(value)`: выбирает все элементы, которые соответствуют *css-селектору* `value`

Например, найдем элемент по `id`:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div>
        <h3 id="header">Block Header</h3>
        <p>Text</p>
    </div>
    <script>
        var headerElement = document.getElementById("header");
        document.write("Текст заголовка: " + headerElement.innerText);
    </script>
</body>
</html>
----

С помощью вызова `document.getElementById("header")` находим элемент, у которого `id="header"`. А с помощью свойства `innerText` можно получить текст найденного элемента.

Поиск по определенному тегу:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div>
        <h3>Заголовок</h3>
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var pElements = document.getElementsByTagName("p");

        for (var i = 0; i < pElements.length; i++) {
            document.write("Текст параграфа: " + pElements[i].innerText + "<br/>");
        }
    </script>
</body>
</html>
----

С помощью вызова `document.getElementsByTagName("p")` находим все элементы параграфов. Этот вызов возвращает массив найденных элементов. Поэтому, чтобы получить отдельные элементы массива, необходимо пробежаться по ним в цикле.

Если нам надо получить только первый элемент, то можно к первому элементу найденной коллекции объектов:

[source,javascript]
----
var pElement = document.getElementsByTagName("p")[0];
document.write("Текст параграфа: " + pElement.innerText);
----

Получение элемента по классу:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="article">
        <h3>Заголовок статьи</h3>
        <p class="text">Первый абзац</p>
        <p class="text">Второй абзац</p>
    </div>
    <script>
        var articleDiv = document.getElementsByClassName("article")[0];
        console.log(articleDiv);
        var textElems = document.getElementsByClassName("text");
        for (var i = 0; i < textElems.length; i++) {
            console.log(textElems[i]);
        }
    </script>
</body>
</html>
----

Выбор по селектору CSS:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var elem = document.querySelector(".annotation p");
        document.write("Текст селектора: " + elem.innerText);
    </script>
</body>
</html>
----

Выражение `document.querySelector(".annotation p")` находит элемент, который соответствует селектору `.annotation p`. Если на странице несколько элементов, соответствующих селектору, то метод выберет первый из них. В итоге браузер выведет:

----
Аннотация статьи

Первый абзац

Второй абзац

Текст селектора: Аннотация статьи
----

Чтобы получить все элементы по селектору, можно подобным образом использовать метод `document.querySelectorAll()`, который возвращает массив найденных элементов:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var elems = document.querySelectorAll(".text p");

        for (var i = 0; i < elems.length; i++) {
            document.write("Текст селектора " + i + ": " + elems[i].innerText + "<br/>");
        }
    </script>
</body>
</html>
----

----
Вывод браузера:

Аннотация статьи

Первый абзац

Второй абзац

Текст селектора 0: Первый абзац
Текст селектора 1: Второй абзац
----

== Свойства объекта `document`

Кроме ранее рассмотренных методов *объект* `document` позволяет обратиться к определенным *элементам web-страницы* через *свойства*:

* `documentElement`: предоставляет доступ к корневому элементу `<html>`
* `body`: предоставляет доступ к элементу `<body>` на web-странице
* `images`: содержит коллекцию всех объектов изображений (элементов `img`)
* `links`: содержит коллекцию ссылок - элементов `<a>` и `<area>`, у которых определен атрибут `href`
* `anchors`: предоставляет доступ к коллекции элементов `<a>`, у которых определен атрибут `name`
* `forms`: содержит коллекцию всех *форм* на web-странице

Эти свойства не предоставляют доступ ко всем элементам, однако позволяют получить наиболее часто используемые элементы на web-странице.

Получение всех изображений на странице:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <img src="picure1.png" alt="Картинка 1" />
    <img src="picure2.png" alt="Картинка 2" />
    <img src="picure3.png" alt="Картинка 3" />
    <script>
        var images = document.images;
        // изменим первое изображение
        images[0].src="pics/picture_4.jpg";
        images[0].alt="Новая картинка";
        // перебирем все изображения
        for (var i = 0; i < images.length; i++) {
            document.write("<br/>" + images[i].src);
            document.write("<br/>" + images[i].alt);
        }
    </script>
</body>
</html>
----

Подобно тому, как в коде HTML можно установить атрибуты у элемента `img`, так и в коде JavaScript можно через свойства `src` и `alt` получить и установить значения этих атрибутов.

Рассмотрим получение всех ссылок на странице:

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <a href="article1.html">Статья 1</a>
    <a href="article2.html">Статья 2</a>
    <a href="article3.html">Статья 3</a>
    <script>
        var links = document.links;

        for (var i = 0; i < links.length; i++) {
            document.write("<br/>" + links[i].innerText);
            document.write("<br/>" + links[i].href);
        }
    </script>
</body>
</html>
----

Подобно тому, как в коде HTML можно установить *атрибуты* у элемента `img`, так и в коде *javascript* можно через свойства `src` и `alt` *получить и установить* значения этих атрибутов.

== Объект `Node`

Каждый отдельный узел, будь то *HTML-элемент*, его *атрибут* или *текст*, в структуре *DOM* представлен *объектом* `Node`. Этот объект предоставляет ряд свойств, с помощью которых мы можем получить информацию о данном узле:

* `childNodes`: содержит коллекцию дочерних узлов
* `firstChild`: возвращает первый дочерний узел текущего узла
* `lastChild`: возвращает последний дочерний узел текущего узла
* `previousSibling`: возвращает предыдущий элемент, который находится на одном уровне с текущим
* `nextSibling`: возвращает следующий элемент, который находится на одном уровне с текущим
* `ownerDocument`: возвращает корневой узел документа
* `parentNode`: возвращает элемент, который содержит текущий узел
* `nodeName`: возвращает имя узла
* `nodeType`: возвращает тип узла в виде числа. 1 - элемент, 2 - атрибут, 3 - текст
* `nodeValue`: возвращает или устанавливает значение узла в виде простого текста

== Создание, добавление элементов web-страницы

Для создания элементов объект `document` имеет следующие методы:

* `createElement(elementName)`: создает HTML-элемент, тег которого передается в качестве параметра. Возвращает созданный элемент
* `createTextNode(text)`: создает и возвращает текстовый узел. В качестве параметра передается текст узла.

[source, js]
----
var elem = document.createElement("div");
var elemText = document.createTextNode("Привет мир");
----

Переменная `elem` будет хранить ссылку на элемент `div`. Однако одного создания элементов недостаточно, их еще надо добавить на web-страницу.

Для добавления элементов мы можем использовать один из методов объекта `Node`:

* `appendChild(newNode)`: добавляет новый узел `newNode` в конец коллекции дочерних узлов
* `insertBefore(newNode, referenceNode)`: добавляет новый узел `newNode` перед узлом `referenceNode`

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="article">
        <h3>Заголовок статьи</h3>
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var articleDiv = document.querySelector("div.article");
        // создаем элемент
        var elem = document.createElement("h2");
        // создаем для него текст
        var elemText = document.createTextNode("Привет мир");
        // добавляем текст в элемент в качестве дочернего элемента
        elem.appendChild(elemText);
        // добавляем элемент в блок div
        articleDiv.appendChild(elem);
    </script>
</body>
</html>
----

Однако необязательно для определения текста внутри элемента создавать дополнительный текстовый узел, так как мы можем воспользоваться свойством `textContent` и напрямую ему присвоить текст:

[source, js]
----
var elem = document.createElement("h2");
elem.textContent = "Привет мир";
----

В этом случае текстовый узел будет создан неявно при установке текста.

=== Копирование элементов

Иногда элементы бывают довольно сложными по составу, и гораздо проще их скопировать, чем с помощью отдельных вызовов создавать из содержимое. Для копирования уже имеющихся узлов у объекта `Node` можно использовать метод `cloneNode()`.

В метод `cloneNode()` в качестве параметра передается логическое значение: если передается `true`, то элемент будет копироваться со всеми дочерними узлами; если передается `false` - то копируется без дочерних узлов.

=== Удаление элемента

Для удаления элемента вызывается метод `removeChild(removalNode)` объекта `Node`. Этот метод удаляет один из дочерних узлов.

=== Замена элемента

Для замены элемента применяется метод `replaceChild(newNode, oldNode)` объекта `Node`.

== Объект `Element`

Кроме методов и свойств объекта `Node` в *JavaScript* мы можем использовать свойства и методы *объектов `Element`*. Важно не путать эти два объекта: `Node` и `Element`. `Node` представляет все узлы web-страницы, в то время как объект `Element` представляет непосредственно только HTML-элементы. То есть *объекты `Element`* - это фактически те же самые узлы - объекты `Node`, у которых тип узла (свойство `nodeType`) равно 1.

Одним из ключевых свойств объекта `Element` является свойство `tagName`, которое возвращает тег элемента. Например, получим все элементы, которые есть на странице:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="article">
        <h3>Заголовок статьи</h3>
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        function getChildren(elem) {
            for(var i in elem.childNodes) {
                if(elem.childNodes[i].nodeType===1) {
                    console.log(elem.childNodes[i].tagName);
                    getChildren(elem.childNodes[i]);
                }
            }
        }
        var root = document.documentElement;
        console.log(root.tagName);
        getChildren(root);
    </script>
</body>
</html>
----

=== Свойства `innerText` и `innerHTML`

Для получения или установки текстового содержимого элемента можно использовать свойство `innerText`, а для получения или установки HTML-кода - свойство `innerHTML`.

Надо отметить, что свойство `innerText` во многом аналогично свойству `textContent`. То есть следующие вызовы будут равноценны:

[source, js]
----
var pElement = document.querySelectorAll("div.article p")[0];
pElement.innerText = "hello";
pElement.textContent = "hello";
----

Установка HTML-кода у элемента:

[source, js]
----
var articleDiv = document.querySelector("div.article");
articleDiv.innerHTML ="<h2>Hello World!!!</h2><p>bla bla bla</p>";
----

=== Методы объекта `Element`

Среди методов объекта `Element` можно отметить *методы управления атрибутами*:

* `getAttribute(attr)`: возвращает значение атрибута `attr`
* `setAttribute(attr, value)`: устанавливает для атрибута `attr` значение `value`. Если атрибута нет, то он добавляется
* `removeAttribute(attr)`: удаляет атрибут `attr` и его значение

Работа с атрибутами:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div class="article" style="color:red;">
        <h3>Заголовок статьи</h3>
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var articleDiv = document.querySelector("div.article");
        // получаем атрибут style
        var styleValue = articleDiv.getAttribute("style");
        console.log("До изменения атрибута: " + styleValue);
        // удаляем атрибут
        articleDiv.removeAttribute("style");
        // добавляем заново атрибут style
        articleDiv.setAttribute("style", "color:blue;");
        styleValue = articleDiv.getAttribute("style");
        console.log("После изменения атрибута: " + styleValue);
    </script>
</body>
</html>
----

=== Размеры и позиция элементов

Элементы имеют ряд свойств, которые позволяют определить размер элемента. Но важно понимать разницу между всеми этими свойствами.

Свойства `offsetWidth` и `offsetHeight` определяют соответственно ширину и высоту элемента в пикселях. В ширину и высоту включается граница элемента.

Свойства `clientWidth` и `clientHeight` также определяют ширину и высоту элемента в пикселях, но уже без учета границы.

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
        #rect {
            width: 100px;
            height: 100px;
            background: #50c878;
            border: 3px solid silver;
        }
    </style>
</head>
<body>
    <div id="rect"></div>
    <script>
        var rect = document.getElementById("rect");
        console.log("offsetHeight: " + rect.offsetHeight);
        console.log("offsetWidth: " + rect.offsetWidth);
        console.log("clientHeight: " + rect.clientHeight);
        console.log("clientWidth: " + rect.clientWidth);
    </script>
</body>
</html>
----

Для определения позиции элемента наиболее эффективным способом является метод `getBoundingClientRect()`.

Этот метод возвращает объект со свойствами `top`, `bottom`, `left`, `right`, которые указывают на смещение элемента относительно верхнего левого угла браузера.

=== Изменение стиля элементов

Для работы со стилевыми свойствами элементов в JavaScript применяются, главным образом, два подхода:

* *Изменение свойства `style`*
* *Изменение значения атрибута `class`*

==== Свойство `style`

Свойство `style` представляет сложный объект для управления стилем и напрямую сопоставляется с атрибутом `style` HTML-элемента. Этот объект содержит набор свойств CSS: `element.style.свойствоCSS`.

[source, js]
----
var root = document.documentElement;
// устанавливаем стиль
root.style.color = "blue";
// получаем значение стиля
document.write(root.style.color);
----

----
blue
----

Однако ряд свойств CSS в названиях имеют дефис, например, `font-family`. В JavaScript для этих свойств дефис не употребляется. Только первая буква, которая идет после дефиса, переводится в верхний регистр.

[source, js]
----
var root = document.documentElement;
root.style.fontFamily = "Verdana";
----

==== Свойство `className`

С помощью свойства `className` можно установить атрибут `class` HTML-элемента:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    .blueStyle {
        color:blue;
        font-family:Verdana;
    }
    .article {
        font-size:20px;
    }
    </style>
</head>
<body>
    <div class="article">
        <h3>Заголовок статьи</h3>
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        var articleDiv = document.querySelector("div.article");
        // установка нового класса
        articleDiv.className = "blueStyle";
        // получаем название класса
        document.write(articleDiv.className);
    </script>
</body>
</html>
----

Благодаря использованию классов не придется настраивать каждое отдельное свойство css с помощью свойства `style`.

Но при этом надо учитывать, что прежнее значение атрибута `class` удаляется. Поэтому, если нам надо добавить класс, надо объединить его название со старым классом.

И если надо вовсе удалить все классы, то можно присвоить свойству пустую строку.

==== Свойство `classList`

Выше было рассмотрено, как добавлять классы к элементу, однако для управления множеством классов гораздо удобнее использовать свойство `classList`. Это свойство представляет объект, реализующий следующие методы:

* `add(className)`: добавляет класс `className`
* `remove(className)`: удаляет класс `className`
* `toggle(className)`: переключает у элемента класс на `className`. Если класса нет, то он добавляется, если есть, то удаляется

[source, js]
----
var articleDiv = document.querySelector("div.article");
// удаляем класс
articleDiv.classList.remove("article");
// добавляем класс
articleDiv.classList.add("blueStyle");
// переключаем класс
articleDiv.classList.toggle("article");
----

== Создание своего элемента HTML

По умолчанию HTML предоставляет ряд встроенных элементов, из которых можно составить структуру web-страницы. Однако нет ограничений на использование встроенных HTML-элементов и можно создать и использовать свои HTML-элементы.

В JavaScript HTML-элемент представлен интерфейсом `HTMLElement`. Соответственно, реализуя данный интерфейс в JavaScript, мы можем создать свои *классы*, которые будут представлять HTML-элементы, и потом их использовать.

Чтобы определить *класс*, который будет представлять HTML-элемент, достаточно создать класс, который реализует интерфейс `HTMLElement`:

[source, js]
----
class HelloMetanit extends HTMLElement {
}
----

Второй важный момент - нужно зарегистрировать разработанный HTML-элемент, что бы браузер знал, что есть такой элемент. Для этого применяется встроенная функция:

[source, js]
----
customElements.define(name, constructor, options);
----

Она принимает три параметра:

* `name`: имя разработанного элемента HTML, который будет представлять класс JavaScript. Важно: имя должно содержать дефис.
* `constructor`: конструктор (по сути класс JavaScript), который представляет разработанный элемент HTML.
* `options`: необязательный параметр - объект, который настраивает разработанный HTML-элемент.

Как правило, классы кастомных элементов применяют *конструктор*. Причем в самом начале конструктора должен идти вызов функции `super()`, который гарантирует, что класс унаследовал все методы, атрибуты и свойства интерфейса `HTMlElement`.

[source, js]
----
class HelloMetanit extends HTMLElement {
    constructor() {
        super();
    }
}
----

Но кроме того, в конструкторе мно определить некоторую базовую логику элемента.

=== Добавление методов

Как и в обычных классах, мы можем определять в классах элементов методы и затем вызывать их.

=== События жизненного цикла

*Кастомный элемент HTML* имеет свой *жизненный цикл*, который описывается следующими методами:

* `connectedCallback`: вызывается каждый раз, когда разработанный HTML-элемент добавляется в DOM.
* `disconnectedCallback`: вызывается каждый раз, когда разработанный HTML-элемент удаляется из DOM.
* `adoptedCallback`: вызывается каждый раз, когда разработанный HTML-элемент перемещается в новый элемент.
* `attributeChangedCallback`: вызывается при каждом изменении (добавлении, изменении значения или удаления) атрибута разработанного HTML-элемента.

=== Добавление атрибутов

Также мы можем определить у элемента свои атрибуты и затем использовать их.

[source, js]
----
this.style.color = "red";
if (this.hasAttribute("hellocolor")) {
    this.style.color = this.getAttribute("hellocolor");
}
----

=== Стилизация CSS

Стилизация элемента через CSS производится так же, как и стилизация любого другого элемента.
