= Работа с DOM
:imagesdir: ../assets/img/js

Одой из ключевых задач *JavaScript* является *взаимодействие с пользователем* и *манипуляция элементами веб-страницы*. Для *JavaScript* *веб-страница* доступна в виде *объектной модели документа* (*document object model*) или сокращенно *DOM*. *DOM* описывает структуру *веб-станицы* в виде *древовидного представления* и предоставляет разработчикам способ получить *доступ* к отдельным *элементам* *веб-станицы*.

Важно не путать понятия *BOM* (*Browser Object Model* - *объектная модель браузера*) и *DOM* (*объектная модель документа*). Если *BOM* предоставляет доступ *к браузеру и его свойствам* в целом, то *DOM* предоставляет доступ к *отдельной веб-странице* или *html-документу и его элементам*.

Рассмотрим простейшую веб-страницу:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
</head>
<body>
    <h2>Page Header</h2>
    <div>
        <h3>Block Header</h3>
        <p>Text</p>
    </div>
</body>
</html>
----
*Дерево* *DOM* для этой страницы будет выглядеть следующим образом:

image::domtree.png[дерево html страницы]

Все компоненты упорядочены в *DOM* *иерархическим* образом, где каждый компонент представляет *отдельный узел*.

Существует следующие виды узлов:

* *Element*: html-элемент

* *Attr*: атрибут html-элемента

* *Document*: корневой узел html-документа

* *DocumentType*: DTD или тип схемы XML-документа

* *DocumentFragment*: место для временного хранения частей документа

* *EntityReference*: ссылка на сущность XML-документа

* *ProcessingInstruction*: инструкция обработки веб-страницы

* *Comment*: элемент комментария

* *Text*: текст элемента

* *CDATASection*: секция CDATA в документе XML

* *Entity*: необработанная сущность DTD

* *Notation*: нотация, объявленная в DTD

== Объект document
Для работы со структурой *DOM* в *JavaScript* предназначен *объект* `document`, который определен в глобальном *объекте* `window`. *Объект* `document` предоставляет ряд свойств и методов для управления элементами страницы.

=== Поиск элементов
Для поиска элементов на странице применяются следующие методы:

* `getElementById(value)`: выбирает элемент, у которого атрибут `id` равен `value`

* `getElementsByTagName(value)`: выбирает все элементы, у которых *тег* равен `value`

* `getElementsByClassName(value)`: выбирает все элементы, которые имеют *класс* `value`

* `querySelector(value)`: выбирает первый элемент, который соответствует *css-селектору* `value`

* `querySelectorAll(value)`: выбирает все элементы, которые соответствуют *css-селектору* `value`

=== Свойства объекта document
Кроме ранее рассмотренных методов *объект* `document` позволяет обратиться к определенным *элементам веб-страницы* через *свойства*:

* `documentElement`: предоставляет доступ к корневому элементу `<html>`

* `body`: предоставляет доступ к элементу `<body>` на веб-странице

* `images`: содержит коллекцию всех объектов изображений (элементов `img`)

* `links`: содержит коллекцию ссылок - элементов `<a>` и `<area>`, у которых определен атрибут `href`

* `anchors`: предоставляет доступ к коллекции элементов `<a>`, у которых определен атрибут `name`

* `forms`: содержит коллекцию всех *форм* на веб-странице

Эти свойства не предоставляют доступ ко всем элементам, однако позволяют получить наиболее часто используемые элементы на веб-странице.

Получение всех изображений на странице:

[source, js]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <img src="picure1.png" alt="Картинка 1" />
    <img src="picure2.png" alt="Картинка 2" />
    <img src="picure3.png" alt="Картинка 3" />
<script>
var images = document.images;
// изменим первое изображение
images[0].src="pics/picture_4.jpg";
images[0].alt="Новая картинка";
// перебирем все изображения
for(var i=0; i<images.length;i++){

    document.write("<br/>" + images[i].src);
    document.write("<br/>" + images[i].alt);
}
</script>
</body>
</html>
----

Подобно тому, как в коде `html` можно установить *атрибуты* у элемента `img`, так и в коде *javascript* можно через свойства `src` и `alt` *получить и установить* значения этих атрибутов.

== Объект Node
Каждый отдельный узел, будь то *html-элемент*, его *атрибут* или *текст*, в структуре *DOM* представлен *объектом* `Node`. Этот объект предоставляет ряд свойств, с помощью которых мы можем получить информацию о данном узле:

* `childNodes`: содержит коллекцию дочерних узлов

* `firstChild`: возвращает первый дочерний узел текущего узла

* `lastChild`: возвращает последний дочерний узел текущего узла

* `previousSibling`: возвращает предыдущий элемент, который находится на одном уровне с текущим

* `nextSibling`: возвращает следующий элемент, который находится на одном уровне с текущим

* `ownerDocument`: возвращает корневой узел документа

* `parentNode`: возвращает элемент, который содержит текущий узел

* `nodeName`: возвращает имя узла

* `nodeType`: возвращает тип узла в виде числа. 1 - элемент, 2 - атрибут, 3 - текст

* `nodeValue`: возвращает или устанавливает значение узла в виде простого текста

=== Создание, добавление  элементов веб-станицы
Для создания элементов *объект* `document` имеет следующие методы:

* `createElement(elementName)`: создает *элемент* `html`, *тег* которого передается в качестве *параметра*. Возвращает созданный элемент

* `createTextNode(text)`: создает и возвращает *текстовый узел*. В качестве параметра передается текст узла.

[source, js]
----
var elem = document.createElement("div");
var elemText = document.createTextNode("Привет мир");
----

Переменная `elem` будет хранить ссылку на *элемент* `div`. Однако одного создания элементов недостаточно, их еще надо *добавить* на веб-страницу.

Для добавления элементов мы можем использовать один из методов *объекта* `Node`:

* `appendChild(newNode)`: добавляет новый узел `newNode` в *конец коллекции дочерних узлов*

* `insertBefore(newNode, referenceNode)`: добавляет новый узел `newNode` перед узлом `referenceNode`

[source, js]
----
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
</head>
<body>
<div class="article">
<h3>Заголовок статьи</h3>
<p>Первый абзац</p>
<p>Второй абзац</p>
</div>
<script>
var articleDiv = document.querySelector("div.article");
// создаем элемент
var elem = document.createElement("h2");
// создаем для него текст
var elemText = document.createTextNode("Привет мир");
// добавляем текст в элемент в качестве дочернего элемента
elem.appendChild(elemText);
// добавляем элемент в блок div
articleDiv.appendChild(elem);
</script>
</body>
</html>
----

Однако необязательно для определения текста внутри элемента создавать дополнительный текстовый узел, так как мы можем воспользоваться *свойством* `textContent` и напрямую ему присвоить текст:

[source, js]
----
var elem = document.createElement("h2");
elem.textContent = "Привет мир";
----

В этом случае текстовый узел будет создан неявно при установке текста.

=== Копирование элементов
Иногда элементы бывают довольно сложными по составу, и гораздо проще их скопировать, чем с помощью отдельных вызовов создавать из содержимое. Для копирования уже имеющихся узлов у *объекта* `Node` можно использовать метод `cloneNode()`.
В *метод* `cloneNode()` в качестве параметра передается *логическое значение*: если передается `true`, то элемент будет копироваться *со всеми дочерними узлами*; если передается `false` - то копируется *без дочерних узлов*.

=== Удаление элемента
Для удаления элемента вызывается метод `removeChild(removalNode)` *объекта* `Node`. Этот метод удаляет один из дочерних узлов.

=== Замена элемента
Для замены элемента применяется метод `replaceChild(newNode, oldNode)` *объекта* `Node`.

== Объект Element

=== Управление элементами
Кроме методов и свойств *объекта* `Node` в `JavaScript` мы можем использовать свойства и методы *объектов* `Element`. Важно не путать эти два объекта: `Node` и `Element`. `Node` представляет *все узлы веб-станицы*, в то время как *объект* `Element` представляет непосредственно *только html-элементы*. То есть *объекты* `Element` - это фактически те же самые *узлы* - *объекты* `Node`, у которых *тип узла* (*свойство* `nodeType`) *равно 1*.

Одним из ключевых свойств *объекта* `Element` является *свойство* `tagName`, которое возвращает *тег элемента*. Например, получим все элементы, которые есть на странице:

[source, js]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
<div class="article">
<h3>Заголовок статьи</h3>
<p>Первый абзац</p>
<p>Второй абзац</p>
</div>
<script>
function getChildren(elem){

    for(var i in elem.childNodes){

        if(elem.childNodes[i].nodeType===1){

            console.log(elem.childNodes[i].tagName);
            getChildren(elem.childNodes[i]);
        }
    }
}
var root = document.documentElement;
console.log(root.tagName);
getChildren(root);
</script>
</body>
</html>
----

=== Свойства innerText и innerHTML

Для получения или установки *текстового содержимого* элемента можно использовать свойство `innerText`, а для получения или установки *кода html* - *свойство* `innerHTML`.

Надо отметить, что *свойство* `innerText` во многом аналогично *свойству* `textContent`. То есть следующие вызовы будут равноценны:

[source, js]
----
var pElement = document.querySelectorAll("div.article p")[0];
pElement.innerText = "hello";
pElement.textContent = "hello";
----

Установка *кода* html у элемента:

[source, js]
----
var articleDiv = document.querySelector("div.article");
articleDiv.innerHTML ="<h2>Hello World!!!</h2><p>bla bla bla</p>";
----

=== Методы объекта Element

Среди методов *объекта* `Element` можно отметить *методы управления атрибутами*:

* `getAttribute(attr)`: возвращает значение атрибута `attr`

* `setAttribute(attr, value)`: устанавливает для атрибута `attr` значение `value`. Если атрибута нет, то он добавляется

* `removeAttribute(attr)`: удаляет атрибут `attr` и его значение

Работа с атрибутами:

[source, js]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
<div class="article" style="color:red;">
<h3>Заголовок статьи</h3>
<p>Первый абзац</p>
<p>Второй абзац</p>
</div>
<script>
var articleDiv = document.querySelector("div.article");
// получаем атрибут style
var styleValue = articleDiv.getAttribute("style");
console.log("До изменения атрибута: " + styleValue);
// удаляем атрибут
articleDiv.removeAttribute("style");
// добавляем заново атрибут style
articleDiv.setAttribute("style", "color:blue;");
styleValue = articleDiv.getAttribute("style");
console.log("После изменения атрибута: " + styleValue);
</script>
</body>
</html>
----

=== Размеры и позиция элементов

*Элементы* имеют ряд свойств, которые позволяют определить *размер элемента*. Но важно понимать разницу между всеми этими свойствами.

Свойства `offsetWidth` и `offsetHeight` определяют соответственно *ширину и высоту элемента в пикселях*. В ширину и высоту включается *граница* элемента.

Свойства `clientWidth` и `clientHeight` также определяют *ширину и высоту элемента в пикселях*, но уже *без учета границы*.

[source, js]
----
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<style>
#rect {
width: 100px;
height: 100px;
background: #50c878;
border: 3px solid silver;
}
</style>
</head>
<body>
<div id="rect"></div>
<script>
var rect = document.getElementById("rect");
console.log("offsetHeight: " + rect.offsetHeight);
console.log("offsetWidth: " + rect.offsetWidth);
console.log("clientHeight: " + rect.clientHeight);
console.log("clientWidth: " + rect.clientWidth);
</script>
</body>
</html>
----

Для определения позиции элемента наиболее эффективным способом является *метод* `getBoundingClientRect()`.

Этот метод возвращает *объект* со свойствами `top`, `bottom`, `left`, `right`, которые указывают на *смещение элемента* относительно *верхнего левого угла* браузера.

=== Изменение стиля элементов
Для работы со *стилевыми свойствами элементов* в *JavaScript* применяются, главным образом, два подхода:

* Изменение *свойства* `style`

* Изменение значения *атрибута* `class`

==== Свойство style
*Свойство* `style` представляет *сложный объект* для управления стилем и напрямую сопоставляется с *атрибутом* `style` *html-элемента*. Этот объект содержит *набор свойств CSS*: `element.style.свойствоCSS`.

[source, js]
----
var root = document.documentElement;
// устанавливаем стиль
root.style.color = "blue";
// получаем значение стиля
document.write(root.style.color); // blue
----

Однако ряд *свойств* *css* в названиях имеют дефис, например, `font-family`. В *JavaScript* для этих свойств *дефис не употребляется*. Только первая буква, которая идет после дефиса, переводится в верхний регистр.

[source, js]
----
var root = document.documentElement;
root.style.fontFamily = "Verdana";
----

==== Свойство className
С помощью свойства `className` можно установить *атрибут* `class` элемента html:

[source, js]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    .blueStyle{
        color:blue;
        font-family:Verdana;
    }
    .article{
        font-size:20px;
    }
    </style>
</head>
<body>
<div class="article">
<h3>Заголовок статьи</h3>
<p>Первый абзац</p>
<p>Второй абзац</p>
</div>
<script>
var articleDiv = document.querySelector("div.article");
// установка нового класса
articleDiv.className = "blueStyle";
// получаем название класса
document.write(articleDiv.className);
</script>
</body>
</html>
----

Благодаря использованию классов не придется настраивать каждое отдельное *свойство css* с помощью *свойства style*.

Но при этом надо учитывать, что прежнее значение *атрибута class* *удаляется*. Поэтому, если нам надо добавить класс, надо объединить его название со старым классом.

И если надо вовсе удалить все классы, то можно присвоить свойству пустую строку.

==== Свойство classList
Выше было рассмотрено, как добавлять классы к элементу, однако для управления множеством классов гораздо удобнее использовать *свойство* `classList`. Это свойство представляет объект, реализующий следующие методы:

* `add(className)`: добавляет класс className

* `remove(className)`: удаляет класс className

* `toggle(className)`: переключает у элемента класс на className. Если класса нет, то он добавляется, если есть, то удаляется

[source, js]
----
var articleDiv = document.querySelector("div.article");
// удаляем класс
articleDiv.classList.remove("article");
// добавляем класс
articleDiv.classList.add("blueStyle");
// переключаем класс
articleDiv.classList.toggle("article");
----

=== Создание своего элемента HTML

По умолчанию *HTML* предоставляет ряд встроенных элементов, из которых мы можем составить *структуру веб-страницы*. Однако мы не ограничены *встроенными html-элементами* и можем сами создать и использовать *свои элементы html*.

В *JavaScript* *HTML-элемент* представлен интерфейсом `HTMLElement`. Соответственно, реализуя даннй интерфейс в *JavaScript*, мы можем создать свои *классы*, которые будут представлять *элементы html*, и потом их использовать.

Чтобы определить *класс*, который будет *представлять html-элемент*, нам достаточно *создать класс*, который *реализует интерфейс* `HTMLElement`:

[source, js]
----
class HelloMetanit extends HTMLElement {

}
----

Второй важный момент - нам надо *зарегистрировать* наш *кастомный html-элемент*, что бы браузер знал, что есть такой элемент. Для этого применяется *встроенная функция*:

[source, js]
----
customElements.define(name, constructor, options);
----

Она принимает три параметра:

* `name`: имя кастомного элемента html, который будет представлять класс *JavaScript*. Важно: имя должно содержать *дефис*.

* `constructor`: *конструктор* (по сути класс JavaScript), который представляет кастомный элемент html.

* `options`: необязательный параметр - объект, который *настраивает* кастомный html-элемент.

Как правило, классы кастомных элементов применяют *конструктор*. Причем в самом начале конструктора должен идти вызов функции `super()`, который гарантирует, что класс *унаследовал* все методы, атрибуты и свойства *интерфейса* `HTMlElement`.

[source, js]
----
class HelloMetanit extends HTMLElement {
    constructor() {
        super();
    }
}
----

Но кроме того, в конструкторе мно определить некоторую базовую логику элемента.

==== Добавление методов
Как и в обычных классах, мы можем определять в классах элементов методы и затем вызывать их.

==== События жизненного цикла
*Кастомный элемент html* имеет свой *жизненный цикл*, который описывается следующими методами:

* `connectedCallback`: вызывается каждый раз, когда кастомный элемент html добавляется в DOM.

* `disconnectedCallback`: вызывается каждый раз, когда кастомный элемент html удаляется из DOM.

* `adoptedCallback`: вызывается каждый раз, когда кастомный элемент html перемещается в новый элемент.

* `attributeChangedCallback`: вызывается при каждом изменении (добавлении, изменении значения или удаления) атрибута кастомного элемента html.

==== Добавление атрибутов
Также мы можем определить у элемента свои атрибуты и затем использовать их.

[source, js]
----
this.style.color = "red";
if (this.hasAttribute("hellocolor")) {
    this.style.color = this.getAttribute("hellocolor");
}
----

==== Стилизация CSS
Стилизация элемента через *CSS* производится также, как и стилизация любого другого элемента.
