= Реализация ООП в JavaScript

== Объекты

Для работы с сущностями в *JavaScript* используются *объекты*. Каждый *объект* может хранить свойства, описывающие его *состояние*, и методы, описывающие его *поведение*.

=== Создание нового объекта

Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора *Object*:

[source,js]
----
var user = new Object();
----

В данном случае *объект* называется `user`. Он определяется так же, как и любая обычная переменная с помощью ключевого слова `var`.

Выражение `new Object()` представляет вызов *конструктора* - функции, создающей новый объект. Для вызова конструктора применяется *оператор* `new`. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование *фигурных скобок*:

[source,js]
----
var user = {};
----

Более распространенным является второй способ создания объекта.

=== Свойства объекта

После создания объекта можно определить в нем *свойства*. Чтобы *определить свойство*, надо после названия объекта через точку указать *имя свойства* и присвоить ему *значение*:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
----

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого появляется возможность использовать эти свойства:

[source,js]
----
console.log(user.name);
console.log(user.age);
----

Также можно определить свойства *при определении объекта*:

[source,js]
----
var user = {
    name: "Tom",
    age: 26
};
----

В этом случае для присвоения значения свойству используется символ _двоеточия_, а после определения свойства ставится _запятая_ (а не точка с запятой).

Кроме того, доступен *сокращенный способ определения свойств*:

[source,js]
----
var name = "Tom";
var age = 34;
var user = {name, age};
console.log(user.name);
console.log(user.age);
----

=== Методы объекта

*Методы объекта* определяют его *поведение* или *действия*, которые он производит. *Методы* представляют собой *функции*. Например, определим метод, который бы выводил имя и возраст человека:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function() {
    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
----

Как и в случае с функциями _методы сначала определяются, а потом уже вызываются_.

Также методы могут определяться непосредственно при определении объекта:

[source,js]
----
var user = {
    name: "Tom",
    age: 26,
    display: function() {
        console.log(this.name);
        console.log(this.age);
    }
};
----

Как и в случае со свойствами, методу присваивается *ссылка на функцию* с помощью знака _двоеточия_.

Чтобы обратиться к *свойствам* или *методам* объекта внутри этого объекта, используется ключевое слово `this`. Оно означает *ссылку на текущий объект*.

Также можно использовать *сокращенный способ определения методов*, когда _двоеточие_ и слово `function` опускаются:

[source,js]
----
var user = {
    name: "Tom",
    age: 26,
    display() {
        console.log(this.name, this.age);
    },
    move(place) {
        console.log(this.name, "goes to", place);
    }
};

user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
----

=== Синтаксис массивов

Существует также альтернативный способ определения свойств и методов с помощью *синтаксиса массивов*:

[source,js]
----
var user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function() {
    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
----

Название каждого свойства или метода _заключается в кавычки и в квадратные скобки_, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо *нотацию точки* `user.name`, либо обращаться так: `user["name"]`.

=== Строки в качестве свойств и методов

Названия свойств и методов объекта всегда представляют _строки_. То есть предыдущее определение объекта можно переписать так:

[source,js]
----
var user = {
    "name": "Tom",
    "age": 26,
    "display": function() {
        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
----

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных *пробелом*:

[source,js]
----
var user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function() {
        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
----

В этом случае для обращения к подобным свойствам и методам мы должны использовать *синтаксис массивов*.

=== Удаление свойств

Удалять свойства и методы необходимо с помощью оператора `delete`. Как и в случае с добавлением удалять свойства можно двумя способами. Первый способ - *использование нотации точки*:

[source,js]
----
delete объект.свойство
----

Либо использовать *синтаксис массивов*:

[source,js]
----
delete объект["свойство"]
----

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function() {
    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
----

После удаления свойство будет _не определено_, поэтому при попытке обращения к нему, программа вернет значение `undefined`.

== Вложенные объекты и массивы в объектах

Одни объекты могут содержать в качестве свойств другие объекты. Например, есть объект страны, у которой можно выделить ряд свойств. Одно из этих свойств может представлять столицу. Но у столицы мы также можем выделить свои свойства, например, название, численность населения, год основания:

[source,js]
----
var country = {
    name: "Германия",
    language: "немецкий",
    capital: {
        name: "Берлин",
        population: 3375000,
        year: 1237
    }
};
console.log("Столица: " + country.capital.name); // Берлин
console.log("Население: " + country["capital"]["population"]); // 3375000
console.log("Год основания: " + country.capital["year"]); // 1237
----

Для доступа к свойствам таких вложенных объектов мы можем использовать *стандартную нотацию точки*:

[source,js]
----
country.capital.name
----

Либо обращаться к ним как к *элементам массивов*:

[source,js]
----
country["capital"]["population"]
----

Также допустим *смешанный вид обращения*:

[source,js]
----
country.capital["year"]
----

В качестве свойств также могут использоваться *массивы*, в том числе *массивы других объектов*:

[source,js]
----
capital:{
        name: "Берн",
        population: 126598
    },
    cities: [
        { name: "Цюрих", population: 378884},
        { name: "Женева", population: 188634},
        { name: "Базель", population: 164937}
    ]
};

// вывод всех элементов из country.languages
document.write("<h3>Официальные языки Швейцарии</h3>");
for (var i = 0; i < country.languages.length; i++) {
    document.write(country.languages[i] + "<br/>");
}

// вывод всех элементов из country.cities
document.write("<h3>Города Швейцарии</h3>");
for (var i = 0; i < country.cities.length; i++) {
    document.write(country.cities[i].name + "<br/>");
}
----

В объекте `country` имеется свойство `languages,` содержащее *массив строк*, а также свойство `cities`, хранящее *массив однотипных объектов*.

С этими массивами можно работать так же, как и с любыми другими, например, перебрать с помощью цикла `for`.

При переборе массива объектов каждый текущий элемент будет представлять *отдельный объект*, поэтому мы можем обратиться к его *свойствам* и *методам*:

[source,js]
----
country.cities[i].name
----

== Проверка наличия и перебор методов и свойств

При *динамическом определении* в объекте новых *свойств* и *методов* перед их использованием бывает важно проверить, а есть ли уже такие методы и свойства. Для этого в *JavaScript* может использоваться оператор `in`:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function() {
    console.log(user.name);
    console.log(user.age);
};

var hasNameProp = "name" in user;
console.log(hasNameProp); // true - свойство name есть в user
var hasWeightProp = "weight" in user;
console.log(hasWeightProp); // false - в user нет свойства или метода под названием weight
----

Оператор `in` имеет следующий синтаксис: `"свойство|метод" in объект` - в кавычках идет *название свойства или метода*, а после `in` - *название объекта*. Если свойство или метод с подобным именем имеется, то оператор возвращает `true`. Если *нет* - то возвращается `false`.

*Альтернативный способ* заключается на значение `undefined`. Если свойство или метод равен `undefined`, то эти свойство или метод не определены:

[source,js]
----
var hasNameProp = user.name !== undefined;
console.log(hasNameProp); // true
var hasWeightProp = user.weight !== undefined;
console.log(hasWeightProp); // false
----

И так как объекты представляют тип `Object`, а значит, имеет *все его методы и свойства*, то *объекты* также могут использовать метод `hasOwnProperty()`, который определен в типе `Object`:

[source,js]
----
var hasNameProp = user.hasOwnProperty('name');
console.log(hasNameProp); // true
var hasDisplayProp = user.hasOwnProperty('display');
console.log(hasDisplayProp); // true
var hasWeightProp = user.hasOwnProperty('weight');
console.log(hasWeightProp); // false
----

=== Перебор свойств и методов

С помощью цикла `for` мы можем перебрать *объект как обычный массив* и получить все его свойства и методы и их значения:

[source,js]
----
var user = {};
user.name = "Tom";
user.age = 26;
user.display = function() {
    console.log(user.name);
    console.log(user.age);
};
for (var key in user) {
    console.log(key + " : " + user[key]);
}
----

== Объекты в функциях

*Функции* могут возвращать *значения*. Но эти значения необязательно должны представлять примитивные данные - *числа*, *строки*, но также могут быть *сложными объектами*.

Например, вынесем создание объекта `user` в отдельную функцию:

[source,js]
----
function createUser(pName, pAge) {
    return {
        name: pName,
        age: pAge,
        displayInfo: function() {
            document.write("Имя: " + this.name + " возраст: " + this.age + "<br/>");
        }
    };
};
var tom = createUser("Tom", 26);
tom.displayInfo();
var alice = createUser("Alice", 24);
alice.displayInfo();
----

Здесь функция `createUser()` получает значения `pName` и `pAge` и по ним *создает новый объект*, который является возвращаемым результатом.

*Преимуществом вынесения создания объекта в функцию* является то, что далее мы можем создать несколько однотипных объектов с разными значениями.

Кроме того объект может передаваться в качестве параметра в функцию:

[source,js]
----
function createUser(pName, pAge) {
    return {
        name: pName,
        age: pAge,
        displayInfo: function() {
            document.write("Имя: " + this.name + " возраст: " + this.age + "<br/>");
        },
        driveCar: function(car) {
            document.write(this.name + " ведет машину " + car.name + "<br/>");
        }
    };
};

function createCar(mName, mYear) {
    return {
        name: mName,
        year: mYear
    };
};
var tom = createUser("Том", 26);
tom.displayInfo();
var bently = createCar("Бентли", 2004);
tom.driveCar(bently);
----

== Конструкторы объектов

Кроме создания новых объектов *JavaScript* предоставляет возможность *создавать новые типы объектов* с помощью конструкторов. Так, одним из способов *создания объекта* является применение конструктора типа `Object`:

[source,js]
----
var tom = new Object();
----

После создания переменной `tom` она будет вести себя как объект типа `Object`.

*Конструктор* позволяет определить новый тип объекта. Можно еще провести следующую аналогию.

Определение типа может состоять из *функции конструктора*, *методов* и *свойств*.

[source,js]
----
function User(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.displayInfo = function(){
        document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
    };
}
----

*Конструктор* - это обычная функция за тем исключением, что в ней мы можем установить *свойства* и *методы*. Для установки свойств и методов используется ключевое слово `this`:

Чтобы вызвать *конструктор*, то есть создать объект типа `User`, надо использовать ключевое слово `new`:

[source,js]
----
var tom = new User("Том", 26);
console.log(tom.name); // Том
tom.displayInfo();
----

=== Оператор `instanceof`

*Оператор `instanceof`* позволяет проверить, с помощью какого конструктора создан объект. Если объект создан с помощью определенного конструктора, то оператор возвращает `true`:

[source,js]
----
var tom = new User("Том", 26);
var isUser = tom instanceof User;
var isCar = tom instanceof Car;
console.log(isUser); // true
console.log(isCar); // false
----

== Расширение объектов. `Prototype`

Кроме непосредственного определения свойств и методов в конструкторе мы также можем использовать *свойство `prototype`*. Каждая функция имеет свойство `prototype`, представляющее *прототип функции*. То есть свойство `User.prototype` представляет *прототип объектов* `User`. И любые *свойства и методы*, которые будут определены в `User.prototype`, будут *общими* для всех объектов `User`.

Например, после определения объекта `User` необходимо добавить к нему метод и свойство:

[source,js]
----
function User(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.displayInfo = function() {
        document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
    };
};

User.prototype.hello = function() {
    document.write(this.name + " говорит: 'Привет!'<br/>");
};
User.prototype.maxAge = 110;

var tom = new User("Том", 26);
tom.hello();
var john = new User("Джон", 28);
john.hello();
console.log(tom.maxAge); // 110
console.log(john.maxAge); // 110
----

В то же время можно определить в объекте *свойство*, которое будет назваться так же, как и *свойство прототипа*. В этом случае собственное *свойство объекта* будет иметь приоритет перед *свойством прототипа*.

== Инкапсуляция

*Инкапсуляция* является одним из ключевых понятий объектно-ориентированного программирования и представляет *сокрытие состояния объекта от прямого доступа извне*. По умолчанию все свойства объектов являются *публичными*, общедоступными, и мы к ним можем обратиться из любого места программы.

Но есть возможность их скрыть от доступа извне, сделав свойства *локальными переменными*:

[source,js]
----
function User (name) {
    this.name = name;
    var _age = 1;
    this.displayInfo = function() {
        console.log("Имя: " + this.name + "; возраст: " + _age);
    };
    this.getAge = function() {
        return _age;
    }
    this.setAge = function(age) {
        if (typeof age === "number" && age > 0 && age < 110) {
            _age = age;
        } else {
            console.log("Недопустимое значение");
        }
    }
}

var tom = new User("Том");
console.log(tom._age); // undefined - _age - локальная переменная
console.log(tom.getAge()); // 1
tom.setAge(32);
console.log(tom.getAge()); // 32
tom.setAge("54"); // Недопустимое значение
tom.setAge(123); // Недопустимое значение
----

В конструкторе `User` объявляется *локальная переменная* `_age` вместо *свойства* `age`. Как правило, названия локальных переменных в конструкторах начинаются со знака *подчеркивания*.

Для того, что бы работать с возрастом пользователя извне, определяются два метода. Метод `getAge()` предназначен *для получения значения переменной* `_age`. Этот метод еще называется *геттер* (*getter)*. Второй метод - `setAge`, который еще называется *сеттер* (*setter*), предназначен для установки значения переменной `_age`.

== Функция как объект. Методы `call()` и `apply()`

В *JavaScript* функция тоже является *объектом* - *объектом Function* и тоже имеет *прототип*, *свойства*, *методы*. *Все функции*, которые используются в программе, являются *объектами Function* и имеют все его *свойства и методы*.

Например, мы можем создать функцию с помощью конструктора `Function`:

[source,js]
----
var square = new Function('n', 'return n * n;');
console.log(square(5));
----

В конструктор `Function` может передаваться ряд параметров. Последний параметр представляет собой само *тело функции в виде строки*. Фактически строка содержит JavaScript код. Предыдущие аргументы содержат *названия параметров*.

Среди свойств объекта `Function` можно выделить следующие:

* `arguments`: массив аргументов, передаваемых в функцию
* `length`: определяет количество аргументов, которые ожидает функция
* `caller`: определяет функцию, вызвавшую текущую выполняющуюся функцию
* `name`: имя функции
* `prototype`: прототип функции

С помощью *прототипа* можно определить дополнительные свойства:

[source,js]
----
function display() {
    console.log("привет мир");
}
Function.prototype.program ="Hello";

console.log(display.program); // Hello
----

Среди методов надо отметить методы `call()` и `apply()`.

Метод `call()` вызывает функцию с указанным значением `this` и аргументами:

[source,js]
----
function add(x, y) {
    return x + y;
}
var result = add.call(this, 3, 8);

console.log(result); // 11
----

`this` указывает на *объект*, для которого вызывается функция - в данном случае это *глобальный объект* `window`. После `this` передаются *значения для параметров*.

При передаче объекта через первый параметр, мы можем ссылаться на него через ключевое слово `this`:

[source,js]
----
function User (name, age) {
    this.name = name;
    this.age = age;
}
var tom = new User("Том", 26);
function display(){
    console.log("Ваше имя: " + this.name);
}
display.call(tom); // Ваше имя: Том
----

Если нам не важен объект, для которого вызывается функция, то можно передать значение `null`.

На метод `call()` похож метод `apply()`, который так же *вызывает функцию*. В качестве первого параметра также получает *объект*, для которого функция вызывается. Только теперь в качестве второго параметра передается *массив аргументов*:

[source,js]
----
function add(x, y) {
    return x + y;
}
var result = add.apply(null, [3, 8]);

console.log(result); // 11
----

== Наследование

*JavaScript* поддерживает *наследование*, что позволяет при создании новых типов объектов при необходимости *унаследовать функционал от уже существующих*. Например, у нас может быть объект `User`, представляющий отдельного пользователя. И также может быть объект `Employee`, который представляет работника. Но работник также может являться пользователем и поэтому должен иметь все его свойства и методы.

[source,js]
----
// конструктор пользователя
function User (name, age) {
    this.name = name;
    this.age = age;
    this.go = function() {
        document.write(this.name + " идет <br/>");
    }
    this.displayInfo = function() {
        document.write("Имя: " + this.name + "; возраст: " + this.age + "<br/>");
    };
}
User.prototype.maxage = 110;

// конструктор работника
function Employee(name, age, comp) {
    User.call(this, name, age);
    this.company = comp;
    this.displayInfo = function() {
        document.write("Имя: " + this.name + "; возраст: " + this.age + "; компания: " + this.company + "<br/>");
    };
}
Employee.prototype = Object.create(User.prototype);

var tom = new User("Том", 26);
var bill = new Employee("Билл", 32, "Google");
tom.go();
bill.go();
tom.displayInfo();
bill.displayInfo();
console.log(bill.maxage);
----

В конструкторе `Employee` происходит обращение к конструктору `User` с помощью вызова:

[source,js]
----
User.call(this, name, age);
----

Передача первого параметра `this` позволяет вызвать функцию *конструктора* `User` для *объекта*, создаваемого *конструктором* `Employee`. Благодаря этому *все свойства и методы*, определенные в *конструкторе* `User`, также переходят на *объект* `Employee`.

Кроме того, необходимо унаследовать также и *прототип* `User`. Для этого служит вызов:

[source,js]
----
Employee.prototype = Object.create(User.prototype);
----

Метод `Object.create()` позволяет создать *объект прототипа* `User`, который затем присваивается *прототипу* `Employee`. При этом при необходимости в прототипе `Employee` мы также можем определить дополнительные свойства и методы.

При наследовании мы можем *переопределять наследуемый функционал*.

== Ключевое слово `this`

*Поведение* ключевого слова `this` зависит *от контекста*, в котором оно используется, и от того, в каком режиме оно используется - *строгом* или *нестрогом*.

=== Глобальный контекст

В глобальном контексте `this` ссылается на *глобальный объект*. В данном случае *поведение не зависит от режима* (строгий или нестрогий):

[source,js]
----
this.alert("global alert");
this.console.log("global console");

var currentDocument = this.document;
----

=== Контекст функции

*В пределах функции* `this` ссылается на *внешний контекст*. Для функций, определенных *в глобальном контексте*, - это объект `Window`, который представляет окно браузера.

[source,js]
----
function foo() {
    var bar = "bar2";
    console.log(this.bar);
}

var bar = "bar1";

foo();  // bar1
----

Если не использовать `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

[source,js]
----
function foo() {
    var bar = "bar2";
    console.log(bar);
}

var bar = "bar1";

foo(); // bar2
----

Но если использовать *строгий режим* (*strict mode*), то `this` в этом случае имело бы значение `undefined`:

[source,js]
----
"use strict";
var obj = {
    function foo() {
        var bar = "bar2";
        console.log(this.bar);
    }
}

var bar = "bar1";

foo(); // ошибка - this - undefined
----

=== Контекст объекта

*В контексте объекта*, в том числе *в его методах*, ключевое слово `this` ссылается на `этот же объект`:

[source,js]
----
var o = {
    bar: "bar3",
    foo: function() {
        console.log(this.bar);
    }
}
var bar = "bar1";
o.foo();
----

----
bar3
----

=== Явная привязка

С помощью методов *call()* и *apply()* можно задать явную привязку функции к *определенному контексту*:

[source,js]
----
function foo() {
    console.log(this.bar);
}

var o3 = {bar: "bar3"}
var bar = "bar1";
foo(); // bar1
foo.apply(o3); // bar3
// или
// foo.call(o3);
----

=== Метод `bind`

Метод `f.bind(o)` позволяет создать *новую функцию* с тем же телом и областью видимости, что и функция f, но *с привязкой к объекту o*:

[source,js]
----
function foo() {
    console.log(this.bar);
}

var o3 = {bar: "bar3"}
var bar = "bar1";
foo();
var func = foo.bind(o3);
func();
----

----
bar1
bar3
----

=== `this` и стрелочные функции

При работе с несколькими контекстами необходимо учитывать, в каком контексте определяется переменная.

[source,js]
----
var school = {
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses: function() {
        this.courses.forEach(function(course) {
            console.log(this.title, course);
        })
    }
}
school.printCourses();
----

----
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
----

Видно, что значение `this.title` не определено, так как `this` как контекст объекта *замещается глобальным контекстом*. В этом случае нам надо передать подобное значение `this.title` или *весь контекст объекта*.

[source,js]
----
var school = {
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses: function() {
        var that = this;
        this.courses.forEach(function(course) {
            console.log(that.title, course);
        })
    }
}
school.printCourses();
----

*Стрелочные функции* также позволяют решить данную проблему:

[source,js]
----
var school = {
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses: function() {
        this.courses.forEach((course) => console.log(this.title, course))
    }
}
school.printCourses();
----

*Контекстом для стрелочной функции* в данном случае будет выступать *контекст объекта school*. Соответственно, не надо определять дополнительные переменные для передачи данных в функцию.

== Декомпозиция

*Декомпозиция* (*destructuring*) позволяет извлечь из объекта *отдельные значения в переменные*:

[source,js]
----
let user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
let {name, email} = user;
console.log(name);
console.log(email);
----

----
Tom
tom@gmail.com
----

Для *декомпозиции объекта* *переменные* помещаются _в фигурные скобки_ и им присваивается *объект*. *Сопоставление* между свойствами объекта и переменными идет *по имени*.

Так же можно указать, что необходимо получить значения свойств объекта в переменные с другим именем:

[source,js]
----
let user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
let {name: userName, email: mailAddress} = user;
console.log(userName);
console.log(mailAddress);
----

----
Tom
tom@gmail.com
----

=== Декомпозиция массивов

Также можно *декомпозировать массивы*:

[source,js]
----
let users = ["Tom", "Sam", "Bob"];
let [a, b, c] = users;

console.log(a);
console.log(b);
console.log(c);
----

----
Tom
Sam
Bob
----

Для *декомпозиции массива* переменные помещаются _в квадратные скобки_ и _последовательно_ получают значения элементов массива.

При этом можно пропустить ряд элементов массива, оставив вместо имен переменных пропуски:

[source,js]
----
let users = ["Tom", "Sam", "Bob", "Ann", "Alice", "Kate"];
let [first,,,,fifth] = users;

console.log(first);
console.log(fifth);
----

----
Tom
Alice
----

=== Декомпозиция параметров

Если в *функцию* в качестве параметра передается *массив* или *объект*, то его также можно подобным образом *декомпозировать*:

[source,js]
----
function display({name:userName, age:userAge}) {
    console.log(userName, userAge);
}
function sum([a, b, c]) {
    var result = a + b + c;
    console.log(result);
}
let user = {name:"Alice", age:33, email: "alice@gmail.com"};

let numbers = [3, 5, 7, 8];

display(user);
sum(numbers);
----

----
Alice 33
15
----

== Классы

С внедрением стандарта *ES2015* (*ES6*) в *JavaScript* появился *новый способ определения объектов - с помощью классов*. Класс представляет описание объекта, его состояния и поведения, а объект является конкретным воплощением или экземпляром класса.

Для *определения класса* используется ключевое слово `class`:

[source,js]
----
class Person {
}
----

Также можно определить *анонимный класс* и присвоить его переменной:

[source,js]
----
let Person = class {}
----

После этого можно создать объекты класса с помощью конструктора:

[source,js]
----
class Person {}

let tom = new Person();
let bob = new Person();
----

*Для создания объекта* с помощью конструктора сначала ставится *ключевое слово* `new`. Затем собственно идет *вызов конструктора* - по сути вызов функции по имени класса. По умолчанию классы имеют *один конструктор без параметров*. Поэтому в данном случае при вызове конструктора в него не передается никаких аргументов.

Также можно определить в классе свои конструкторы. Также класс может содержать свойства и методы:

[source,js]
----
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    display() {
        console.log(this.name, this.age);
    }
}

let tom = new Person("Tom", 34);
tom.display();
console.log(tom.name);
----

----
Tom 34
Tom
----

*Конструктор* определяется с помощью метода с именем `constructor`. По сути это обычный метод, который может принимать параметры. *Основная цель конструктора* - *инициализировать объект начальными данными*. И в данном случае в конструктор передаются два значения - для имени и возраста пользователя.

Для хранения состояния в классе *определяются свойства*. Для их определения используется ключевое слово `this`. В данном случае в классе два свойства: `name` и `age`.

Поведение *класса* определяют *методы*. В данном случае определен метод `display()`, который выводит значения свойств на консоль.

=== Наследование

Одни классы могут наследоваться от других. Наследование позволяет сократить объем кода в классах-наследниках:

[source,js]
----
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    display() {
        console.log(this.name, this.age);
    }
}

class Employee extends Person {
    constructor(name, age, company) {
        super(name, age);
        this.company = company;
    }

    display() {
        super.display();
        console.log("Employee in", this.company);
    }

    work() {
        console.log(this.name, "is hard working");
    }
}

let tom = new Person("Tom", 34);
let bob = new Employee("Bob", 36, "Google");
tom.display();
bob.display();
bob.work();
----

Для *наследования* одного класса от другого в определении класса применяется *оператор `extends`*, после которого идет название *базового класса*. То есть в данном случае класс `Employee` наследуется от класса `Person`. Класс `Person` еще называется *базовым классом*, *классом-родителем*, *суперклассом*, а класс `Employee` - *классом-наследником*, *подклассом*, *производным классом*.

*Производный класс*, как и *базовый*, может определять *конструкторы*, *свойства*, *методы*. Вместе с тем с помощью слова `super` *производный класс* может ссылаться на функционал, определенный *в базовом*.

=== Статические методы

*Статические методы* вызываются для *всего класса* в целом, а не для отдельного объекта. Для их определения применяется оператор `static`.

[source,js]
----
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static nameToUpper(person) {
        return person.name.toUpperCase();
    }

    display() {
        console.log(this.name, this.age);
    }
}
let tom = new Person("Tom Soyer", 34);
let personName = Person.nameToUpper(tom);
console.log(personName);
----

----
TOM SOYER
----
