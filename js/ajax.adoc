= AJAX
:imagesdir: ../assets/img/js

Современные веб-приложение, как правило, разделяются на две части: клиент и сервер. Клиент представляет собой веб-страницу с кодом *JavaScript*. К серверным технологиям относятся *Java*, *PHP*, *Ruby*, *Node.js*, *ASP.NET* и т.д., которые получают запрос от клиента, обрабатывают и отправляют в ответ результат обработки.

*AJAX* представляет технологию для отправки запросов к серверу из клиентского кода *JavaScript* без перезагрузки страницы. Сам термин расшифровывается как *Asynchronous JavaScript And XML*. То есть изначально *AJAX* предполагал асинхронное взаимодействие клиента и сервера посредством данных в формате *XML*. Хотя сейчас *XML* во многом вытеснил формат *JSON*. В любом случае *AJAX* революционизировал веб-среду, позволив создавать динамичные отзывчивые веб-приложения.

Поскольку *AJAX*  предполагает взаимодействие клиента и сервера, то для работы с *AJAX*  и в частности этой главы необходим локальный веб-сервер. Это может быть любой веб-сервер: *nginx*, *Apache*, *IIS* и т.д.

== Объект `XMLHttpRequest`

Для создания приложений, использующих *AJAX*, применяются различные способы. Но самым распространенным способом является использование объекта `XMLHttpRequest`:

[source, javascript]
----
var request = new XMLHttpRequest();
----

После создания объекта `XMLHttpRequest` можно отправлять запросы к серверу. Но для начала надо вызвать метод `open()` для инициализации:

[source, javascript]
----
request.open("GET", "http://localhost/hello.txt", false);
----

Метод `open()` принимает три параметра: *тип запроса* (`GET`, `POST`, `HEAD`, `PUT`), адрес запроса и третий необязательный параметр — логическое значение `true` или `false`, указывающее, будет ли запрос осуществляться в асинхронном режиме. То есть в данном случае запрос будет иметь тип `GET`, он будет направляться по адресу `http://localhost/hello.txt` в синхронном режиме, так как стоит значение `false` (для асинхронного режима указывается значение `true`).

*Синхронный и асинхронный режим* отличаются тем, что запрос в синхронном режиме пока запрос не выполнится, остальной код *JavaScript* не может выполняться. По умолчанию, если третий параметр не используется, то запрос отправляется в асинхронном режиме, что позволяет параллельно с выполнением запроса выполнять также и другой код *JavaScript*. И в большинстве случаев, как правило, используется именно асинхронный режим.

Кроме того, метод `open()` может принимать еще два параметра: _логин_ и _пароль пользователя_, если для выполнения запроса нужна аутентификация.

[source, javascript]
----
request.open("GET", "http://localhost/home.php", true, "login", "password");
----

После инициализации запроса методом `open()` необходимо отправить запрос с помощью метода `send()`:

[source, javascript]
----
request.send();
----

=== Свойства `XMLHttpRequest`

Объект `XMLHttpRequest` имеет ряд свойств, которые позволяют проконтролировать выполнение запроса:

* `status`: содержит статусный код ответа `HTTP`, который пришел от сервера. С помощью статусного кода можно судить об успешности запроса или об ошибках, которые могли бы возникнуть при его выполнении. Например, `статусный код 200` указывает на то, что запрос прошел успешно. `Код 403` говорит о необходимости авторизации для выполнения запроса, а `код 404` сообщает, что ресурс не найден и так далее.
* `statusText`: возвращает текст статуса ответа, например, `"200 OK"`
* `responseType`: возвращает тип ответа. Есть следующие типы:
** ``
** `arraybuffer`
** `blob`
** `document`
** `json`
** `text`
* `response`: возвращает ответ сервера
* `responseText`: возвращает текст ответа сервера
* `responseXML`: возвращает `xml`, если ответ от сервера в формате `xml`

Например, выполним запрос к текстовому файлу, который находится на локальном веб-сервере. Для выполнения *AJAX*-запросов потребуется запущенный локальный веб-сервер, на котором будет лежать файл `hello.txt`, в котором будет содержаться одна строка: `Привет мир`.

Код веб-страницы (пусть она называется `test.html`) будет следующим:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
</head>
<body>
    <script>
        var request = new XMLHttpRequest();
        request.open("GET", "http://localhost:8080/hello.txt", false);
        request.send();
        var status = request.status;
        if (status == 200) {
            document.write("Текст ответа: " + request.responseText)
        } else if (status == 404) {
            document.write("Ресурс не найден")
        } else {
            document.write(request.statusText)
    </script>
</body>
</html>
----

И после загрузки страницы выполнится ajax-запрос к ресурсу `http://localhost:8080/hello.txt`. Но важно отметить, что получение статуса сразу после вызова метода `request.send()` будет работать только для синхронного запроса.

image::xmlhttprequest.png[XMLHttpRequest в JavaScript, align=center]

=== Асинхронные запросы

Хотя синхронные запросы вполне работают и их можно использовать, но в то же время их рекомендуется избегать. Поскольку нередко запрос может занять продолжительное время, то это может заблокировать выполнение остального кода и работу с HTML-страницей до окончания выполнения запроса. Поэтому рекомендуется использовать преимущественно асинхронные запросы.

Работа с асинхронными запросами чуть более сложна, чем с синхронными, поскольку нам надо еще обработать событие `readystatechange` объекта `XMLHttpRequest`.

При асинхронном запросе объект `XMLHttpRequest` использует свойство `readyState` для хранения состояния запроса. Состояние запроса представляет собой число:

* `0`: объект `XMLHttpRequest` создан, но метод `open()` еще не был вызван для инициализации объекта
* `1`: метод `open()` был вызван, но запрос еще не был отправлен методом `send()`
* `2`: запрос был отправлен, заголовки и статус ответа получены и готовы к использованию
* `3`: ответ получен от сервера
* `4`: выполнение запроса завершено (даже если получен код ошибки, например, `404`)

Событие `readystatechange` возникает каждый раз, когда изменяется значение свойства `readyState`. Например, выполним асинхронный запрос:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <script>
        var request = new XMLHttpRequest();

        function reqReadyStateChange() {
            if (request.readyState == 4) {
                var status = request.status;
                if (status == 200) {
                    document.write(request.responseText);
                } else {
                    document.write("Ответ сервера " + request.statusText);
                }
            }
        }
        request.open("GET", "http://localhost:8080/hello.txt");
        request.onreadystatechange = reqReadyStateChange;
        request.send();
    </script>
</body>
</html>
----

Кроме обработки события `readystatechange` для получения ответа сервера можно также обрабатывать событие `load`, которое возникает после выполнения запроса. Его использование аналогично:

[source, javascript]
----
var request = new XMLHttpRequest();
function responceLoad() {
    if (request.readyState == 4) {
        var status = request.status;
        if (status == 200) {
            document.write(request.responseText);
        } else {
            document.write("Ответ сервера " + request.statusText);
        }
    }
}
request.open("GET", "http://localhost:8080/hello.txt");
request.onload = responceLoad;
request.send();
----

== Отправка данных

Принцип отправки данных может отличаться в различных ситуациях. Рассмотрим эти ситуации.

=== Отправка GET-запроса

*GET*-запрос характеризуется тем, что данные могут отправляться в строке запроса:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div id="output"></div>
    <script>
        // объект для отправки
        var user = {
            name: "Tom",
            age: 23
        };

        var request = new XMLHttpRequest();
        function reqReadyStateChange() {
            if (request.readyState == 4) {
                var status = request.status;
                if (status == 200) {
                    document.getElementById("output").innerHTML=request.responseText;
                }
            }
        }
        // строка с параметрами для отправки
        var body = "name=" + user.name + "&age="+user.age;
        request.open("GET", "http://localhost:8080/postdata.php?"+body);
        request.onreadystatechange = reqReadyStateChange;
        request.send();
    </script>
</body>
</html>
----

Для отправки берем свойства объекта `user` и формируем из их значений сроку с параметрами:

[source, javascript]
----
"name=" + user.name + "&age="+user.age
----

Затем эта строка добавляется к строке запроса в методе `open("GET", "http://localhost:8080/postdata.php?"+body)`

Предполагается, что данные отправляются скрипту на языке `php` `postdata.php`, который может иметь, например, следующее содержание:

[source, php]
----
<?php
$name = "Не известно";
$age = "Не известно";
if(isset($_GET['name'])) $name = $_GET['name'];
if (isset($_GET['age'])) $age = $_GET['age'];
echo "Ваше имя: $name  <br> Ваш возраст: $age";
?>
----

Конкретная технология стороны сервера тут не важна. И в качестве тестирования можно взять любую другую технологию. Например, `ASP.NET MVC`. Метод контроллера в `ASP.NET MVC`, который принимает данные, мог бы выглядеть следующим образом:

[source]
----
public string PostData(string name, int age)
{
    return "Ваше имя: "+name +"; Ваш возраст: "+ age;
}
----

=== Кодирование параметров

Все отправляемые в *GET*-запросе параметры разделяются знаком *амперсанда* (`&`). Но что, если какой-нибудь параметр имеет знак амперсанда. Например,

[source, javascript]
----
var user = {
    name: "Tom&Tim",
    age: 23
};
// строка с параметрами для отправки
var body = "name=" + user.name + "&age="+user.age;
----

В этом случае при получении параметров скрипт на стороне сервера может неправильно обработать данные и неправильно извлечь параметры. Поэтому, чтобы кодировать все передаваемые данные, нужно применять функцию `encodeURIComponent()`:

[source, javascript]
----
var body = "name=" + encodeURIComponent(user.name) + "&age="+encodeURIComponent(user.age);
----

При этом строка `Tom&Tim` будет кодирована в следующую строку: `Tom%26Tim`.

При необходимости мы можем выполнить обратное декодирование с помощью функции `decodeURIComponent()`:

[source, javascript]
----
var encodeName = encodeURIComponent(user.name); // Tom%26Tim
var decodeName = decodeURIComponent(encodeName); // Tom&Tim
----

=== POST-запросы

Отправка данных в *POST*-запросах будет немного отличаться:

[source, javascript]
----
var user = {
    name: "Tom",
    age: 23
};
var request = new XMLHttpRequest();
function reqReadyStateChange() {
    if (request.readyState == 4 && request.status == 200)
        document.getElementById("output").innerHTML=request.responseText;
}
var body = "name=" + user.name + "&age="+user.age;
request.open("POST", "http://localhost:8080/postdata.php");
request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
request.onreadystatechange = reqReadyStateChange;
request.send(body);
----

Для отправки данных методом `POST` надо установить заголовок `Content-Type` с помощью метода `setRequestHeader()`. В данном случае заголовок имеет значение `application/x-www-form-urlencoded`.

=== Отправка форм. `FormData`

Начиная со спецификации `XMLHttpRequest2` в *JavaScript* появился новый объект - `FormData`, который позволяет сериализовать данные формы для ее последующей отправки. При этом нам даже необязательно создавать форму в коде *HTML*, мы можем создать ее динамически в *JavaScript*:

[source, javascript]
----
var formData = new FormData();
formData.append('name', 'Tom');
formData.append('age', 23);
var request = new XMLHttpRequest();
function reqReadyStateChange() {
    if (request.readyState == 4 && request.status == 200)
        document.getElementById("output").innerHTML=request.responseText;
}
request.open("POST", "http://localhost:8080/display.php");
request.onreadystatechange = reqReadyStateChange;
request.send(formData);
----

Для добавления данных у объекта `FormData` используется метод `append('имя_параметра', значение)`. При этом никакие заголовки указывать не надо.

Также мы можем определить форму в *HTML* и использовать ее для отправки:

[source, html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
</head>
<body>
    <div id="output">
    </div>
    <form name="user" action="http://localhost:8080/postdata.php">
        <input type="text" name="username" placeholder="Введите имя" /><br/>
        <input type="text" name="age" placeholder="Введите возраст" /><br/>
        <input type="submit" name="submit" value="Отправить" />
    </form>
    <script>
        // получаем объект формы
        var form = document.forms.user;
        // прикрепляем обработчик кнопки
        form.submit.addEventListener("click", sendRequest);

        // обработчик нажатия
        function sendRequest(event) {
            event.preventDefault();
            var formData = new FormData(form);
            var request = new XMLHttpRequest();
            request.open("POST", form.action);
            request.onreadystatechange = function () {
                if (request.readyState == 4 && request.status == 200)
                    document.getElementById("output").innerHTML=request.responseText;
            }
            request.send(formData);
        }
    </script>
</body>
</html>
----

Для сериализации всех полей формы нам достаточно передать объект формы в конструктор `FormData: var formData = new FormData(form)`.

=== Отправка данных в формате json

Для отправки данных в формате `json` нам необходимо установить соответствующий заголовок и сериализовать данные с помощью метода `JSON.stringify()`:

[source, javascript]
----
// объект для отправки
var user = {
    username: "Tom",
    age: 23
};
var json = JSON.stringify(user);
var request = new XMLHttpRequest();
request.open("POST", "http://localhost:8080/postjson.php");
request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
request.onreadystatechange = function () {
    if (request.readyState == 4 && request.status == 200)
        document.getElementById("output").innerHTML=request.responseText;
}
request.send(json);
----

== `Promise` в AJAX-запросах

Как видно из примеров прошлых тем для создания *AJAX*-запросов используются фактически повторяющиеся вызовы, отличающиеся лишь деталями — строкой запроса, функциями обработки ответа. И вполне было бы неплохо создать для всех действий, связанных с асинхронным *AJAX*-запросом, создать какую-то общую абстракцию и затем использовать ее при следующих обращениях к серверу.

Для создания дополнительного уровня абстракции в данном случае удобно применять объект `Promise`, который обертывает асинхронную операцию в один объект, который позволяет определить действия, выполняющиеся при успешном или неудачном выполнении этой операции.

Инкапсулируем асинхронный запрос в объект `Promise`:

[source, javascript]
----
function get(url) {
    return new Promise(function(succeed, fail) {
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function() {
            if (request.status < 400)
                succeed(request.response);
            else
            fail(new Error("Request failed: " + request.statusText));
        });
        request.addEventListener("error", function() {
            fail(new Error("Network error"));
        });
        request.send();
    });
}
----

Метод `get` получает в качестве параметра адрес ресурса сервера и возвращает объект `Promise`. Конструктор `Promise` в качестве параметра принимает функцию обратного вызова, которая в свою очередь принимает два параметра — две функции: одна выполняется при успешной обработке запроса, а вторая — при неудачной.

Допустим, на сервере будет размещен файл `users.json` со следующим содержимым:

[source, json]
----
[
    {
        "name": "Tom",
        "age": 34
    },
    {
        "name": "Sam",
        "age": 32
    },
    {
        "name": "Bob",
        "age": 26
    }
]
----

Теперь вызовем метод `get()` для осуществления запроса к серверу:

[source, javascript]
----
get("http://localhost:8080/users.json").then(function(text) {
        console.log(text);
    }, function(error) {
        console.log("Error!!!");
        console.log(error);
    });
----

Для обработки результата объекта `Promise` вызывается метод `then()`, который принимает два параметра: функцию, вызываемую при успешном выполнении запроса, и функцию, которая вызывается при неудачном выполнении запроса. Метод `then()` также возвращает объект `Promise`. Поэтому при необходимости мы можем применить к его результату цепочки вызовов метода `then: get().then().then()...`. Например:

[source, javascript]
----
get("http://localhost:8080/users.json").then(function(response) {
    console.log(response);
    return JSON.parse(response);
}).then(function(data) {
    console.log(data[0]);
});
----

В данном случае функция в первом вызове метода `then` получает ответ сервера и возвращает разобранные данные в виде массива с помощью функции `JSON.parse()`.

Функция во втором вызове `then()` получает эти разобранные данные, то есть массив, в виде параметра (возвращаемое значение предыдущего `then` является параметром для последующего `then`). Затем первый элемент массива выводится на консоль.

Для обработки ошибок мы можем использовать метод `catch()`, в который передается функция обработки ошибок:

[source, javascript]
----
get("http://localhost:8080/users.jsn").then(function(response) {
    console.log(response);
    return JSON.parse(response);
}).then(function(data) {
    console.log(data[0]);
}).catch(function(error){
    console.log("Error!!!");
    console.log(error);
});
----

Подобным образом через `Promise` можно было бы отправлять данные на сервер:

[source, javascript]
----
function post(url, requestuestBody) {
    return new Promise(function(succeed, fail) {
        var request = new XMLHttpRequest();
        request.open("POST", url, true);
        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        request.addEventListener("load", function() {
            if (request.status < 400)
                succeed(request.responseText);
            else
                fail(new Error("Request failed: " + request.statusText));
        });
        request.addEventListener("error", function() {
            fail(new Error("Network error"));
        });
        request.send(requestuestBody);
    });
}

var user = {
    name: "Tom&Tim",
    age: 23
};
// данные для отправки
var params = "name=" + user.name + "&age="+user.age;

post("http://localhost:8080/postdata.php", params).then(function(text) {
        console.log(text);
    }, function(error) {
        console.log(error);
    });
----
