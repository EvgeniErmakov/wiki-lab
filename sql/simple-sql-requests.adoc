= Простые SQL-запросы

== Создание таблицы `CREATE TABLE`

Для того чтобы создать таблицу в *SQL*, используется выражение `CREATE TABLE`. Он принимает в качестве параметров все колонки, которые необходимо внести, а также их типы данных. Пример создания таблицы с названием `Months`, в которой будет три колонки:

* `id` - порядковый номер месяца (целочисленный тип или `int`).
* `name` - название месяца.
* `days` - число дней в конкретном месяце.

Код создания будет выглядеть следующим образом:

[source,sql]
----
CREATE TABLE months (id int, name varchar(10), days int);
----

== DROP TABLE
Оператор DROP TABLE используется для удаления существующей таблицы в базе данных.

=== Синтаксис
[source,sql]
----
DROP TABLE table_name;
----
== Удаление таблиц при помощи `TRUNCATE`

Если необходимо все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду `TRUNCATE`:

[source,sql]
----
TRUNCATE TABLE table_name;
----

В случае, если необходимо удалить саму таблицу, то следует использовать команду `DROP`:

[source,sql]
----
DROP TABLE table_name;
----




==  Оператор `CREATE DATABASE`
Оператор CREATE DATABASE используется для создания новой базы данных SQL.

=== Синтаксис
[source,sql]
----
CREATE DATABASE databasename;
----
=== Пример CREATE DATABASE
Следующий оператор SQL создает базу данных с именем «invoice»:
[source,sql]
----
CREATE DATABASE invoice;
----

== Оператор `DROP DATABASE`
Оператор `DROP DATABASE` используется для удаления существующей базы данных SQL.

=== Синтаксис
[source,sql]
----
DROP DATABASE databasename;
----

=== Пример `DROP DATABASE`
Следующий оператор SQL уничтожает существующую базу данных «info»:
[source,sql]
----
DROP DATABASE info;
----

== `INSERT INTO`

`INSERT INTO` - этот запрос используется для добавления двумя разными способами новых строк данных в таблицу в базе данных.

*Способ первый:*

[source,sql]
----
INSERT INTO months VALUES (1,'January',31);
----

Этот способ не подразумевает указания названий колонок, а лишь принимает значения в том порядке, в котором они указаны в таблице. Однако, если в будущем необходимо добавить дополнительные колонки, все предыдущие запросы работать не будут.

Для решения данной проблемы следует использовать *второй способ*. Его суть заключается в том, что перед вводом данных указываются названия колонок.

[source,sql]
----
INSERT INTO months (id,name,days) VALUES (2,'February',29);
----

== `SELECT`

`SELECT` - используется для выбора данных из базы данных. Возвращаемые данные сохраняются в таблице результатов, называемой результирующим набором.

[source,sql]
----
SELECT * FROM characters
----

Результатом данного запроса будет таблица со всеми данными в таблице characters. Знак звёздочки (`*`) означает то, что необходимо показать все столбцы из таблицы без исключений. Так как в базе данных обычно больше одной таблицы, нам необходимо указывать название таблицы, данные из которой требуется посмотреть. Сделать это можно используя ключевое слово FROM.

Когда необходимы лишь некоторые столбцы из таблицы, то можно указать их имена через запятую вместо звёздочки.

[source,sql]
----
SELECT name, weapon FROM characters
----

== `SELECT DISTINCT`

Оператор `SELECT DISTINCT` используется для возврата только отдельных (разных) значений. Внутри таблицы столбец часто содержит много повторяющихся значений и вам нужно только перечислить отличающиеся значения.

=== Синтаксис `SELECT DISTINCT`
[source,sql]
----
SELECT DISTINCT column1, column2, ...
FROM table_name;
----
=== Пример `SELECT DISTINCT`
Следующий оператор SQL выбирает только значения `DISTINCT` из столбца «name» в таблице «users»:
[source,sql]
----
SELECT DISTINCT name FROM users;
----

В следующем SQL-заявлении указано количество разных имен пользователей:
[source,sql]
----
SELECT COUNT(DISTINCT name) FROM users;
----

== `WHERE`

`WHERE` - это запрос позволяющий включить в вывод лишь некоторые конкретные строки. Данное ключевое слово позволяет фильтровать данные по определённому условию.

=== Синтаксис `WHERE`
[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition;
----

=== Пример предложения `WHERE`
Следующий оператор SQL выбирает всех пользователей с именем «name» в таблице «users»:

Пример:

[source,sql]
----
SELECT * FROM users
WHERE name ='Том';
----

Следует отметить, что *SQL* требует одинарных кавычек вокруг текстовых значений (большинство систем баз данных также допускают двойные кавычки). Однако числовые поля не должны быть заключены в кавычки.

=== Операторы в разделе `WHERE`
Следующие операторы могут использоваться в предложении `WHERE`:

|===
|Заголовок|Группа
| `=` |Равно
|`!=` или `<>`|Не равно
| `>`|Больше чем
|`<`|	Меньше чем
|`>=`|	Больше или равно
|`<=`|Меньше или равно
|`BETWEEN`|Между включенным диапазоном
|`LIKE`|Поиск по шаблону
|`IN`|Поиск данных по нескольким значениям, перечисленным через запятую
|===

== Операторы `AND`, `OR` и `NOT`

Предложение `WHERE` может быть объединено с операторами `AND`, `OR` и `NOT`. Операторы `AND` и `OR` используются для фильтрации записей на основе более чем одного условия:

Оператор `AND` отображает запись, если все условия, разделенные символом `AND`, имеют значение *TRUE*.

Оператор `OR` отображает запись, если любое из условий, разделенных `OR`, является *TRUE*.

Оператор `NOT` отображает запись, если условие (и) *НЕ ИСТИНА*.

=== Оператор  `AND`
*Синтаксис:*
[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition1 AND condition2 AND condition3 ...;
----

*Пример:*

Следующий оператор SQL выбирает все поля из «users», где пол «gender» равен 1 (женский), а  баланс «balance» больше или равен (>=) 1000.

[source,sql]
----
SELECT * FROM users
WHERE gender = 1 AND balance >= 1000;
----

=== Оператор `OR`
*Синтаксис:*
[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition1 OR condition2 OR condition3 ...;
[source,sql]
----

*Пример:*

Следующий оператор SQL выбирает все поля из «users», где баланс пользователя «balance» равен 1000 или возраст пользователя «age» равен 25.

[source,sql]
----
SELECT * FROM users
WHERE balance = 1000 OR age = 25;
----

=== Оператор `NOT`
*Синтаксис:*
[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE NOT condition;
----

*Пример:*

Следующий оператор SQL выбирает все поля из «users», где возраст «age» не равен 30:
[source,sql]
----
SELECT * FROM users
WHERE NOT age = 30
----

=== Объединение `AND`, `OR` и `NOT`
Также можно комбинировать операторы AND, OR и NOT.

Следующий оператор SQL выбирает все поля из «users», где возраст «age» равно 30. И баланс «balance» больше 1000 или имя «name» равно Том.

*Пример:*
[source,sql]
----
SELECT * FROM users
WHERE age = 30 AND (balance > 1000 OR name = 'Том');
----


== Ключевое слово `ORDER BY`
Ключевое слово ORDER BY используется для сортировки результирующего набора в порядке возрастания или убывания.По умолчанию оно сортирует записи по возрастанию. Чтобы отсортировать записи в порядке убывания, используйте ключевое слово `DESC`. Для сортировки по возрастанию, используйте ключевое слово `ASC`.

*Синтаксис:*
[source,sql]
----
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
----

*Пример:*
Следующий оператор *SQL* выбирает всех пользователей из таблицы «users», отсортированные по столбцу «name»:
[source,sql]
----
SELECT * FROM users
ORDER BY name;
----

== Значение `NULL`
Поле со значением NULL является полем без значения.Если поле в таблице является необязательным, можно вставить новую запись или обновить запись без добавления значения в это поле. Затем поле будет сохранено со значением NULL. Значение NULL отличается от нулевого значения или поля, содержащего пробелы.

=== Как проверить значения `NULL`?
Невозможно проверить значения `NULL` с операторами сравнения, такими как `=`, `<` или `<>`. Вместо этого нужно использовать операторы `IS NULL` и `NOT NULL`.

Синтаксис `IS NULL`:

[source,sql]
----
SELECT column_names
FROM table_name
WHERE column_name IS NULL;
----

Пример `IS NULL`:
Следующий оператор SQL использует оператор IS NULL для перечисления всех пользователей, у которых нет телефона.

[source,sql]
----
SELECT name, fullname, phone FROM users
WHERE phone IS NULL;
----

Синтаксис `NOT NULL`:

[source,sql]
----
SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;
----

Пример `IS NOT NULL`:
Следующий оператор SQL использует оператор IS NOT NULL для перечисления всех пользователей, у которых есть телефон.

[source,sql]
----
SELECT name, fullname, phone FROM users
WHERE phone IS NOT NULL;
----

== `IN/BETWEEN/LIKE`

Условия в `WHERE` могут быть записаны с использованием ещё нескольких команд, которыми являются:

* `IN` — сравнивает значение в столбце с несколькими возможными значениями и возвращает `true`, если значение совпадает хотя бы с одним значением
* `BETWEEN` — проверяет, находится ли значение в каком-то промежутке.
* `LIKE` — ищет по шаблону.

К примеру, можно сделать запрос для вывода данных об альбомах в жанре `pop` или `soul`:

[source,sql]
----
SELECT * FROM albums WHERE genre IN ('pop','soul');
----

Если необходимо вывести все альбомы, которые были выпущены в промежутке между `1975` и `1985` годом, можно использовать следующую запись:

[source,sql]
----
SELECT * FROM albums WHERE released BETWEEN 1975 AND 1985;
----

Также, если необходимо вывести все альбомы, в названии которых есть буква `R`, можно использовать следующую запись:

[source,sql]
----
SELECT * FROM albums WHERE album LIKE '%R%';
----

Знак `%` означает любую последовательность символов (0 символов тоже считается за последовательность). Если необходимо вывести все альбомы, первая буква в названии которых — `R`, то запись слегка изменится:

[source,sql]
----
SELECT * FROM albums WHERE album LIKE 'R%';
----

В *SQL* также есть инверсия. Для этого достаточно написать `NOT` перед любым логическим выражением в условии (`NOT BETWEEN` и так далее).

== `UPDATE`

Зачастую необходимо изменить данные в таблице. В *SQL* это делается с помощью `UPDATE`.

Использование `UPDATE` включает в себя выбор таблицы, в которой находится поле подлежащее изменению. Запись нового значения осуществляется с помощью запроса `WHERE`, чтобы обозначить конкретное место в таблице.

*Синтаксис:*
[source,sql]
----
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition
----

*Пример:*
Предположим есть таблица с самыми высоко оценёнными сериалами всех времён. Однако в ней есть несоответствие: `Игра Престолов` обозначена как комедия, изменим значение поля следующим запросом:

[source,sql]
----
UPDATE tv_series
SET genre = 'drama'
WHERE name = 'Game of Thrones';
----

== Удаление записей из таблицы. `DELETE`.

Удаление записи из таблицы через *SQL* - очень простая операция. Всё, что нужно - это обозначить, что необходимо удалить.

[source,sql]
----
DELETE FROM tv_series
WHERE id = 4;
----

Примечание: необходимо убедиться что используется запрос `WHERE`, когда происходит удаление записи из таблицы. Иначе удалятся все записи.

=== Удалить все записи
Можно удалить все строки таблицы без удаления таблицы. Это означает, что структура таблицы, атрибуты и индексы будут неповрежденными:

[source,sql]
----
DELETE FROM table_name;
----
или:
[source,sql]
----
DELETE * FROM table_name;
----



== Предложение `SELECT TOP`

Предложение `SELECT TOP` используется для указания количества возвращаемых записей. Оно полезно для больших таблиц с тысячами записей. Возвращение большого количества записей может повлиять на производительность.

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
----

=== Примеры SQL `TOP`, `LIMIT` и `ROWNUM`
Следующий оператор SQL выбирает первые три записи из таблицы «users»:
*Пример:*

[source,sql]
----
SELECT TOP 3 * FROM users;
----

Следующий оператор SQL показывает эквивалентный пример, используя предложение LIMIT:
Пример:
[source,sql]
----
SELECT * FROM users
LIMIT 3;
----
Следующий оператор SQL показывает эквивалентный пример с использованием ROWNUM:

Пример:
[source,sql]
----
SELECT * FROM users
WHERE ROWNUM <= 3;
----

=== Пример SQL TOP PERCENT
Следующий оператор SQL выбирает первые 25% записей из таблицы «users»:
*Пример:*
[source,sql]
----
SELECT TOP 25 PERCENT * FROM users;
----
Следующий оператор SQL выбирает первые 5 записи из таблицы «users», где баланс «balance» равен 1000:

*Пример:*
[source,sql]
----
SELECT TOP 5 * FROM users
WHERE balance = 1000;
----

Следующий оператор SQL показывает эквивалентный пример, используя предложение LIMIT:
[source,sql]
----
SELECT * FROM users
WHERE balance = 1000
LIMIT 5;
----

Следующий оператор SQL показывает эквивалентный пример с использованием ROWNUM:
*Пример:*
[source,sql]
----
SELECT * FROM users
WHERE balance = 1000 AND ROWNUM <= 5;
----

== Функции `MIN()` и `MAX()`
Функция MIN() возвращает наименьшее значение выбранного столбца. Функция MAX() возвращает наибольшее значение выбранного столбца.

*Синтаксис `MIN()`:*

[source,sql]
----
SELECT MIN(column_name)
FROM table_name
WHERE condition;
----

*Пример `MIN()`:*

[source,sql]
----
SELECT MIN(price) AS min_price
FROM product;
----

*Синтаксис `MAX()`:*

[source,sql]
----
SELECT MAX(column_name)
FROM table_name
WHERE condition;
----

*Пример `MAX()`:*

Следующий оператор SQL находит цену самого дорогого товара:

[source,sql]
----
SELECT MAX(price) AS max_price
FROM product;
----

== Функция `COUNT()`
Функция `COUNT()` возвращает количество строк, соответствующих заданным критериям.

*Синтаксис:*
[source,sql]
----
SELECT COUNT(column_name)
FROM table_name
WHERE condition;
----

*Пример:*

Следующий оператор SQL находит количество товаров.
[source,sql]
----
SELECT COUNT(product_id)
FROM product;
----

== Функция `AVG()`
Функция AVG() возвращает среднее значение числового столбца.

*Синтаксис:*
[source,sql]
----
SELECT AVG(column_name)
FROM table_name
WHERE condition;
----

*Пример:*
Следующий оператор SQL находит среднюю цену всех товаров.
[source,sql]
----
SELECT AVG(price)
FROM product;
----

== Функция `SUM()`
Функция `SUM()` возвращает общую сумму числового столбца.

*Синтаксис:*
[source,sql]
----
SELECT SUM(column_name)
FROM table_name
WHERE condition;
----

*Пример:*
Следующий оператор SQL находит сумму полей доставка «delivery» в таблице «invoice».
[source,sql]
----
SELECT SUM(delivery)
FROM invoice;
----

== Оператор `LIKE`

Оператор `LIKE` используется в предложении `WHERE` для поиска заданного шаблона в столбце.

В сочетании с оператором `LIKE` используются два подстановочных знака:

* `%` - Знак процента представляет нулевой, один или несколько символов
* `_` - Подчеркнутый символ представляет собой один символ

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
----

|===
|Выражение|	Описание
|`WHERE name LIKE 'text%'`  |Находит любые значения, начинающиеся с "text"
|`WHERE name LIKE '%text'`  |Находит любые значения, заканчивающиеся на "text"
|`WHERE name LIKE '%text%'`  |Находит любые значения, которые имеют «text» в любой позиции
|`WHERE name LIKE '_text%'`  |	Находит любые значения, которые имеют «text» во второй позиции
|`WHERE name LIKE 'text_%_%'`  |	Находит любые значения, начинающиеся с «text» и длиной не менее 3 символов
|`WHERE name LIKE 'text%data'`  |Находит любые значения, начинающиеся с «text» и заканчивающиеся на «data»
|===

== Подстановочные знаки
Символ подстановки используется для замены любого другого символа в строке. Подстановочные символы используются с оператором SQL `LIKE`. Оператор `LIKE` используется в предложении `WHERE` для поиска заданного шаблона в столбце.

=== Использование подстановочного знака

Следующий оператор SQL выбирает всех пользователей с name, начиная с любого символа, за которым следует «о»:

*Пример:*

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '_о';
----
Следующий оператор SQL выбирает всех пользователе с name начиная с «Т», за которым следует любой символ, за которым следует «м», за которым следует любой символ, а затем «с»:


*Пример:*

[source,sql]
----
SELECT * FROM users
WHERE name LIKE 'Т_м_с';
----
Использование подстановочного знака [charlist]
Следующий оператор SQL выбирает всех пользователей с name, начиная с «Т», «Р» или «Е»:


*Пример:*

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[ТРЕ]%';
----
Следующий оператор SQL выбирает всех пользователей с name, начиная с «Т», «Р» или «Е»:

*Пример:*

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[Т-E]%'
----
Использование подстановочного знака [! Charlist]
Два следующих оператора SQL выбирают всех пользователей с помощью name NOT, начинающегося с «Т», «Р» или «E»:

*Пример:*
[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[!ТРЕ]%';
----
Или:

[source,sql]
----
SELECT * FROM users
WHERE name NOT LIKE '[ТРЕ]%';
----

== Оператор `IN`

Оператор `IN` позволяет указать несколько значений в предложении `WHERE`. Он является сокращением для нескольких условий `OR`.

*Синтаксис `IN`*
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
----
или:

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
----

Пример.

Следующий оператор SQL выбирает всех пользователей, которые находятся в странах «Испания», «Франция» и «Бразилия»:

[source,sql]
----
SELECT * FROM users
WHERE country IN ('Испания', 'Франция', 'Бразилия');
----

Следующий оператор SQL выбирает всех пользователей, которые НЕ расположены в «Испания», «Франция» и «Бразилия»:

[source,sql]
----
SELECT * FROM users
WHERE country NOT IN ('Испания', 'Франция', 'Бразилия');
----

== Оператор `BETWEEN` и `NOT BETWEEN`

Оператор `BETWEEN` выбирает значения в заданном диапазоне. Значения могут быть числами, текстом или датами.

Синтаксис:
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
----

Пример:
Следующий оператор SQL выбирает все продукты с ценой BETWEEN 5 и 200.

[source,sql]
----
SELECT * FROM product
WHERE price BETWEEN 5 AND 200;
----

Чтобы отобразить товары вне диапазона предыдущего примера, используйте `NOT BETWEEN`:

[source,sql]
----
SELECT * FROM product
WHERE price NOT BETWEEN 5 AND 200;
----

=== Пример `BETWEEN` с `IN`
Следующий оператор SQL выбирает все товары с ценой `BETWEEN` 5 и 200 и не показывать товары с категориями 1, 2, 3, 4, 5.

[source,sql]
----
SELECT * FROM product
WHERE (price BETWEEN 5 AND 200)
AND NOT category_id IN (1, 2, 3, 4, 5);
----

BETWEEN текстовых значений
Следующий оператор SQL выбирает все товары с name BETWEEN 'Красный телефон' и 'Серебристая клавиатура':

[source,sql]
----
SELECT * FROM product
WHERE name BETWEEN 'Красный телефон' AND 'Серебристая клавиатура'
ORDER BY name;
----

=== `NOT BETWEEN` текстовых значений

Следующий оператор SQL выбирает все продукты с name NOT BETWEEN 'Красный телефон' и 'Серебристая клавиатура':

[source,sql]
----
SELECT * FROM product
WHERE name NOT BETWEEN 'Красный телефон' AND 'Серебристая клавиатура'
ORDER BY name;
----

=== Пример `BETWEEN` с датами
Следующий оператор SQL выбирает все счета с помощью date BETWEEN.

[source,sql]
----
SELECT * FROM invoice
WHERE date BETWEEN #21.10.2017# AND #22.10.2017#;
----

== Псевдонимы `Aliases`

SQL-псевдонимы используются для предоставления таблицы или столбца таблицы временного имени.

Псевдонимы часто используются, чтобы сделать имена столбцов более читабельными. Псевдоним существует только для продолжительности запроса.

Псевдонимы могут быть полезны, когда:

* В запросе содержится более одной таблицы
* Функции используются в запросе
* Названия столбцов большие или не очень читаемые
* Два или более столбца объединяются вместе

*Синтаксис.*
[source,sql]
----
SELECT column_name AS alias_name
FROM table_name;
Синтаксис таблицы псевдонимов
SELECT column_name(s)
FROM table_name AS alias_name;
----

=== Псевдоним для столбцов

Следующий оператор SQL создает два псевдонима: один для столбца user_id и один для столбца name:

*Пример:*

[source,sql]
----
SELECT user_id as ID, name AS user
FROM users;
----

Следующий оператор SQL создает два псевдонима: один для столбца name и один для столбца address.

*Пример:*
[source,sql]
----
SELECT name AS user, address AS [Address User]
FROM users;
----

=== Псевдонимы для таблиц

Следующий оператор SQL выбирает все счета от пользователя с помощью user_id и name. В запросе используются таблицы «users» и «invoice», которым даются псевдонимы таблиц «u» и «o».

*Пример:*

[source,sql]
----
SELECT i.invoice_id, i.date, i.name
FROM users AS u, invoice AS i
WHERE u.name = "Том" AND u.user_id = i.user_id;
----

== Предложение `JOIN`

Предложение `JOIN` используется для объединения строк из двух или более таблиц на основе соответствующего столбца между ними.

Существует несколько типов `JOIN` в *SQL*:

* (INNER) JOIN - возвращает записи, имеющие соответствующие значения в обеих таблицах
* LEFT (OUTER) JOIN - возвращает все записи из левой таблицы и соответствующие записи из правой таблицы
* RIGHT (OUTER) JOIN - вернуть все записи из правой таблицы и сопоставленные записи из левой таблицы
* FULL (OUTER) JOIN - возвращает все записи, когда есть совпадение в левой или правой таблице

=== `INNER JOIN`

Ключевое слово `INNER JOIN` выбирает записи, имеющие соответствующие значения в обеих таблицах

*Синтаксиc:*
[source,sql]
----
SELECT column_name(s)
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример:*

.Таблица users
|===
|user_id|name|fullname
|1|Ник|Никольский
|2|Майк|Майкович
|===

.Таблица invoice
|===
|invoice_id|user_id|product_id
|1|1|7
|2|2|12
|===
Столбец «user_id» в таблице «invoice» ссылается на «user_id» в таблице  «invoice» между которыми осуществляется взаимосвязь. Для выбора записей, имеющие соответствующие значения в обеих таблицах используется следующий запрос:

[source,sql]
----
SELECT invoice.invoice_id, users.name
FROM Orders
INNER JOIN users ON invoice.user_id = users.user_id;
----

==== `JOIN Three` таблиц

Следующий оператор SQL выбирает все счета с информацией о пользователях и отправителях:

*Пример:*

[source,sql]
----
SELECT invoice.invoice, users.name, addresser.name
FROM ((invoice
INNER JOIN users ON invoice.user_id = users.user_id)
INNER JOIN addresser ON invoice.addresser_id = addresser.addresser_id);
----

== Ключевое слово LEFT JOIN

Ключевое слово `LEFT JOIN` возвращает все записи из левой таблицы (table1) и сопоставленные записи из правой таблицы (table2). Результат равен NULL с правой стороны, если нет совпадения.

*Синтаксис:*
[source,sql]
----
SELECT column_name(s)
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример:*

Следующий оператор SQL выберет всех пользователей и любые заказы, которые они могут иметь:
[source,sql]
----
SELECT users.name, invoice.invoice_id
FROM users
LEFT JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;
----

== Ключевое слово RIGHT JOIN

Ключевое слово RIGHT JOIN возвращает все записи из правой таблицы (table2) и сопоставленные записи из левой таблицы (table1). Результат равен NULL с левой стороны, когда нет совпадения.

*Синтаксис:*
[source,sql]
----
SELECT column_name(s)
FROM table1
RIGHT JOIN table2 ON table1.column_name = table2.column_name;
----


*Пример:*
Следующий оператор SQL вернет всех пользователей и любые заказы, которые они могли бы разместить.

[source,sql]
----
SELECT invoice.invoice_id, users.name, users.fullname
FROM invoice
RIGHT JOIN users ON invoice.user_id = users.user_id
ORDER BY invoice.invoice_id;
----

== Ключевое слово FULL OUTER JOIN

Ключевое слово FULL OUTER JOIN возвращает все записи, когда есть совпадение в обеих таблицах таблицы (table1) или справа (table2).

*Синтаксис:*
[source,sql]
----
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример:*
Следующий оператор SQL выбирает всех пользователей и все заказы.
[source,sql]
----
SELECT users.name, invoice.invoice_id
FROM users
FULL OUTER JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;
----

== Self JOIN

`Self JOIN` - это регулярное соединение, но таблица соединяется сама с собой.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
----

*Пример.*

Следующий оператор SQL соответствует пользователям из одного города:

[source,sql]
----
SELECT A.name AS name1, B.name AS name2, A.city
FROM users A, users B
WHERE A.user_id <> B.user_id
AND A.city = B.city
ORDER BY A.city;
----

== Оператор `UNION`

Оператор UNION используется для объединения результирующего набора из двух или более операторов SELECT. Каждый оператор SELECT в UNION должен иметь одинаковое количество столбцов. Столбцы также должны иметь похожие типы данных и в каждой инструкции SELECT быть в том же порядке.

=== Синтаксис `UNION`

[source,sql]
----
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
----

=== Пример `UNION`
Следующий оператор SQL выбирает все разные города (только отдельные значения) от «users» и «delivery»:
[source,sql]
----
SELECT city FROM users
UNION
SELECT city FROM delivery
ORDER BY city;
----

=== Синтаксис `UNION ALL`

Оператор UNION по умолчанию выбирает только разные значения. Чтобы разрешить повторяющиеся значения, используйте UNION ALL:

[source,sql]
----
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
----

=== Пример `UNION ALL`
Следующий оператор SQL выбирает все города (дублирующиеся значения также) из «users» и «delivery»:

[source,sql]
----
SELECT city FROM users
UNION ALL
SELECT city FROM delivery
ORDER BY city;
----

=== SQL `UNION` с `WHERE`
Следующий оператор SQL выбирает все разные испанские города (только отдельные значения) от «users» и «delivery»:

[source,sql]
----
SELECT city, country FROM users
WHERE country='Spain'
UNION
SELECT city, country FROM delivery
WHERE country='Spain'
ORDER BY city;
----

=== SQL `UNION ALL` с `WHERE`
Следующий оператор SQL выбирает все испанские города (повторяющиеся значения) также из «users» и «delivery»:

[source,sql]
----
SELECT city, country FROM users
WHERE country='Spain'
UNION ALL
SELECT city, country FROM delivery
WHERE country = 'Spain'
ORDER BY city;
----

== Заявление `GROUP BY`

Оператор GROUP BY часто используется с агрегатными функциями (`COUNT`, `MAX`, `MIN`, `SUM`, `AVG`) для группировки результирующего набора одним или несколькими столбцами.

=== Синтаксис `GROUP BY`

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
----

=== Пример SQL `GROUP BY`
В следующем выражении SQL указано количество пользователей в каждой стране:
[source,sql]
----
SELECT COUNT(use_id), country
FROM users
GROUP BY country;
----

В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированных по высоким и низким:
[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
ORDER BY COUNT(user_id) DESC;
----

=== `GROUP BY` с `JOIN`
В следующем выражении SQL указано количество заказов, отправленных каждой службой доставки:
[source,sql]
----
SELECT delivery.name, COUNT(invoice.delivery_id) AS orders FROM invoice
LEFT JOIN delivery ON invoice.delivery_id = delivery.delivery_id
GROUP BY name;
----

== Предложение `HAVING`
Предложение HAVING используется в SQL, для работы с агрегатными функциями, так как WHERE не могло с ними использоваться.

=== Синтаксис `HAVING`
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
----

=== Пример `HAVING`
В следующем SQL-заявлении указано количество пользователей в каждой стране. Включать только страны с более чем 7 клиентами:

[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) > 7;
----
В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированные по высоким и низким.

[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) > 7
ORDER BY COUNT(user_id) DESC;
----

== Оператор `EXISTS`
Оператор EXISTS используется для проверки существования любой записи в подзапросе. Если подзапрос возвращает одну или несколько записей, то возвращается true.

=== Синтаксис `EXISTS`
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
----

=== Примеры использования `EXISTS`
Следующий оператор SQL возвращает TRUE и перечисляет доставки с ценой товара менее 1000:
[source,sql]
----
SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price < 1000);
----

Следующий оператор SQL возвращает TRUE и перечисляет доставки с ценой товара 5000.
[source,sql]
----
SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price = 5000);
----

== Операторы `ANY` и `ALL`

Операторы ANY и ALL используются с предложением WHERE или HAVING. Оператор ANY возвращает true, если какое-либо из значений подзапроса соответствует условию. Оператор ALL возвращает true, если все значения подзапроса удовлетворяют условию.

=== Синтаксис `ANY`
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
----

=== Пример `ANY`
Оператор ANY возвращает TRUE, если какое-либо из значений подзапроса соответствует условию. Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице info, с количеством = 15:

[source,sql]
----
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts = 15)
----

Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице info, с количеством > 15:

[source,sql]
----
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts > 15);
----

=== Синтаксис `ALL`
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);
----

=== Пример `ALL`
Оператор ALL возвращает TRUE, если все значения подзапроса удовлетворяют условию.

Следующий оператор SQL возвращает TRUE и перечисляет имена товаров, если ВСЕ записи в таблице info имеют количество = 7:
[source,sql]
----
SELECT name
FROM product
WHERE product_id = ALL (SELECT product_id FROM info WHERE couns =7);
----

== Заявление `SELECT INTO`
Оператор `SELECT INTO` копирует данные из одной таблицы в новую таблицу.

=== Синтаксис `SELECT INTO`
Скопировать все столбцы в новую таблицу:
[source,sql]
----
SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Скопировать только несколько столбцов в новую таблицу:
[source,sql]
----
SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Новая таблица будет создана с именами и типами столбцов, как определено в старой таблице. Вы можете создавать новые имена столбцов, используя предложение AS.

=== Примеры SQL `SELECT INTO`
Следующий оператор SQL создает резервную копию users:
[source,sql]
----
SELECT * INTO usersBackup001
FROM users;
----
Следующий оператор SQL использует предложение IN для копирования таблицы в новую таблицу в другой базе данных:
[source,sql]
----
SELECT * INTO usersBackup001 IN 'backup.mdb'
FROM users;
----
Следующий оператор SQL копирует только несколько столбцов в новую таблицу:

[source,sql]
----
SELECT name, fullname INTO usersBackup001
FROM users;
----

== Оператор `INSERT INTO SELECT`
Оператор INSERT INTO SELECT копирует данные из одной таблицы и вставляет ее в другую таблицу. INSERT INTO SELECT требует, чтобы типы данных в исходной и целевой таблицах соответствовали.

Синтаксис `INSERT IN SELECT`
Скопировать все столбцы из одной таблицы в другую:
[source,sql]
----
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
----

Скопировать только несколько столбцов из одной таблицы в другую таблицу:

[source,sql]
----
INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
----

=== Пример SQL `INSERT INTO SELECT`
Следующий оператор SQL копирует «clients» в «users» (столбцы, которые не заполнены данными, будет содержать NULL):

[source,sql]
----
INSERT INTO users (nme, fullname, balance)
SELECT nme, fullname, balance FROM clients;
----

==  Однострочные и многострочные комментарии
Комментарии используются для пояснения разделов операторов SQL или для предотвращения выполнения операторов во время отладки запросов.

=== Однострочные комментарии
Однострочные комментарии начинаются со знака `-` . Любой текст между `-` и концом строки будет проигнорирован (не будет выполнен).

В следующем примере в качестве объяснения используется однострочный комментарий:
[source,sql]
----
-Select all:
SELECT * FROM users;
----

В следующем примере используется однострочный комментарий для игнорирования конца строки:
[source,sql]
----
SELECT * FROM users -- WHERE balance = 1000;
----
В следующем примере используется однострочный комментарий для игнорирования оператора:

[source,sql]
----
--SELECT * FROM users
SELECT * FROM users;
----

=== Многострочные комментарии
Многострочные комментарии начинаются с / * и заканчиваются на * /. Любой текст между / * и * / будет проигнорирован. В следующем примере в качестве объяснения используется многострочный комментарий:
[source,sql]
----
/* Этот запрос
выведет данные
всех пользователей */

SELECT * FROM users;
----
В следующем примере используется многострочный комментарий для игнорирования многих операторов:
[source,sql]
----
/*SELECT * FROM users;
SELECT * FROM product;
SELECT * FROM invoice;*/

SELECT * FROM category;
----

== Оператор `ALTER TABLE`

Оператор `ALTER TABLE` используется для добавления, удаления или изменения столбцов в существующей таблице, а также для добавления и удаления различных ограничений для существующей таблицы.

=== `ALTER TABLE - ADD Column`
Чтобы добавить столбец в таблицу, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE table_name
ADD column_name datatype;
----

=== `ALTER TABLE - DROP COLUMN`
Чтобы удалить столбец в таблице, используйте следующий синтаксис (обратите внимание, что некоторые системы баз данных не позволяют удалить столбец):
[source,sql]
----
ALTER TABLE table_name
DROP COLUMN column_name;
----

=== `ALTER TABLE - ALTER/MODIFY COLUMN`
Чтобы изменить тип данных столбца в таблице, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
----

[source,sql]
----
ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
----

=== Изменить тип данных
Изменим тип данных столбца с именем «day_birth» в таблице «users».
[source,sql]
----
ALTER TABLE users
ALTER COLUMN day_birth year;
----

=== Пример `DROP COLUMN`

Для удаления столбца «day_birth» в таблице  «users» используется следующее:
[source,sql]
----
ALTER TABLE users
DROP COLUMN day_birth;
----

== Ограничения

Ограничения могут быть указаны при создании таблицы с помощью оператора CREATE TABLE или после создания таблицы с помощью инструкции ALTER TABLE.

=== Синтаксис
[source,sql]
----
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);
----

=== SQL-ограничения
SQL-ограничения используются для указания правил данных таблицы, для ограничения типа данных, которые могут входить в таблицу. Это обеспечивает точность и надежность данных в таблице. Если между ограничением и действием данных существует какое-либо нарушение, действие прерывается.

Ограничения могут быть уровнями столбцов или таблиц. Ограничения уровня столбца применяются к столбцу, а ограничения уровня таблиц относятся ко всей таблице.

В SQL обычно используются следующие ограничения:

* `NOT NULL` - гарантирует, что столбец не может иметь значение NULL
* `UNIQUE` - обеспечивает, чтобы все значения в столбце были разными
* `PRIMARY KEY` - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице
* `FOREIGN KEY` - однозначно идентифицирует строку / запись в другой таблице
* `CHECK` - обеспечивает, чтобы все значения в столбце удовлетворяли конкретному условию
* `DEFAULT` - устанавливает значение по умолчанию для столбца, если не указано значение
* `INDEX` - используется для быстрого создания и извлечения данных из базы данных



== Ограничение `NOT NULL`
По умолчанию столбец может содержать значения NULL. Ограничение NOT NULL приводит к тому, что столбец НЕ принимает значения NULL. Это приводит к тому, что поле всегда содержит значение, а это означает, что вы не можете вставить новую запись или обновить запись без добавления значения в это поле.

Следующий SQL гарантирует, что столбцы «user_id», «name» и «fullname» НЕ будут принимать значения NULL:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255) NOT NULL,
balanse int
);
----

== Ограничение `UNIQUE`
Ограничение `UNIQUE` гарантирует, что все значения в столбце отличаются. Ограничения `UNIQUE` и `PRIMARY KEY` гарантируют уникальность столбца или набора столбцов. Ограничение `PRIMARY KEY` автоматически имеет ограничение `UNIQUE`.

Однако для каждой таблицы может быть множество ограничений `UNIQUE`, но только одно ограничение `PRIMARY KEY` для каждой таблицы.
[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
UNIQUE (user_id)
);
----

=== SQL `UNIQUE` ограничение в `ALTER TABLE`

Чтобы создать ограничение UNIQUE в столбце «user_id», когда таблица уже создана, используйте следующее:
[source,sql]
----
ALTER TABLE users
ADD UNIQUE (user_id);
----
Чтобы назвать ограничение UNIQUE и определить ограничение UNIQUE для нескольких столбцов, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT UC_Users UNIQUE (user_id, name);
----

=== `DROP a UNIQUE`
Чтобы удалить ограничение `UNIQUE`, используйте следующий SQL:

[source,sql]
----
ALTER TABLE users
DROP INDEX UC_Users;
----

== Ограничение `PRIMARY KEY`

Ограничение PRIMARY KEY однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать UNIQUE значения и не могут содержать значения NULL.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

=== `PRIMARY KEY` для `CREATE TABLE`
Следующий SQL создает PRIMARY KEY в столбце «user_id», когда создается таблица «users»:
[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
PRIMARY KEY (user_id)
);
----

Чтобы разрешить именовать ограничение PRIMARY KEY и определить ограничение PRIMARY KEY для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE users (
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    CONSTRAINT PK_Users PRIMARY KEY (user_id, name)
);
----

=== SQL `PRIMARY KEY` на `ALTER TABLE`
Чтобы создать ограничение PRIMARY KEY в столбце «user_id», когда таблица уже создана, используйте следующее:
[source,sql]
----
ALTER TABLE users
ADD PRIMARY KEY (user_id);
----
Чтобы разрешить именовать ограничение PRIMARY KEY и определить ограничение PRIMARY KEY для нескольких столбцов, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT PK_Users PRIMARY KEY (user_id, name);
----

=== `DROP` a `PRIMARY KEY`
Чтобы удалить ограничение PRIMARY KEY, используйте следующее:
[source,sql]
----
ALTER TABLE users
DROP PRIMARY KEY;
----

== Ограничение `FOREIGN KEY`
`FOREIGN KEY` - это ключ, используемый для соединения двух таблиц вместе. Является полем (или набором полей) в одной таблице, которое ссылается на `PRIMARY KEY` в другой таблице.

Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ-кандидат, называется ссылочной или родительской таблицей.

=== SQL `FOREIGN KEY` в `CREATE TABLE`
Следующий SQL создает FOREIGN KEY в столбце «user_id» при создании таблицы «invoice»:
[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
FOREIGN KEY (user_id) REFERENCES users(user_id)
);
----
Чтобы разрешить именовать ограничение FOREIGN KEY и определять ограничение FOREIGN KEY для нескольких столбцов, используйте следующий синтаксис SQL:
[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
CONSTRAINT FK_UserInvoice FOREIGN KEY (user_id)
REFERENCES Users(user_id)
);
----

=== SQL `FOREIGN KEY` на `ALTER TABLE`
Чтобы создать ограничение FOREIGN KEY в столбце «user_id», когда таблица «invoice» уже создана, используйте следующее:
[source,sql]
----
ALTER TABLE invoice
ADD FOREIGN KEY (user_id) REFERENCES Users(user_id);
----
Чтобы разрешить именовать ограничение FOREIGN KEY и определять ограничение FOREIGN KEY для нескольких столбцов, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE invoice
ADD CONSTRAINT FK_UsersInvoice
FOREIGN KEY (user_id) REFERENCES Users(user_id);
----

=== `DROP` a `FOREIGN KEY`
Чтобы удалить ограничение FOREIGN KEY, используйте следующий:

[source,sql]
----
ALTER TABLE invoice
DROP FOREIGN KEY FK_UsersInvoice;
----

== Ограничение `CHECK`

Ограничение CHECK используется для ограничения диапазона значений, который может быть помещен в столбец. Если вы определяете ограничение CHECK для одного столбца, оно допускает только определенные значения для этого столбца. Если вы определяете ограничение CHECK для таблицы, оно может ограничить значения в определенных столбцах на основе значений в других столбцах в строке.

=== SQL `CHECK` на `CREATE TABLE`
Следующий SQL создает ограничение CHECK в столбце «age», когда создается таблица «users». Ограничение CHECK гарантирует, не может быть пользователя с возрастом старше 60 лет:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
CHECK (age>=60)
);
----

Чтобы разрешить именовать ограничение CHECK и определить ограничение CHECK для нескольких столбцов, используйте следующий синтаксис SQL:
[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
balance int,
CONSTRAINT CHK_Users CHECK (age>=60 AND balance = 500)
);
----

=== SQL `CHECK` на `ALTER TABLE`
Чтобы создать ограничение CHECK в столбце «age», когда таблица уже создана, используйте следующее:
[source,sql]
----
ALTER TABLE users
ADD CHECK (age>=60);
----
Чтобы разрешить именовать ограничение CHECK и определить ограничение CHECK для нескольких столбцов, используйте следующий синтаксис:
[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT CHK_UsersAge CHECK (age>=60 AND country='Spain');
----

=== `DROP` a `CHECK`
Чтобы удалить ограничение CHECK, используйте следующий SQL:
[source,sql]
----
ALTER TABLE users
DROP CHECK CHK_UsersAge;
----

== Ограничение `DEFAULT`
Ограничение DEFAULT используется для предоставления значения по умолчанию для столбца. Значение по умолчанию будет добавлено ко всем новым записям, если другое значение не указано.

=== SQL `DEFAULT` в `CREATE TABLE`

Следующий SQL устанавливает значение DEFAULT для столбца «country», когда создается таблица «users»:
[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
country varchar(255) DEFAULT 'Spain'
);
----
=== SQL `DEFAULT` в `ALTER TABLE`

Чтобы создать ограничение DEFAULT в столбце «country», когда таблица уже создана, используйте следующее:
[source,sql]
----
ALTER TABLE users
ALTER country SET DEFAULT 'Spain';
----

=== `DROP` a `DEFAULT`

Чтобы удалить ограничение DEFAULT, используйте следующее:
[source,sql]
----
ALTER TABLE users
ALTER country DROP DEFAULT;
----

== Ограничение `CREATE INDEX`

Оператор CREATE INDEX используется для создания индексов в таблицах. Индексы используются для быстрого извлечения данных из базы данных. Пользователи не могут видеть индексы, они просто используются для ускорения поиска/запросов.

=== Синтаксис CREATE INDEX
CREATE INDEX создает индекс в таблице. Допускаются повторяющиеся значения:

[source,sql]
----
CREATE INDEX index_name
ON table_name (column1, column2, ...);
----

=== Синтаксис CREATE UNIQUE INDEX
Создает уникальный индекс в таблице. Дублирующие значения не допускаются:
[source,sql]
----
CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
----
=== Пример CREATE INDEX
В приведенной ниже инструкции SQL создается индекс с именем «ind_name» в столбце «name» в таблице «users»:

CREATE INDEX ind_name
ON users (name);
Если вы хотите создать индекс в комбинации столбцов, вы можете указать имена столбцов в круглых скобках, разделенные запятыми:
[source,sql]
----
CREATE INDEX ind_name
ON users (name, fullname);
----
=== DROP INDEX
Оператор DROP INDEX используется для удаления индекса в таблице.
[source,sql]
----
ALTER TABLE table_name
DROP INDEX index_name;
----

== Поле `AUTO INCREMENT`
Auto-increment позволяет создавать уникальный номер автоматически, когда новая запись вставляется в таблицу. Часто это поле основного ключа, которое мы хотели бы создать автоматически каждый раз, когда будет вставлена новая запись.

=== Синтаксис для `MySQL`
Следующий оператор SQL определяет столбец «user_id» как поле первичного ключа с автоматическим приращением в таблице «users»:
[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL AUTO_INCREMENT,
name varchar(255) NOT NULL,
fullname varchar(255),
balance int,
PRIMARY KEY (user_id)
);
----

MySQL использует ключевое слово AUTO_INCREMENT для выполнения функции автоматического увеличения.

По умолчанию начальное значение для AUTO_INCREMENT равно 1, и оно будет увеличиваться на 1 для каждой новой записи.

Чтобы последовательность AUTO_INCREMENT начиналась с другого значения, используйте следующий оператор:
[source,sql]
----
ALTER TABLE users AUTO_INCREMENT = 7;
----
Чтобы вставить новую запись в таблицу «user», нам не нужно указывать значение для столбца «user_id», так как уникальное значение будет добавляться автоматически:
[source,sql]
----
INSERT INTO users (name, fullname)
VALUES ('Том','Эдисон');
----


== Работа с датами
Пока ваши данные содержат только часть даты, ваши запросы будут работать должным образом. Однако, если задействована временная часть, она становится более сложной.

=== Типы данных `SQL Date`
MySQL имеет следующие типы данных для хранения даты или значения даты/времени в базе данных:

* `DATE` - формат: YYYY-MM-DD
* `DATETIME` - формат: YYYY-MM-DD HH:MI:SS
* `TIMESTAMP` - формат: YYYY-MM-DD HH:MI:SS
* `YEAR` - формат: YYYY or YY

== Операторы

.Арифметические операторы SQL
|===
|Оператор|Описание
|`+`|Добавление
|`-`|Вычитание
|`*`|Умножение
|`/`|Деление
|`%`|Модуль
|===

.Побитовые операции SQL
|===
|Оператор|Описание
|`&`|Побитовое М
|/||Побитовое ИЛИ
|`^`|Побитовое исключение ИЛИ
|===

.Операторы сравнения SQL
|===
|Оператор|Описание
|`=`|Равно
|`>`|Больше
|`<`|Меньше
|`>=`|Больше или равно
|`<=`|Меньше или равно
|`<>`|Не равно
|===

.Составные операторы SQL
|===
|Оператор|Описание
|`+=` |Добавить равно
|`-=`|Вычесть равно
|`*=`|Умножить равно
|`/=`|Разделить равно
|`%=`|Модуль равно
|`&=`|Побитовое И равно
|`^-=`|Побитовое исключающее равно
|`\|*=` |Побитовое ИЛИ равно
|===

.Логические операторы SQL
|===
|Оператор|Описание
|`ALL` |Если все значения подзапроса являются TRUE
|`AND`|Если все условия, разделенные И, являются TRUE
|`ANY`|Если какое-либо из значений подзапроса соответствует TRUE условию
|`BETWEEN`|	Если операнд находится в диапазоне сравнения
|`EXISTS`|Если подзапрос возвращает одну или несколько записей
|`IN`|	Если операнд равен одному из списка выражений
|`LIKE`|	Если операнд соответствует шаблону
|`NOT`|	Отображает запись, если условие (И) НЕ TRUE
|`OR`|Если любое из условий, разделенных OR, является TRUE.
|`SOME`|	Если какое-либо из значений подзапроса соответствует условию
|===

== Функции
|===
|Функция|Описание
|`ASCII`|Возвращает числовой код, который представляет конкретный символ
|`CHAR_LENGTH`|Возвращает длину указанной строки (в символах)
|`CHARACTER_LENGTH`|Возвращает длину указанной строки (в символах)
|`CONCAT`|Объединяет два или более выражения вместе
|`CONCAT_WS`|Объединяет два или более выражения вместе и добавляет разделитель между ними
|`FIELD`|Возвращает позицию значения в списке значений
|`FIND_IN_SET`|Возвращает позицию строки в списке строк
|`FORMAT`|Форматирует число как формат «#, ###. ##», округляя его до определенного количества знаков после запятой
|`INSERT`|Вставляет подстроку в строку в указанной позиции для определенного количества символов
|`INSTR`|Возвращает позицию первого вхождения строки в другую строку
|`LCASE`|Преобразует строку в нижний регистр
|`LEFT`|Извлекает подстроку из строки (начиная слева)
|`LENGTH`|Возвращает длину указанной строки (в байтах)
|`LOCATE`|Возвращает позицию первого вхождения подстроки в строку
|`LOWER`|Преобразует строку в нижний регистр
|`LPAD`|Возвращает строку, которая добавлена в левую сторону с указанной строкой до определенной длины
|`LTRIM`|Удаляет ведущие пробелы из строки
|`MID`|Извлекает подстроку из строки (начиная с любой позиции)
|`POSITION`|Возвращает позицию первого вхождения подстроки в строку
|`REPEAT`|Повторяет строку определенное количество раз
|`REPLACE`|Заменяет все вхождения указанной строки
|`REVERSE`|Отменяет строку и возвращает результат
|`RIGHT`|Извлекает подстроку из строки (начиная справа)
|`RPAD`|Возвращает строку с правой строкой с определенной строкой до определенной длины
|`RTRIM`|Удаляет конечные пробелы из строки
|`SPACE`|Возвращает строку с заданным количеством пробелов
|`STRCMP`|Проверяет, одинаковы ли две строки
|`SUBSTR`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING_INDEX`|Возвращает подстроку  string и перед integer вхождений delimiter
|`TRIM`|Удаляет начальные и конечные пробелы из строки
|`UCASE`|Преобразует строку в верхний регистр
|`UPPER`|Преобразует строку в верхний регистр
|===

.Числовые функции
|===
|Функция|Описание
|`ABS`|Возвращает абсолютное значение числа
|`ACOS`|Возвращает косинус дуги числа
|`ASIN`|Возвращает синус дуги числа
|`ATAN`|Возвращает тангенс дуги числа или дуги касательной n и m
|`ATAN2`|Возвращает тангенс дуги n и m
|`AVG`|Возвращает среднее значение выражения
|`CEIL`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`CEILING`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`COS`|Возвращает косинус числа
|`COT`|Возвращает котангенс числа
|`COUNT`|Возвращает количество записей в выбранном запросе
|`DEGREES`|Преобразует значение радиана в градусы
|`DIV`|Используется для целочисленного деления
|`EXP`|Возвращает e, поднятый до степени числа
|`FLOOR`|Возвращает наибольшее целочисленное значение, которое меньше или равно числу
|`GREATEST`|Возвращает наибольшее значение в списке выражений
|`LEAST`|Возвращает наименьшее значение в списке выражений
|`LN`|Возвращает натуральный логарифм числа
|`LOG`|Возвращает натуральный логарифм числа или логарифм числа к заданной базе
|`LOG10`|Возвращает логарифм базы-10 числа
|`LOG2`|Возвращает логарифм базы-2 числа
|`MAX`|Возвращает максимальное значение выражения
|`MIN`|Возвращает минимальное значение выражения
|`MOD`|Возвращает остаток n, деленный на m
|`PI`|Возвращает значение PI, отображаемое с шестью знаками после запятой
|`POW`|Возвращает m, поднятую до n-й степени
|`POWER`|Возвращает m, поднятую до n-й степени
|`RADIANS`|Преобразует значение в градусах в радианы
|`RAND`|Возвращает случайное число или случайное число в пределах диапазона
|`ROUND`|Возвращает число, округленное до определенного количества знаков после запятой
|`SIGN`|Возвращает значение, обозначающее знак числа
|`SIN`|Возвращает синус числа
|`SQRT`|Возвращает квадратный корень из числа
|`SUM`|Возвращает суммарное значение выражения
|`TAN`|Возвращает тангенс числа
|`TRUNCATE`|Возвращает число, усеченное до определенного количества знаков после запятой
|===



.Функции даты
|===
|Функция|	Описание
|`DATEDIFF`|Возвращает дату после добавления определенного интервала времени / даты
|`DATE_ADD`|Возвращает время / дату-время после добавления определенного временного интервала
|`DATE_FORMAT`|Возвращает текущую дату
|`DATE_SUB`|Возвращает текущую дату
|`DAY`|Возвращает текущее время
|`DAYNAME`|Возвращает текущую дату и время
|`DAYOFMONTH`|Возвращает текущее время
|`DAYOFWEEK`|Извлекает значение даты из выражения даты или даты и времени
|`DAYOFYEAR`|Возвращает разницу в днях между двумя значениями даты
|`EXTRACT`|Возвращает дату после добавления определенного интервала времени / даты
|`FROM_DAYS`|Форматирует дату, указанную маской формата
|`HOUR`|Возвращает дату после вычитания определенного интервала времени / даты
|`LAST_DAY`|Возвращает дневную часть значения даты
|`LOCALTIME`|Возвращает имя дня недели для даты
|`LOCALTIMESTAMP`|Возвращает дневную часть значения даты
|`MAKEDATE`|Возвращает индекс недели недели для значения даты
|`MAKETIME`|Возвращает день года для значения даты
|`MICROSECOND`|Извлекает части с даты
|`MINUTE`|Возвращает значение даты из числового представления дня
|`MONTH`|Возвращает часовую часть значения даты
|`MONTHNAME`|Возвращает последний день месяца на заданную дату
|`NOW`|Возвращает текущую дату и время
|`PERIOD_ADD`|Возвращает текущую дату и время
|`PERIOD_DIFF`|Возвращает дату определенного годового и дневного значения
|`QUARTER`|Возвращает время для определенного часа, минуты, второй комбинации
|`SECOND`|Возвращает микросекундную часть значения даты
|`SEC_TO_TIME`|Возвращает минутную часть значения даты
|`STR_TO_DATE`|Возвращает месячную часть значения даты
|`SUBDATE`|Возвращает полное название месяца для даты
|`SUBTIME`|Возвращает текущую дату и время
|`SYSDATE`|Принимает период и добавляет к нему определенное количество месяцев
|`TIME`|Возвращает разницу в месяцах между двумя периодами
|`TIME_FORMAT`|Возвращает четвертную часть значения даты
|`TIME_TO_SEC`|Возвращает вторую часть значения даты
|`TIMEDIFF`|Преобразует числовые секунды в значение времени
|`TIMESTAMP`|Принимает строку и возвращает дату, заданную маской формата
|`TO_DAYS`|Возвращает дату, после которой вычитается определенный интервал времени / даты
|`WEEK`|Возвращает значение time / datetime после вычитания определенного временного интервала
|`WEEKDAY`|Возвращает текущую дату и время
|`WEEKOFYEAR`|Извлекает значение времени из выражения time / datetime
|`YEAR`|Форматирует время, указанное маской формата
|`YEARWEEK`|Преобразует значение времени в числовые секунды
|===

.Расширенные функции
|===
|Функция|	Описание
|`BIN`|Преобразует десятичное число в двоичное число
|`BINARY`|Преобразует значение в двоичную строку
|`CASE`|Позволяет вам оценить условия и вернуть значение при выполнении первого условия
|`CAST`|Преобразует значение из одного типа данных в другой тип данных
|`COALESCE`|Возвращает первое ненулевое выражение в списке
|`CONNECTION_ID`|Возвращает уникальный идентификатор соединения для текущего соединения
|`CONV`|Преобразует число из одной базы чисел в другую
|`CONVERT`|Преобразует значение из одного типа данных в другой или один набор символов в другой
|`CURRENT_USER`|Возвращает имя пользователя и имя хоста для учетной записи MySQL, используемой сервером, для проверки подлинности текущего клиента
|`DATABASE`|Возвращает имя базы данных по умолчанию
|`IF`|Возвращает одно значение, если условие TRUE или другое значение, если условие FALSE
|`IFNULL`|Позволяет вернуть альтернативное значение, если выражение равно NULL
|`ISNULL`|Проверяет, является ли выражение NULL
|`LAST_INSERT_ID`|Возвращает первое значение AUTO_INCREMENT, заданное последним оператором INSERT или UPDATE
|`NULLIF`|Сравнивает два выражения
|`SESSION_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`SYSTEM_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`VERSION`|Возвращает версию базы данных MySQL
|===