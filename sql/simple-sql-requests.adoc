= Простые SQL-запросы

== Создание таблицы `CREATE TABLE`

Для того чтобы создать таблицу в *SQL*, используется выражение `CREATE TABLE`. Оно принимает в качестве параметров все колонки, которые необходимо внести, а также их типы данных. Пример создания таблицы с названием `Months`, в которой будет три колонки:

* `id` - порядковый номер месяца (целочисленный тип или `int`).
* `name` - название месяца.
* `days` - число дней в конкретном месяце.

Код создания будет выглядеть следующим образом:

[source,sql]
----
CREATE TABLE months (id int, name varchar(10), days int);
----

== Запрос `DROP TABLE`

Оператор `DROP TABLE` используется для удаления существующей таблицы в базе данных.

*Синтаксис:*

[source,sql]
----
DROP TABLE table_name;
----

== Удаление таблиц при помощи `TRUNCATE`

Если необходимо все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду `TRUNCATE`:

[source,sql]
----
TRUNCATE TABLE table_name;
----

==  Оператор `CREATE DATABASE`

Оператор `CREATE DATABASE` используется для создания новой базы данных SQL.

*Синтаксис:*

[source,sql]
----
CREATE DATABASE databasename;
----

*Пример*, следующий оператор SQL создает базу данных с именем `invoice`:

[source,sql]
----
CREATE DATABASE invoice;
----

== Оператор `DROP DATABASE`

Оператор `DROP DATABASE` используется для удаления существующей базы данных SQL.

*Синтаксис:*

[source,sql]
----
DROP DATABASE databasename;
----

*Пример*, следующий оператор SQL уничтожает существующую базу данных `info`:

[source,sql]
----
DROP DATABASE info;
----

== Запрос `INSERT INTO`

`INSERT INTO` - этот запрос используется для добавления двумя разными способами новых строк данных в таблицу в базе данных.

*Способ первый:*

[source,sql]
----
INSERT INTO months VALUES (1,'January',31);
----

Этот способ не подразумевает указания названий колонок, а лишь принимает значения в том порядке, в котором они указаны в таблице. Однако, если в будущем необходимо добавить дополнительные колонки, все предыдущие запросы работать не будут.

Для решения данной проблемы следует использовать *второй способ*. Его суть заключается в том, что перед вводом данных указываются названия колонок.

[source,sql]
----
INSERT INTO months (id,name,days) VALUES (2,'February',29);
----

== Запрос `SELECT`

`SELECT` - используется для выбора данных из базы данных. Возвращаемые данные сохраняются в таблице результатов, называемой результирующим набором.

[source,sql]
----
SELECT * FROM characters
----

Результатом данного запроса будет таблица со всеми данными в таблице `characters`. Знак звёздочки (`*`) означает то, что необходимо показать все столбцы из таблицы без исключений. Так как в базе данных обычно больше одной таблицы, нам необходимо указывать название таблицы, данные из которой требуется посмотреть. Сделать это можно используя ключевое слово `FROM`.

Когда необходимы лишь некоторые столбцы из таблицы, то можно указать их имена через запятую вместо звёздочки.

[source,sql]
----
SELECT name, weapon FROM characters
----

== Запрос `SELECT DISTINCT`

Оператор `SELECT DISTINCT` используется для возврата только отдельных (разных) значений. Внутри таблицы столбец часто содержит много повторяющихся значений и вам нужно только перечислить отличающиеся значения.

*Синтаксис:*

[source,sql]
----
SELECT DISTINCT column1, column2, ...
FROM table_name;
----

*Пример*, следующий оператор SQL выбирает только значения `DISTINCT` из столбца «name» в таблице `users`:

[source,sql]
----
SELECT DISTINCT name FROM users;
----

В следующем SQL-заявлении указано количество разных имен пользователей:

[source,sql]
----
SELECT COUNT(DISTINCT name) FROM users;
----

== Запрос `WHERE`

`WHERE` - это запрос позволяющий включить в вывод лишь некоторые конкретные строки. Данное ключевое слово позволяет фильтровать данные по определённому условию.

*Синтаксис:*

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition;
----

*Пример предложения*, следующий оператор SQL выбирает всех пользователей с именем `name` в таблице `users`:

[source,sql]
----
SELECT * FROM users
WHERE name ='Том';
----

Следует отметить, что *SQL* требует одинарных кавычек вокруг текстовых значений (большинство систем баз данных также допускают двойные кавычки). Однако числовые поля не должны быть заключены в кавычки.

=== Операторы в разделе `WHERE`

Следующие операторы могут использоваться в предложении `WHERE`:

|===
|*Заголовок*|*Группа*
| `=` |Равно
|`!=` или `<>`|Не равно
| `>`|Больше чем
|`<`|	Меньше чем
|`>=`|	Больше или равно
|`\<=`|Меньше или равно
|`BETWEEN`|Между включенным диапазоном
|`LIKE`|Поиск по шаблону
|`IN`|Поиск данных по нескольким значениям, перечисленным через запятую
|===

== Операторы `AND`, `OR` и `NOT`

Предложение `WHERE` может быть объединено с операторами `AND`, `OR` и `NOT`. Операторы `AND` и `OR` используются для фильтрации записей на основе более чем одного условия:

* Оператор `AND` отображает запись, если все условия, разделенные символом `AND`, имеют значение `TRUE`.
* Оператор `OR` отображает запись, если любое из условий, разделенных `OR`, является `TRUE`.
* Оператор `NOT` отображает запись, если условие (и) *НЕ ИСТИНА*.

=== Оператор `AND`

*Синтаксис:*

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition1 AND condition2 AND condition3 ...;
----

*Пример:*

Следующий оператор SQL выбирает все поля из `users`, где пол `gender` равен `1` (_женский_), а баланс `balance` больше или равен (`>=`) `1000`.

[source,sql]
----
SELECT * FROM users
WHERE gender = 1 AND balance >= 1000;
----

=== Оператор `OR`

*Синтаксис:*

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE condition1 OR condition2 OR condition3 ...;
----

*Пример:*

Следующий оператор SQL выбирает все поля из `users`, где баланс пользователя `balance` равен `1000` или возраст пользователя `age` равен `25`.

[source,sql]
----
SELECT * FROM users
WHERE balance = 1000 OR age = 25;
----

=== Оператор `NOT`

*Синтаксис:*

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE NOT condition;
----

*Пример:*

Следующий оператор SQL выбирает все поля из `users`, где возраст `age` не равен `30`:

[source,sql]
----
SELECT * FROM users
WHERE NOT age = 30
----

=== Объединение `AND`, `OR` и `NOT`

Также можно комбинировать операторы `AND`, `OR` и `NOT`.

Следующий оператор выбирает все поля из `users`, где возраст `age` равно `30`. И баланс `balance` больше `1000` или имя `name` равно `Том`.

*Пример:*

[source,sql]
----
SELECT * FROM users
WHERE age = 30 AND (balance > 1000 OR name = 'Том');
----

== Ключевое слово `ORDER BY`

Ключевое слово `ORDER BY` используется для сортировки результирующего набора в порядке возрастания или убывания. По умолчанию оно сортирует записи по возрастанию. Чтобы отсортировать записи в порядке убывания, используйте ключевое слово `DESC`. Для сортировки по возрастанию, используйте ключевое слово `ASC`.

*Синтаксис:*

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
----

*Пример:*

Следующий оператор выбирает всех пользователей из таблицы `users`, отсортированные по столбцу `name`:

[source,sql]
----
SELECT * FROM users
ORDER BY name;
----

== Значение `NULL`

Поле со значением `NULL` является полем без значения. Если поле в таблице является необязательным, можно вставить новую запись или обновить запись без добавления значения в это поле. Затем поле будет сохранено со значением `NULL`. Значение `NULL` отличается от нулевого значения или поля, содержащего пробелы.

=== Как проверить значения `NULL`?

Невозможно проверить значения `NULL` с операторами сравнения, такими как `=`, `<` или `<>`. Вместо этого нужно использовать операторы `IS NULL` и `NOT NULL`.

Синтаксис `IS NULL`:

[source,sql]
----
SELECT column_names
FROM table_name
WHERE column_name IS NULL;
----

Пример `IS NULL`:

Следующий оператор использует оператор `IS NULL` для перечисления всех пользователей, у которых нет телефона.

[source,sql]
----
SELECT name, fullname, phone FROM users
WHERE phone IS NULL;
----

Синтаксис `NOT NULL`:

[source,sql]
----
SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;
----

Пример `IS NOT NULL`: следующий оператор использует оператор `IS NOT NULL` для перечисления всех пользователей, у которых есть телефон.

[source,sql]
----
SELECT name, fullname, phone FROM users
WHERE phone IS NOT NULL;
----

== Запрос `UPDATE`

Зачастую необходимо изменить данные в таблице. В *SQL* это делается с помощью `UPDATE`.

Использование `UPDATE` включает в себя выбор таблицы, в которой находится поле подлежащее изменению. Запись нового значения осуществляется с помощью запроса `WHERE`, чтобы обозначить конкретное место в таблице.

*Синтаксис:*

[source,sql]
----
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition
----

*Пример:*

Предположим есть таблица с самыми высоко оценёнными сериалами всех времён. Однако в ней есть несоответствие: *Игра Престолов*  обозначена как комедия, изменим значение поля следующим запросом:

[source,sql]
----
UPDATE tv_series
SET genre = 'drama'
WHERE name = 'Game of Thrones';
----

== Удаление записей из таблицы c помощью `DELETE`.

Удаление записи из таблицы очень простая операция, всё что нужно - это обозначить, что необходимо удалить.

[source,sql]
----
DELETE FROM tv_series
WHERE id = 4;
----

NOTE: Необходимо убедиться что используется запрос `WHERE`, когда происходит удаление записи из таблицы. Иначе удалятся все записи.

=== Удалить все записи

Можно удалить все строки таблицы без удаления таблицы. Это означает, что структура таблицы, атрибуты и индексы будут неповрежденными:

[source,sql]
----
DELETE FROM table_name;
----

или:

[source,sql]
----
DELETE * FROM table_name;
----

== Предложение `SELECT TOP`

Предложение `SELECT TOP` используется для указания количества возвращаемых записей. Оно полезно для больших таблиц с тысячами записей. Возвращение большого количества записей может повлиять на производительность.

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
----

=== Примеры `TOP`, `LIMIT` и `ROWNUM`

Следующий оператор выбирает первые три записи из таблицы `users`:

[source,sql]
----
SELECT TOP 3 * FROM users;
----

Следующий оператор показывает эквивалентный пример, используя предложение `LIMIT`:

[source,sql]
----
SELECT * FROM users
LIMIT 3;
----

Следующий оператор показывает эквивалентный пример с использованием `ROWNUM`:

[source,sql]
----
SELECT * FROM users
WHERE ROWNUM <= 3;
----

=== Пример `TOP PERCENT`

Следующий оператор выбирает *первые 25% записей* из таблицы `users`:

[source,sql]
----
SELECT TOP 25 PERCENT * FROM users;
----

Следующий оператор выбирает первые 5 записи из таблицы `users`, где баланс `balance` равен `1000`:

[source,sql]
----
SELECT TOP 5 * FROM users
WHERE balance = 1000;
----

=== Пример `LIMIT`

Следующий оператор показывает эквивалентный пример, используя предложение `LIMIT`:

[source,sql]
----
SELECT * FROM users
WHERE balance = 1000
LIMIT 5;
----

Следующий оператор показывает эквивалентный пример с использованием `ROWNUM`:

[source,sql]
----
SELECT * FROM users
WHERE balance = 1000 AND ROWNUM <= 5;
----

== Функции `MIN()` и `MAX()`

Функция `MIN()` возвращает наименьшее значение выбранного столбца. Функция `MAX()` возвращает наибольшее значение выбранного столбца.

*Синтаксис `MIN()`:*

[source,sql]
----
SELECT MIN(column_name)
FROM table_name
WHERE condition;
----

*Пример `MIN()`:*

[source,sql]
----
SELECT MIN(price) AS min_price
FROM product;
----

*Синтаксис `MAX()`:*

[source,sql]
----
SELECT MAX(column_name)
FROM table_name
WHERE condition;
----

*Пример `MAX()`*

[source,sql]
----
SELECT MAX(price) AS max_price
FROM product;
----

== Функция `COUNT()`

Функция `COUNT()` возвращает количество строк, соответствующих заданным критериям.

*Синтаксис:*

[source,sql]
----
SELECT COUNT(column_name)
FROM table_name
WHERE condition;
----

*Пример:*

Следующий оператор SQL находит количество товаров.

[source,sql]
----
SELECT COUNT(product_id)
FROM product;
----

== Функция `AVG()`

Функция `AVG()` возвращает среднее значение числового столбца.

*Синтаксис:*

[source,sql]
----
SELECT AVG(column_name)
FROM table_name
WHERE condition;
----

*Например* найдем среднюю стоимость товара:

[source,sql]
----
SELECT AVG(price)
FROM product;
----

== Функция `SUM()`

Функция `SUM()` возвращает общую сумму числового столбца.

*Синтаксис:*

[source,sql]
----
SELECT SUM(column_name)
FROM table_name
WHERE condition;
----

*Пример*, найдем сумму полей доставка `delivery` в таблице `invoice`:

[source,sql]
----
SELECT SUM(delivery)
FROM invoice;
----

== Оператор `LIKE`

Оператор `LIKE` используется в предложении `WHERE` для поиска заданного шаблона в столбце.

В сочетании с оператором `LIKE` используются два подстановочных знака:

* `%` - Знак процента представляет нулевой, один или несколько символов
* `_` - Подчеркнутый символ представляет собой один символ

[source,sql]
----
SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
----

|===
|Выражение|	Описание
|`WHERE name LIKE 'text%'`|Находит любые значения, начинающиеся с `text`
|`WHERE name LIKE '%text'`|Находит любые значения, заканчивающиеся на `text`
|`WHERE name LIKE '%text%'`|Находит любые значения, которые имеют `text` в любой позиции
|`WHERE name LIKE '_text%'`|Находит любые значения, которые имеют `text` во второй позиции
|`WHERE name LIKE 'text_%_%'`|Находит любые значения, начинающиеся с `text` и длиной не менее 3 символов
|`WHERE name LIKE 'text%data'`|Находит любые значения, начинающиеся с `text` и заканчивающиеся на `data`
|===

== Подстановочные знаки

Символ подстановки используется для замены любого другого символа в строке. Подстановочные символы используются с оператором `LIKE`. Оператор `LIKE` используется в предложении `WHERE` для поиска заданного шаблона в столбце.

=== Использование подстановочного знака

Следующий оператор SQL выбирает всех пользователей с `name`, начиная с любого символа, за которым следует `о`:

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '_о';
----

Следующий оператор выбирает всех пользователей с `name` начиная с `Т`, за которыми, следует любой символ. А за ним следует `м`, за которым следует любой символ, а затем `с`:

[source,sql]
----
SELECT * FROM users
WHERE name LIKE 'Т_м_с';
----

==== Использование подстановочного знака `[charlist]`

Следующий оператор SQL выбирает всех пользователей с name, начиная с `Т`, `Р` или `Е`:

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[ТРЕ]%';
----

Следующий оператор SQL выбирает всех пользователей с `name`, начиная с `Т`, `Р` или `Е`:

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[Т-E]%'
----

==== Использование подстановочного знака `[!charlist]`

Два следующих оператора SQL выбирают всех пользователей с помощью `name NOT`, начинающегося с `Т`, `Р` или `E`:

[source,sql]
----
SELECT * FROM users
WHERE name LIKE '[!ТРЕ]%';
----

Или:

[source,sql]
----
SELECT * FROM users
WHERE name NOT LIKE '[ТРЕ]%';
----

== Оператор `IN`

Оператор `IN` позволяет указать несколько значений в предложении `WHERE`. Он является сокращением для нескольких условий `OR`.

*Синтаксис `IN`*

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
----

*или:*

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
----

*Например* выберем всех пользователей, которые находятся в странах `Испания`, `Франция` и `Бразилия`:

[source,sql]
----
SELECT * FROM users
WHERE country IN ('Испания', 'Франция', 'Бразилия');
----

Выберем всех пользователей, которые *НЕ расположены* в `Испания`, `Франция` и `Бразилия`:

[source,sql]
----
SELECT * FROM users
WHERE country NOT IN ('Испания', 'Франция', 'Бразилия');
----

== Оператор `BETWEEN` и `NOT BETWEEN`

Оператор `BETWEEN` выбирает значения в заданном диапазоне. Значения могут быть числами, текстом или датами.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
----

*Например* выберем все продукты с ценой `BETWEEN` `5` и `200`.

[source,sql]
----
SELECT * FROM product
WHERE price BETWEEN 5 AND 200;
----

Чтобы отобразить товары вне диапазона предыдущего примера, используйте `NOT BETWEEN`:

[source,sql]
----
SELECT * FROM product
WHERE price NOT BETWEEN 5 AND 200;
----

=== Пример `BETWEEN` с `IN`

Следующий оператор выбирает все товары с ценой `BETWEEN` `5` и `200` и не показывать товары с категориями `1`, `2`, `3`, `4`, `5`.

[source,sql]
----
SELECT * FROM product
WHERE (price BETWEEN 5 AND 200)
AND NOT category_id IN (1, 2, 3, 4, 5);
----

=== `BETWEEN` текстовых значений

Следующий оператор выбирает все товары с name `BETWEEN` `'Красный телефон'` и `'Серебристая клавиатура'`:

[source,sql]
----
SELECT * FROM product
WHERE name BETWEEN 'Красный телефон' AND 'Серебристая клавиатура'
ORDER BY name;
----

=== `NOT BETWEEN` текстовых значений

Следующий оператор выбирает все продукты с name `NOT BETWEEN` `'Красный телефон'` и `'Серебристая клавиатура'`:

[source,sql]
----
SELECT * FROM product
WHERE name NOT BETWEEN 'Красный телефон' AND 'Серебристая клавиатура'
ORDER BY name;
----

=== Пример `BETWEEN` с датами

Следующий оператор SQL выбирает все счета с помощью `date BETWEEN`.

[source,sql]
----
SELECT * FROM invoice
WHERE date BETWEEN #21.10.2017# AND #22.10.2017#;
----

== Псевдонимы `Aliases`

*SQL-псевдонимы* используются для предоставления таблицы или столбца таблицы временного имени. Псевдонимы часто используются, чтобы сделать имена столбцов более читабельными. Псевдоним существует только для продолжительности запроса.

Псевдонимы могут быть полезны, когда:

* В запросе содержится более одной таблицы
* Функции используются в запросе
* Названия столбцов большие или не очень читаемые
* Два или более столбца объединяются вместе

*Синтаксис:*

[source,sql]
----
SELECT column_name AS alias_name
FROM table_name;
----

*Синтаксис таблицы псевдонимов:*

[source,sql]
----
SELECT column_name(s)
FROM table_name AS alias_name;
----

=== Псевдоним для столбцов

Следующий оператор создает два псевдонима: один для столбца `user_id` и один для столбца `name`:

*Пример:*

[source,sql]
----
SELECT user_id as ID, name AS user
FROM users;
----

Следующий оператор создает два псевдонима: один для столбца `name` и один для столбца `address`:

[source,sql]
----
SELECT name AS user, address AS [Address User]
FROM users;
----

=== Псевдонимы для таблиц

Следующий оператор выбирает все счета от пользователя с помощью `user_id` и `name`. В запросе используются таблицы `users` и `invoice`, которым даются псевдонимы таблиц `u` и `o`:

[source,sql]
----
SELECT i.invoice_id, i.date, i.name
FROM users AS u, invoice AS i
WHERE u.name = "Том" AND u.user_id = i.user_id;
----

== Предложение `JOIN`

Предложение `JOIN` используется для объединения строк из двух или более таблиц на основе соответствующего столбца между ними.

Существует несколько типов `JOIN` в *SQL*:

* `(INNER) JOIN` - возвращает записи, имеющие соответствующие значения в обеих таблицах
* `LEFT (OUTER) JOIN` - возвращает все записи из левой таблицы и соответствующие записи из правой таблицы
* `RIGHT (OUTER) JOIN` - вернуть все записи из правой таблицы и сопоставленные записи из левой таблицы
* `FULL (OUTER) JOIN` - возвращает все записи, когда есть совпадение в левой или правой таблице

=== `INNER JOIN`

Ключевое слово `INNER JOIN` выбирает записи, имеющие соответствующие значения в обеих таблицах

*Синтаксиc:*

[source,sql]
----
SELECT column_name(s)
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример:*

.Таблица users
[options="header"]
|===
|user_id|name|fullname
|1|Ник|Никольский
|2|Майк|Майкович
|===

.Таблица invoice
[options="header"]
|===
|invoice_id|user_id|product_id
|1|1|7
|2|2|12
|===

Столбец `user_id` в таблице `invoice` ссылается на `user_id` в таблице `invoice` между которыми осуществляется взаимосвязь. Для выбора записей, имеющие соответствующие значения в обеих таблицах используется следующий запрос:

[source,sql]
----
SELECT invoice.invoice_id, users.name
FROM Orders
INNER JOIN users ON invoice.user_id = users.user_id;
----

==== `JOIN Three` таблиц

Следующий оператор выбирает все счета с информацией о пользователях и отправителях:

*Пример:*

[source,sql]
----
SELECT invoice.invoice, users.name, addresser.name
FROM ((invoice
INNER JOIN users ON invoice.user_id = users.user_id)
INNER JOIN addresser ON invoice.addresser_id = addresser.addresser_id);
----

== Ключевое слово `LEFT JOIN`

Ключевое слово `LEFT JOIN` возвращает все записи из левой таблицы и сопоставленные записи из правой таблицы. Результат равен `NULL` с правой стороны, если нет совпадения.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример*, следующий оператор выберет всех пользователей и любые заказы, которые они могут иметь:

[source,sql]
----
SELECT users.name, invoice.invoice_id
FROM users
LEFT JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;
----

== Ключевое слово `RIGHT JOIN`

Ключевое слово `RIGHT JOIN` возвращает все записи из правой таблицы и сопоставленные записи из левой таблицы. Результат равен `NULL` с левой стороны, когда нет совпадения.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table1
RIGHT JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример*, следующий оператор вернет всех пользователей и любые заказы, которые они могли бы разместить.

[source,sql]
----
SELECT invoice.invoice_id, users.name, users.fullname
FROM invoice
RIGHT JOIN users ON invoice.user_id = users.user_id
ORDER BY invoice.invoice_id;
----

== Ключевое слово `FULL OUTER JOIN`

Ключевое слово `FULL OUTER JOIN` возвращает все записи, когда есть совпадение в обеих таблицах таблицы или справа.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2 ON table1.column_name = table2.column_name;
----

*Пример*, следующий оператор выбирает всех пользователей и все заказы:

[source,sql]
----
SELECT users.name, invoice.invoice_id
FROM users
FULL OUTER JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;
----

== Регулярное соединение `Self JOIN`

`Self JOIN` - это регулярное соединение, но таблица соединяется сама с собой.

*Синтаксис:*

[source,sql]
----
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
----

*Пример*, следующий оператор соответствует пользователям из одного города:

[source,sql]
----
SELECT A.name AS name1, B.name AS name2, A.city
FROM users A, users B
WHERE A.user_id <> B.user_id
AND A.city = B.city
ORDER BY A.city;
----

== Оператор `UNION`

Оператор `UNION` используется для объединения результирующего набора из двух или более операторов `SELECT`. Каждый оператор `SELECT` в `UNION` должен иметь одинаковое количество столбцов. Столбцы также должны иметь похожие типы данных и в каждой инструкции `SELECT` быть в том же порядке.

=== Синтаксис `UNION`

[source,sql]
----
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
----

=== Пример `UNION`

Следующий оператор выбирает все разные города (только отдельные значения) от `users` и `delivery`:

[source,sql]
----
SELECT city FROM users
UNION
SELECT city FROM delivery
ORDER BY city;
----

=== Синтаксис `UNION ALL`

Оператор `UNION` по умолчанию выбирает только разные значения. Чтобы разрешить повторяющиеся значения, используйте `UNION ALL`:

[source,sql]
----
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
----

=== Пример `UNION ALL`

Следующий оператор выбирает все города (дублирующиеся значения также) из `users` и `delivery`:

[source,sql]
----
SELECT city FROM users
UNION ALL
SELECT city FROM delivery
ORDER BY city;
----

=== Оператор `UNION` с `WHERE`

Следующий оператор выбирает все разные испанские города (только отдельные значения) от `users` и `delivery`:

[source,sql]
----
SELECT city, country FROM users
WHERE country='Spain'
UNION
SELECT city, country FROM delivery
WHERE country='Spain'
ORDER BY city;
----

=== Оператор `UNION ALL` с `WHERE`

Следующий оператор выбирает все испанские города (повторяющиеся значения) также из `users` и `delivery`:

[source,sql]
----
SELECT city, country FROM users
WHERE country='Spain'
UNION ALL
SELECT city, country FROM delivery
WHERE country = 'Spain'
ORDER BY city;
----

== Заявление `GROUP BY`

Оператор `GROUP BY` часто используется с агрегатными функциями (`COUNT`, `MAX`, `MIN`, `SUM`, `AVG`) для группировки результирующего набора одним или несколькими столбцами.

=== Синтаксис `GROUP BY`

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
----

=== Пример SQL `GROUP BY`

В следующем выражении указано количество пользователей в каждой стране:

[source,sql]
----
SELECT COUNT(use_id), country
FROM users
GROUP BY country;
----

В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированных по высоким и низким:

[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
ORDER BY COUNT(user_id) DESC;
----

=== Оператор`GROUP BY` с `JOIN`

В следующем выражении указано количество заказов, отправленных каждой службой доставки:

[source,sql]
----
SELECT delivery.name, COUNT(invoice.delivery_id) AS orders FROM invoice
LEFT JOIN delivery ON invoice.delivery_id = delivery.delivery_id
GROUP BY name;
----

== Предложение `HAVING`

Предложение `HAVING` используется в SQL, для работы с агрегатными функциями, так как `WHERE` не могло с ними использоваться.

*Синтаксис:*`
[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
----

*Пример*, в следующем SQL-заявлении указано количество пользователей в каждой стране. Включать только страны с более чем 7 клиентами:

[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) > 7;
----

В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированные по высоким и низким.

[source,sql]
----
SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) > 7
ORDER BY COUNT(user_id) DESC;
----

== Оператор `EXISTS`

Оператор `EXISTS` используется для проверки существования любой записи в подзапросе. Если подзапрос возвращает одну или несколько записей, то возвращается `true`.

=== Синтаксис `EXISTS`

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
----

=== Примеры использования `EXISTS`

Следующий оператор возвращает `TRUE` и перечисляет доставки с ценой товара менее `1000`:

[source,sql]
----
SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price < 1000);
----

Следующий оператор SQL возвращает `TRUE` и перечисляет доставки с ценой товара `5000`.

[source,sql]
----
SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price = 5000);
----

== Операторы `ANY` и `ALL`

Операторы `ANY` и `ALL` используются с предложением `WHERE` или `HAVING`. Оператор `ANY` возвращает `true`, если какое-либо из значений подзапроса соответствует условию. Оператор `ALL` возвращает `true`, если все значения подзапроса удовлетворяют условию.

=== Синтаксис `ANY`

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
----

=== Пример `ANY`

Оператор `ANY` возвращает `TRUE`, если какое-либо из значений подзапроса соответствует условию. Следующий оператор возвращает `TRUE` и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице `info`, с количеством = `15`:

[source,sql]
----
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts = 15)
----

Следующий оператор возвращает `TRUE` и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице `info`, с количеством > `15`:

[source,sql]
----
SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts > 15);
----

=== Синтаксис `ALL`

[source,sql]
----
SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);
----

=== Пример `ALL`

Оператор `ALL` возвращает `TRUE`, если все значения подзапроса удовлетворяют условию.

Следующий оператор возвращает `TRUE` и перечисляет имена товаров, если ВСЕ записи в таблице `info` имеют количество = `7`:

[source,sql]
----
SELECT name
FROM product
WHERE product_id = ALL (SELECT product_id FROM info WHERE couns =7);
----

== Заявление `SELECT INTO`

Оператор `SELECT INTO` копирует данные из одной таблицы в новую таблицу.

=== Синтаксис `SELECT INTO`

Скопировать все столбцы в новую таблицу:

[source,sql]
----
SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Скопировать только несколько столбцов в новую таблицу:

[source,sql]
----
SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Новая таблица будет создана с именами и типами столбцов, как определено в старой таблице. Можно создавать новые имена столбцов, используя предложение `AS`.

=== Примеры SQL `SELECT INTO`

Следующий оператор SQL создает резервную копию `users`:

[source,sql]
----
SELECT * INTO usersBackup001
FROM users;
----

Следующий оператор использует предложение `IN` для копирования таблицы в новую таблицу в другой базе данных:

[source,sql]
----
SELECT * INTO usersBackup001 IN 'backup.mdb'
FROM users;
----

Следующий оператор копирует только несколько столбцов в новую таблицу:

[source,sql]
----
SELECT name, fullname INTO usersBackup001
FROM users;
----

== Оператор `INSERT INTO SELECT`

Оператор `INSERT INTO SELECT` копирует данные из одной таблицы и вставляет ее в другую таблицу. `INSERT INTO SELECT` требует, чтобы типы данных в исходной и целевой таблицах соответствовали.

Синтаксис `INSERT IN SELECT`
Скопировать все столбцы из одной таблицы в другую:

[source,sql]
----
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
----

Скопировать только несколько столбцов из одной таблицы в другую таблицу:

[source,sql]
----
INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
----

=== Пример SQL `INSERT INTO SELECT`

Следующий оператор копирует `clients` в `users` (столбцы, которые не заполнены данными, будет содержать `NULL`):

[source,sql]
----
INSERT INTO users (nme, fullname, balance)
SELECT nme, fullname, balance FROM clients;
----

== Оператор `ALTER TABLE`

Оператор `ALTER TABLE` используется для добавления, удаления или изменения столбцов в существующей таблице, а также для добавления и удаления различных ограничений для существующей таблицы.

=== `ALTER TABLE - ADD Column`

Чтобы добавить столбец в таблицу, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE table_name
ADD column_name datatype;
----

=== `ALTER TABLE - DROP COLUMN`

Чтобы удалить столбец в таблице, используйте следующий синтаксис, обратите внимание, что некоторые системы баз данных не позволяют удалить столбец:

[source,sql]
----
ALTER TABLE table_name
DROP COLUMN column_name;
----

=== `ALTER TABLE - ALTER/MODIFY COLUMN`

Чтобы изменить тип данных столбца в таблице, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
----

[source,sql]
----
ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
----

=== Изменить тип данных

Изменим тип данных столбца с именем `day_birth` в таблице `users`.

[source,sql]
----
ALTER TABLE users
ALTER COLUMN day_birth year;
----

=== Пример `DROP COLUMN`

Для удаления столбца `day_birth` в таблице `users` используется следующее:

[source,sql]
----
ALTER TABLE users
DROP COLUMN day_birth;
----

== Ограничения

*Ограничения* могут быть указаны при создании таблицы с помощью оператора `CREATE TABLE` или после создания таблицы с помощью инструкции `ALTER TABLE`.

*Синтаксис:*

[source,sql]
----
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);
----

*SQL-ограничения* используются для указания правил данных таблицы, для ограничения типа данных, которые могут входить в таблицу. Это обеспечивает точность и надежность данных в таблице. Если между ограничением и действием данных существует какое-либо нарушение, действие прерывается.

Ограничения могут быть уровнями столбцов или таблиц. Ограничения уровня столбца применяются к столбцу, а ограничения уровня таблиц относятся ко всей таблице.

В SQL обычно используются следующие ограничения:

* `NOT NULL` - гарантирует, что столбец не может иметь значение NULL
* `UNIQUE` - обеспечивает, чтобы все значения в столбце были разными
* `PRIMARY KEY` - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице
* `FOREIGN KEY` - однозначно идентифицирует строку / запись в другой таблице
* `CHECK` - обеспечивает, чтобы все значения в столбце удовлетворяли конкретному условию
* `DEFAULT` - устанавливает значение по умолчанию для столбца, если не указано значение
* `INDEX` - используется для быстрого создания и извлечения данных из базы данных

== Ограничение `NOT NULL`

По умолчанию столбец может содержать значения `NULL`. Ограничение `NOT NULL` приводит к тому, что столбец НЕ принимает значения `NULL`. Это приводит к тому, что поле всегда содержит значение, а это означает, что нельзя вставить новую запись или обновить запись без добавления значения в это поле.

Следующий SQL-запрос гарантирует, что столбцы `user_id`, `name` и `fullname` НЕ будут принимать значения `NULL`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255) NOT NULL,
balanse int
);
----

== Ограничение `UNIQUE`

Ограничение `UNIQUE` гарантирует, что все значения в столбце отличаются. Ограничения `UNIQUE` и `PRIMARY KEY` гарантируют уникальность столбца или набора столбцов. Ограничение `PRIMARY KEY` автоматически имеет ограничение `UNIQUE`.

Однако для каждой таблицы может быть множество ограничений `UNIQUE`, но только одно ограничение `PRIMARY KEY` для каждой таблицы.

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
UNIQUE (user_id)
);
----

===  Создание ограничения `UNIQUE` когда таблица уже создана

Чтобы создать ограничение `UNIQUE` в столбце `user_id`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD UNIQUE (user_id);
----

Чтобы назвать ограничение `UNIQUE` и определить ограничение `UNIQUE` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT UC_Users UNIQUE (user_id, name);
----

=== Удаление ограничения `UNIQUE`

Чтобы удалить ограничение `UNIQUE`, используйте следующий SQL-запрос:

[source,sql]
----
ALTER TABLE users
DROP INDEX UC_Users;
----

== Ограничение `PRIMARY KEY`

Ограничение `PRIMARY KEY` однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать `UNIQUE` значения и не могут содержать значения `NULL`.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

=== Создание `PRIMARY KEY` при создании таблицы

Следующий SQL-запрос создает `PRIMARY KEY` в столбце `user_id`, когда создается таблица `users`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
PRIMARY KEY (user_id)
);
----

Чтобы разрешить именовать ограничение `PRIMARY KEY` и определить ограничение `PRIMARY KEY` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE users (
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    CONSTRAINT PK_Users PRIMARY KEY (user_id, name)
);
----

=== Создание ограничения `PRIMARY KEY` когда таблица уже создана

Чтобы создать ограничение `PRIMARY KEY` в столбце `user_id`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD PRIMARY KEY (user_id);
----

Чтобы разрешить именовать ограничение `PRIMARY `KEY` и определить ограничение `PRIMARY KEY` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT PK_Users PRIMARY KEY (user_id, name);
----

=== Удаление ограничения `PRIMARY KEY

Чтобы удалить ограничение `PRIMARY KEY`, используйте следующее:
[source,sql]
----
ALTER TABLE users
DROP PRIMARY KEY;
----

== Ограничение `FOREIGN KEY`

`FOREIGN KEY` - это *ключ*, используемый для соединения двух таблиц вместе. Является полем (или набором полей) в одной таблице, которое ссылается на `PRIMARY KEY` в другой таблице.

Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ-кандидат, называется *ссылочной* или *родительской таблицей*.

=== Создание `FOREIGN KEY` при создании таблицы

Следующий SQL-запрос создает `FOREIGN KEY` в столбце `user_id` при создании таблицы `invoice`:

[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
FOREIGN KEY (user_id) REFERENCES users(user_id)
);
----

Чтобы разрешить именовать ограничение `FOREIGN KEY` и определять ограничение `FOREIGN KEY` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE invoice (
invoice_id int NOT NULL,
number int NOT NULL,
user_id int,
PRIMARY KEY (invoice_id),
CONSTRAINT FK_UserInvoice FOREIGN KEY (user_id)
REFERENCES Users(user_id)
);
----

===  Создание ограничения `FOREIGN KEY` когда таблица уже создана

Чтобы создать ограничение `FOREIGN KEY` в столбце `user_id`, когда таблица `invoice` уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE invoice
ADD FOREIGN KEY (user_id) REFERENCES Users(user_id);
----

Чтобы разрешить именовать ограничение `FOREIGN KEY` и определять ограничение `FOREIGN KEY` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE invoice
ADD CONSTRAINT FK_UsersInvoice
FOREIGN KEY (user_id) REFERENCES Users(user_id);
----

=== Удаление ограничения `FOREIGN KEY`

Чтобы удалить ограничение `FOREIGN KEY`, используйте следующий:

[source,sql]
----
ALTER TABLE invoice
DROP FOREIGN KEY FK_UsersInvoice;
----

== Ограничение `CHECK`

Ограничение `CHECK` используется для ограничения диапазона значений, который может быть помещен в столбец. Если определяется ограничение `CHECK` для одного столбца, оно допускает только определенные значения для этого столбца. Если определяется ограничение `CHECK` для таблицы, оно может ограничить значения в определенных столбцах на основе значений в других столбцах в строке.

=== Создание ограничения `CHECK` при создании таблицы

Следующий SQL-запрос создает ограничение `CHECK` в столбце `age`, когда создается таблица «users». Ограничение `CHECK` гарантирует, не может быть пользователя с возрастом старше 60 лет:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
CHECK (age>=60)
);
----

Чтобы разрешить именовать ограничение `CHECK` и определить ограничение `CHECK` для нескольких столбцов, используйте следующий синтаксис SQL:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
age int,
balance int,
CONSTRAINT CHK_Users CHECK (age>=60 AND balance = 500)
);
----

=== Создание ограничения `CHECK` когда таблица уже создана

Чтобы создать ограничение `CHECK` в столбце `age`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ADD CHECK (age>=60);
----

Чтобы разрешить именовать ограничение `CHECK` и определить ограничение `CHECK` для нескольких столбцов, используйте следующий синтаксис:

[source,sql]
----
ALTER TABLE users
ADD CONSTRAINT CHK_UsersAge CHECK (age>=60 AND country='Spain');
----

=== `DROP CHECK`

Чтобы удалить ограничение `CHECK`, используйте следующий SQL:

[source,sql]
----
ALTER TABLE users
DROP CHECK CHK_UsersAge;
----

== Ограничение `DEFAULT`

Ограничение `DEFAULT` используется для предоставления значения по умолчанию для столбца. Значение по умолчанию будет добавлено ко всем новым записям, если другое значение не указано.

=== Установка `DEFAULT` столбца при создании таблицы

Следующий SQL-запрос устанавливает значение `DEFAULT` для столбца `country`, когда создается таблица `users`:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL,
name varchar(255) NOT NULL,
fullname varchar(255),
gender int,
country varchar(255) DEFAULT 'Spain'
);
----

=== Установка `DEFAULT` столбца в уже созданной таблице

Чтобы создать ограничение `DEFAULT` в столбце `country`, когда таблица уже создана, используйте следующее:

[source,sql]
----
ALTER TABLE users
ALTER country SET DEFAULT 'Spain';
----

=== Удаление ограничения `DEFAULT`

Чтобы удалить ограничение `DEFAULT`, используйте следующее:

[source,sql]
----
ALTER TABLE users
ALTER country DROP DEFAULT;
----

== Ограничение `CREATE INDEX`

Оператор `CREATE INDEX` используется для создания индексов в таблицах. Индексы используются для быстрого извлечения данных из базы данных. Пользователи не могут видеть индексы, они просто используются для ускорения поиска/запросов.

=== Синтаксис `CREATE INDEX`

`CREATE INDEX` создает индекс в таблице. Допускаются повторяющиеся значения:

[source,sql]
----
CREATE INDEX index_name
ON table_name (column1, column2, ...);
----

=== Синтаксис `CREATE UNIQUE INDEX`

Создает уникальный индекс в таблице. Дублирующие значения не допускаются:

[source,sql]
----
CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
----

=== Пример `CREATE INDEX`

В приведенной ниже инструкции SQL создается индекс с именем `ind_name` в столбце `name` в таблице `users`:

[source,sql]
----
CREATE INDEX ind_name
ON users (name);
----

Если необходимо создать индекс в комбинации столбцов, можно указать имена столбцов в круглых скобках, разделенные запятыми:

[source,sql]
----
CREATE INDEX ind_name
ON users (name, fullname);
----

== Оператор `DROP INDEX`

Оператор `DROP INDEX` используется для удаления индекса в таблице.

[source,sql]
----
ALTER TABLE table_name
DROP INDEX index_name;
----

== Поле `AUTO INCREMENT`

`Auto-increment` позволяет создавать уникальный номер автоматически, когда новая запись вставляется в таблицу. Часто это поле основного ключа, которое необходимо создать автоматически каждый раз, когда будет вставлена новая запись.

=== Синтаксис для `MySQL`

Следующий оператор SQL определяет столбец `user_id` как поле первичного ключа с автоматическим приращением в таблице «users»:

[source,sql]
----
CREATE TABLE users (
user_id int NOT NULL AUTO_INCREMENT,
name varchar(255) NOT NULL,
fullname varchar(255),
balance int,
PRIMARY KEY (user_id)
);
----

MySQL использует ключевое слово `AUTO_INCREMENT` для выполнения функции автоматического увеличения.

По умолчанию начальное значение для `AUTO_INCREMENT` равно `1`, и оно будет увеличиваться на 1 для каждой новой записи.

Чтобы последовательность `AUTO_INCREMENT` начиналась с другого значения, используйте следующий оператор:

[source,sql]
----
ALTER TABLE users AUTO_INCREMENT = 7;
----

Чтобы вставить новую запись в таблицу `user`, нам не нужно указывать значение для столбца `user_id`, так как уникальное значение будет добавляться автоматически:

[source,sql]
----
INSERT INTO users (name, fullname)
VALUES ('Том','Эдисон');
----

== Работа с датами

Пока ваши данные содержат только часть даты, ваши запросы будут работать должным образом. Однако, если задействована временная часть, она становится более сложной.

=== Типы данных `SQL Date`

MySQL имеет следующие типы данных для хранения даты или значения даты/времени в базе данных:

* `DATE` - формат: `YYYY-MM-DD`
* `DATETIME` - формат: `YYYY-MM-DD HH:MI:SS`
* `TIMESTAMP` - формат: `YYYY-MM-DD HH:MI:SS`
* `YEAR` - формат: `YYYY` or `YY`

==  Однострочные и многострочные комментарии

Комментарии используются для пояснения разделов операторов SQL или для предотвращения выполнения операторов во время отладки запросов.

=== Однострочные комментарии

Однострочные комментарии начинаются со знака `-`. Любой текст между `-` и концом строки будет проигнорирован (не будет выполнен).

В следующем примере в качестве объяснения используется однострочный комментарий:

[source,sql]
----
-- Select all:
SELECT * FROM users;
----

В следующем примере используется однострочный комментарий для игнорирования конца строки:

[source,sql]
----
SELECT * FROM users -- WHERE balance = 1000;
----

В следующем примере используется однострочный комментарий для игнорирования оператора:

[source,sql]
----
-- SELECT * FROM users
SELECT * FROM users;
----

=== Многострочные комментарии

Многострочные комментарии начинаются с `/` и заканчиваются на `/`. Любой текст между `/` и `/` будет проигнорирован. В следующем примере в качестве объяснения используется многострочный комментарий:

[source,sql]
----
/* Этот запрос
выведет данные
всех пользователей */

SELECT * FROM users;
----

В следующем примере используется многострочный комментарий для игнорирования многих операторов:

[source,sql]
----
/*SELECT * FROM users;
SELECT * FROM product;
SELECT * FROM invoice;*/

SELECT * FROM category;
----

== Операторы

.Арифметические операторы SQL
[options="header"]
|===
|Оператор|Описание
|`+`|Добавление
|`-`|Вычитание
|`*`|Умножение
|`/`|Деление
|`%`|Модуль
|===

.Побитовые операции SQL
[options="header"]
|===
|Оператор|Описание
|`&`|Побитовое М
|/||Побитовое ИЛИ
|`^`|Побитовое исключение ИЛИ
|===

.Операторы сравнения SQL
[options="header"]
|===
|Оператор|Описание
|`=`|Равно
|`>`|Больше
|`<`|Меньше
|`>=`|Больше или равно
|`\<=`|Меньше или равно
|`<>`|Не равно
|===

.Составные операторы SQL
[options="header"]
|===
|Оператор|Описание
|`+=` |Добавить равно
|`-=`|Вычесть равно
|`*=`|Умножить равно
|`/=`|Разделить равно
|`%=`|Модуль равно
|`&=`|Побитовое И равно
|`^-=`|Побитовое исключающее равно
|`\|*=` |Побитовое ИЛИ равно
|===

.Логические операторы SQL
[options="header"]
|===
|Оператор|Описание
|`ALL` |Если все значения подзапроса являются TRUE
|`AND`|Если все условия, разделенные И, являются TRUE
|`ANY`|Если какое-либо из значений подзапроса соответствует TRUE условию
|`BETWEEN`|	Если операнд находится в диапазоне сравнения
|`EXISTS`|Если подзапрос возвращает одну или несколько записей
|`IN`|	Если операнд равен одному из списка выражений
|`LIKE`|	Если операнд соответствует шаблону
|`NOT`|	Отображает запись, если условие (И) НЕ TRUE
|`OR`|Если любое из условий, разделенных OR, является TRUE.
|`SOME`|	Если какое-либо из значений подзапроса соответствует условию
|===

== Функции

.Функции
[options="header"]
|===
|Функция|Описание
|`ASCII`|Возвращает числовой код, который представляет конкретный символ
|`CHAR_LENGTH`|Возвращает длину указанной строки (в символах)
|`CHARACTER_LENGTH`|Возвращает длину указанной строки (в символах)
|`CONCAT`|Объединяет два или более выражения вместе
|`CONCAT_WS`|Объединяет два или более выражения вместе и добавляет разделитель между ними
|`FIELD`|Возвращает позицию значения в списке значений
|`FIND_IN_SET`|Возвращает позицию строки в списке строк
|`FORMAT`|Форматирует число как формат «#, ###. ##», округляя его до определенного количества знаков после запятой
|`INSERT`|Вставляет подстроку в строку в указанной позиции для определенного количества символов
|`INSTR`|Возвращает позицию первого вхождения строки в другую строку
|`LCASE`|Преобразует строку в нижний регистр
|`LEFT`|Извлекает подстроку из строки (начиная слева)
|`LENGTH`|Возвращает длину указанной строки (в байтах)
|`LOCATE`|Возвращает позицию первого вхождения подстроки в строку
|`LOWER`|Преобразует строку в нижний регистр
|`LPAD`|Возвращает строку, которая добавлена в левую сторону с указанной строкой до определенной длины
|`LTRIM`|Удаляет ведущие пробелы из строки
|`MID`|Извлекает подстроку из строки (начиная с любой позиции)
|`POSITION`|Возвращает позицию первого вхождения подстроки в строку
|`REPEAT`|Повторяет строку определенное количество раз
|`REPLACE`|Заменяет все вхождения указанной строки
|`REVERSE`|Отменяет строку и возвращает результат
|`RIGHT`|Извлекает подстроку из строки (начиная справа)
|`RPAD`|Возвращает строку с правой строкой с определенной строкой до определенной длины
|`RTRIM`|Удаляет конечные пробелы из строки
|`SPACE`|Возвращает строку с заданным количеством пробелов
|`STRCMP`|Проверяет, одинаковы ли две строки
|`SUBSTR`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING_INDEX`|Возвращает подстроку  string и перед integer вхождений delimiter
|`TRIM`|Удаляет начальные и конечные пробелы из строки
|`UCASE`|Преобразует строку в верхний регистр
|`UPPER`|Преобразует строку в верхний регистр
|===

.Числовые функции
[options="header"]
|===
|Функция|Описание
|`ABS`|Возвращает абсолютное значение числа
|`ACOS`|Возвращает косинус дуги числа
|`ASIN`|Возвращает синус дуги числа
|`ATAN`|Возвращает тангенс дуги числа или дуги касательной n и m
|`ATAN2`|Возвращает тангенс дуги n и m
|`AVG`|Возвращает среднее значение выражения
|`CEIL`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`CEILING`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`COS`|Возвращает косинус числа
|`COT`|Возвращает котангенс числа
|`COUNT`|Возвращает количество записей в выбранном запросе
|`DEGREES`|Преобразует значение радиана в градусы
|`DIV`|Используется для целочисленного деления
|`EXP`|Возвращает e, поднятый до степени числа
|`FLOOR`|Возвращает наибольшее целочисленное значение, которое меньше или равно числу
|`GREATEST`|Возвращает наибольшее значение в списке выражений
|`LEAST`|Возвращает наименьшее значение в списке выражений
|`LN`|Возвращает натуральный логарифм числа
|`LOG`|Возвращает натуральный логарифм числа или логарифм числа к заданной базе
|`LOG10`|Возвращает логарифм базы-10 числа
|`LOG2`|Возвращает логарифм базы-2 числа
|`MAX`|Возвращает максимальное значение выражения
|`MIN`|Возвращает минимальное значение выражения
|`MOD`|Возвращает остаток n, деленный на m
|`PI`|Возвращает значение PI, отображаемое с шестью знаками после запятой
|`POW`|Возвращает m, поднятую до n-й степени
|`POWER`|Возвращает m, поднятую до n-й степени
|`RADIANS`|Преобразует значение в градусах в радианы
|`RAND`|Возвращает случайное число или случайное число в пределах диапазона
|`ROUND`|Возвращает число, округленное до определенного количества знаков после запятой
|`SIGN`|Возвращает значение, обозначающее знак числа
|`SIN`|Возвращает синус числа
|`SQRT`|Возвращает квадратный корень из числа
|`SUM`|Возвращает суммарное значение выражения
|`TAN`|Возвращает тангенс числа
|`TRUNCATE`|Возвращает число, усеченное до определенного количества знаков после запятой
|===

.Функции даты
[options="header"]
|===
|Функция|Описание
|`DATEDIFF`|Возвращает дату после добавления определенного интервала времени / даты
|`DATE_ADD`|Возвращает время / дату-время после добавления определенного временного интервала
|`DATE_FORMAT`|Возвращает текущую дату
|`DATE_SUB`|Возвращает текущую дату
|`DAY`|Возвращает текущее время
|`DAYNAME`|Возвращает текущую дату и время
|`DAYOFMONTH`|Возвращает текущее время
|`DAYOFWEEK`|Извлекает значение даты из выражения даты или даты и времени
|`DAYOFYEAR`|Возвращает разницу в днях между двумя значениями даты
|`EXTRACT`|Возвращает дату после добавления определенного интервала времени / даты
|`FROM_DAYS`|Форматирует дату, указанную маской формата
|`HOUR`|Возвращает дату после вычитания определенного интервала времени / даты
|`LAST_DAY`|Возвращает дневную часть значения даты
|`LOCALTIME`|Возвращает имя дня недели для даты
|`LOCALTIMESTAMP`|Возвращает дневную часть значения даты
|`MAKEDATE`|Возвращает индекс недели для значения даты
|`MAKETIME`|Возвращает день года для значения даты
|`MICROSECOND`|Извлекает части с даты
|`MINUTE`|Возвращает значение даты из числового представления дня
|`MONTH`|Возвращает часовую часть значения даты
|`MONTHNAME`|Возвращает последний день месяца на заданную дату
|`NOW`|Возвращает текущую дату и время
|`PERIOD_ADD`|Возвращает текущую дату и время
|`PERIOD_DIFF`|Возвращает дату определенного годового и дневного значения
|`QUARTER`|Возвращает время для определенного часа, минуты, второй комбинации
|`SECOND`|Возвращает микросекундную часть значения даты
|`SEC_TO_TIME`|Возвращает минутную часть значения даты
|`STR_TO_DATE`|Возвращает месячную часть значения даты
|`SUBDATE`|Возвращает полное название месяца для даты
|`SUBTIME`|Возвращает текущую дату и время
|`SYSDATE`|Принимает период и добавляет к нему определенное количество месяцев
|`TIME`|Возвращает разницу в месяцах между двумя периодами
|`TIME_FORMAT`|Возвращает четвертную часть значения даты
|`TIME_TO_SEC`|Возвращает вторую часть значения даты
|`TIMEDIFF`|Преобразует числовые секунды в значение времени
|`TIMESTAMP`|Принимает строку и возвращает дату, заданную маской формата
|`TO_DAYS`|Возвращает дату, после которой вычитается определенный интервал времени / даты
|`WEEK`|Возвращает значение time / datetime после вычитания определенного временного интервала
|`WEEKDAY`|Возвращает текущую дату и время
|`WEEKOFYEAR`|Извлекает значение времени из выражения time / datetime
|`YEAR`|Форматирует время, указанное маской формата
|`YEARWEEK`|Преобразует значение времени в числовые секунды
|===

.Расширенные функции
[options="header"]
|===
|Функция|Описание
|`BIN`|Преобразует десятичное число в двоичное число
|`BINARY`|Преобразует значение в двоичную строку
|`CASE`|Позволяет вам оценить условия и вернуть значение при выполнении первого условия
|`CAST`|Преобразует значение из одного типа данных в другой тип данных
|`COALESCE`|Возвращает первое ненулевое выражение в списке
|`CONNECTION_ID`|Возвращает уникальный идентификатор соединения для текущего соединения
|`CONV`|Преобразует число из одной базы чисел в другую
|`CONVERT`|Преобразует значение из одного типа данных в другой или один набор символов в другой
|`CURRENT_USER`|Возвращает имя пользователя и имя хоста для учетной записи MySQL, используемой сервером, для проверки подлинности текущего клиента
|`DATABASE`|Возвращает имя базы данных по умолчанию
|`IF`|Возвращает одно значение, если условие TRUE или другое значение, если условие FALSE
|`IFNULL`|Позволяет вернуть альтернативное значение, если выражение равно NULL
|`ISNULL`|Проверяет, является ли выражение NULL
|`LAST_INSERT_ID`|Возвращает первое значение AUTO_INCREMENT, заданное последним оператором INSERT или UPDATE
|`NULLIF`|Сравнивает два выражения
|`SESSION_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`SYSTEM_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MySQL
|`VERSION`|Возвращает версию базы данных MySQL
|===
