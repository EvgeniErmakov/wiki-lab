= Основные понятия
:sectnums:
:toc:

*SQL* - это язык структурированных запросов, с помощью которого можно обрабатывать и извлекать данные из реляционных баз данных.
Каждая строка, находящаяся в таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют ключом.
Столбцы таблицы имеют атрибуты данных, а каждая запись обычно содержит значение для каждого атрибута, что дает возможность легко устанавливать взаимосвязь между элементами данных.

== Типы данных

*Тип данных* — это атрибут, который определяет тип любого объекта.
SQL предлагает шесть категорий типов данных для использования.

=== Точные типы числовых данных

|===
|Тип данных |Возможные значения |Примечание

|bit
|0 или 1
|Фактически является аналогом булевого типа в языках программирования.
Занимает 1 байт.

|TINYINT
|От 0 до 255
|Занимает 1 байт.
Хорошо подходит для хранения небольших чисел.

|SMALLINT
|От –32 768 до 32 767
|Занимает 2 байта

|INT
|От –2 147 483 648 до 2 147 483 647
|Занимает 4 байта.
Наиболее используемый тип для хранения чисел.

|BIGINT
|От -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
|Занимают в памяти 8 байт.

|DECIMAL 2+^|Хранит числа c фиксированной точностью.
Занимает от 5 до 17 байт в зависимости от количества чисел после запятой.
Данный тип может принимать два параметра precision и scale: DECIMAL(precision, scale).
Параметр precision представляет максимальное количество цифр, которые может хранить число.
Это значение должно находиться в диапазоне от 1 до 38. По умолчанию оно равно 18. Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой.
Это значение должно находиться в диапазоне от 0 до значения параметра precision.
По умолчанию оно равно 0.

|MONEY
|Дробные значения от -922 337 203 685 477.5808 до 922 337 203 685 477.5807
|Представляет денежные величины и занимает 8 байт.

|SMALLMONEY
|Хранит дробные значения от -214 748.3648 до 214 748.3647
|Предназначено для хранения денежных величин.
Занимает 4 байта.
Эквивалентен типу DECIMAL(10,4).

|FLOAT
|Хранит числа от –1.79E+308 до 1.79E+308
|Занимает от 4 до 8 байт в зависимости от дробной части.

|REAL
|От –340E+38 to 3.40E+38
|Занимает 4 байта.
Эквивалентен типу FLOAT(24).

|===

Если необходимо получать из базы данных числовое значение в строго указанном формате, то для этого следует выбрать один из точных числовых типов данных.

=== Примерные типы числовых данных

|===
|Тип данных |Возможные значения

|float
|От -1.79E + 308, до 1.79E + 308

|real
|От -3.40E + 38, до 3.40E + 38

|===

Некоторые числа нельзя точно представить в десятичном виде с ограниченным числом знаков, например, одну треть или число пи.
Для записи таких чисел используются действительный (real) или плавающий (float) типы данных.
Данные действительного типа хранятся с точностью от 1 до 7 знаков.
Плавающий формат, который иногда называют еще форматом двойной точности, может хранить числа, содержащие от 8 до 15 значащих цифр.
Действительный и плавающий типы данных применяются в научных приложениях для хранения чисел, не требующих точного двоичного выражения.
Одна-две последние цифры могут не вполне точно сохраняться при преобразованиях в двоичный формат.

=== Типы данных даты и времени

|===
|Тип данных |Примечание

|datetime
|От 1 января 1753, до 31 декабря, 9999

|smalldatetime
|От 1 января 1900, до 6 июня 2079

|date
| Сохраняет дату, как 30 июня 1991 года

|time
|    Сохраняет время суток, как 12:30

|===

Для дат применяются два типа данных, datetime и smalldatetime.
Тип данных smalldatetime охватывает период времени от 1 января 1900 года до 6 июня 2079 года и включает время с точностью до минуты.
Такого диапазона достаточно для подавляющего большинства проектов.
Тип данных datetime годен для использования до 31 декабря 9999 года (это следует учитывать при решении проблемы 10К года).

=== Типы данных символьных строк

|===
|Тип данных |Возможные значения

|char
|Максимальная длина 8000 символов.
(Фиксированная длина без Unicode символов)

|varchar
| Максимум 8000 символов.
(Переменная длина данных не-Unicode).

|text
|Переменная длина данных, не Unicode с максимальной длиной 2147483647 символов.

|===

К этому типу относятся такие символьные данные, как имена или адреса.
Можно выбрать символьный тип данных либо фиксированной длины, char, либо переменной длины, varchar. Фиксированный размер оказывается предпочтительным в тех случаях, когда данные имеют одинаковую или сходную длину, например, при вводе идентификатора автора (часто в этом качестве используют индивидуальный номер системы социальной безопасности).
В большинстве ситуаций применение переменной длины данных не приводит к сколько-нибудь заметному увеличению времени обработки.
В то же время фамилия автора может быть очень длинной, так что использование типа varchar оказывается вполне оправданным.
Применительно к подавляющему большинству фамилий фиксированная длина поля означает потерю значительного объема памяти, поэтому лучше использовать тип данных varchar. При выборе того или иного типа данных всегда следует искать компромисс с учетом двух аспектов: с одной стороны, потери полезного объема памяти при использовании данных фиксированной длины, а с другой стороны, увеличения времени обработки в случае применения данных переменной длины.

=== Типы строк данных символов Unicode

|===
|Тип данных |Возможные значения

|nchar
|    Максимальная длина 4000 символов.
(Фиксированная длина Unicode)

|nvarchar
|Максимальная длина 4000 символов.
(Переменная длина Unicode)

|nvarchar(max)
|Максимальная длина 231 символов (SQL Server 2005).
(Переменная длина Unicode)

|ntext
|Максимальная длина 1,073,741,823 символов.
(Переменная длина Unicode)

|===

SQL Server 7.0 поддерживает набор символов Unicode.
В связи с этим, чтобы воспользоваться всеми преимуществами, предоставляемыми расширенными возможностями Unicode, необходимо было ввести дополнительный тип данных.
Если необходимо использовать символьные данные Unicode, то следует указать тип данных Nchar или, если это информация переменной длины, то Nvarchar.
При вводе данных Unicode их следует заключать в одиночные кавычки, причем непосредственно перед ними необходимо поставить заглавную латинскую букву N. Ограничение максимальной длины информации при работе с типом данных Unicode составляет 4000 знаков.
Это объясняется тем, что для хранения каждого символа Unicode требуется два байта памяти.
Поэтому на стандартную страницу памяти размером 8К можно поместить в два раза меньше символов Unicode, чем при использовании обычных символов.

=== Двоичные типы данных

|===
|Тип данных |Возможные значения

|binary
|Максимальная длина 8000 байт (фиксированная длина двоичных данных)

|varbinary
|Максимальная длина 8000 байт.
(Переменная длина двоичных данных)

|varbinary(max)
|Максимальная длина 231 байт (SQL Server 2005).
(Переменная длина двоичных данных)

|image
|Максимальная длина 2147483647 байт.
(Переменная длина двоичных данных)

|===

Если в базе данных необходимо хранить двоичную информацию, имеется выбор между двумя форматами представления: c фиксированной или переменной длиной.
Данным фиксированной длины соответствует тип данных binary, а двоичным данным переменной длины соответствует тип данных varbinary.

== Нормализация и денормализация баз данных

*Нормализация базы данных* - это процесс эффективной организации данных в базе данных.
Есть две причины процесса нормализации:

* Устранение избыточных данных, например, хранение тех же данных в более чем одной таблице.
* Обеспечение зависимостей данных.

*Денормализация* — намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.

Нормализация состоит из ряда принципов, которые помогают в создании хорошей структуры базы данных.
Эти принципы делятся на нормальные формы, их цель в организации структуры базы данных таким образом, чтобы правильно организовать структуру базы данных.

==== Первая нормальная форма

Правила первой нормальной формы:

* В таблице не должно быть дублирующих строк.
* В каждой ячейке таблицы хранится атомарное значение (одно не составное значение).
* В столбце хранятся данные одного типа.
* Нет упорядочивания строк сверху вниз (другими словами, порядок строк не несет в себе никакой информации).
* Нет упорядочивания столбцов слева направо (другими словами, порядок столбцов не несет в себе никакой информации).

Пример, допустим есть ненормализованная таблица:

|===
|ID покупателя |ФИО  |Заказ | Телефон

|10
|Егоров Егор
|Ноутбук Asus G53
| Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77

|10
|Егоров Егор
|Телефон Nokia 5310
| Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77

|10
|Егоров Егор
|Наушники LG 700
|Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77
|===

Такая таблица нарушает требования первой нормальной формы.
Ее следует разбить на две части, а затем соединить их с помощью ключа.

Информация о клиенте

|===
|ID покупателя |ФИО | Мобильный телефон | Домашний телефон

|10
|Егоров Егор
|44 888 77 77
|8-77-77

|===

Информация о заказах

|===
|ID заказа |ID клиента |Заказ

|1
|10
|Ноутбук Asus G53

|2
|10
|Телефон Nokia 5310

|3
|10
|Наушники LG 700
|===

Такие таблицы соответствуют требованиям первой нормальной формы.

==== Вторая нормальная форма

*Правило второй нормальной формы* звучит следующим образом:

Отношение соответствует второй нормальной форме, если оно соответствует первой нормальной форме и каждый не ключевой атрибут неприводимо зависит от первичного ключа.

|===
|ФИО |Должность |Подразделение

|Егоров Егор
|Программист
|Отдел разработки ПО

|Иванов Иван
|Бухгалтер
|Бухгалтерия

|Борисов Борис
|Продавец
|Отдел реализации
|===

Допустим в организации каждому сотруднику присваивается уникальный табельный номер, который никогда не будет изменен.
Таким образом, чтобы привести эту таблицу ко второй нормальной форме, необходимо добавить в нее еще один атрибут, т.е. столбец с табельным номером, который будет выступать первичным ключом.

|===
|Табельный номер |ФИО |Должность |Подразделение

|660
|Егоров Егор
|Программист
|Отдел разработки ПО

|212
|Иванов Иван
|Бухгалтер
|Бухгалтерия

|1024
|Борисов Борис
|Продавец
|Отдел реализации
|===

==== Третья нормальная форма

Отношение находится в третьей нормальной форме, когда находится во второй нормальной форме и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа.
Иначе говоря, третья нормальная форма требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

|===
|CourseID |Course |TeacherID |Teacher

|1
|Математика
|1
|Егоров Егор

|2
|Java
|2
|Иванов Иван

|3
|Алгоритмы
|2
|Иванов Иван

|===

Такую ненормализованную таблицу требуется разбить на две разные таблицы:

|===
|TeacherID |Teacher

|1
|Егоров Егор

|2
|Иванов Иван
|===

Таким образом в первой таблице TeacherID является ключом, явный указывающий на преподавателя.

|===
|CourseID |Course |    TeacherID

|1
|Математика
|1

|2
|Java
|2

|3
|Алгоритмы
|2
|===

== Ключи

*Ключ* — это колонка или колонки, не имеющие в строках дублирующих значений.

*Ключи бывают:*

* Первичные.
* Внешние.
* Составные

==== Первичный ключ

Столбец, который в базе данных должен быть уникальным помечают первичным ключом.
*Первичный ключ или primary key* означает, что в таблице значение колонки primary key не может повторяться.
Таким образом данный ключ позволяет однозначно идентифицировать запись в таблице не боясь при этом, что значение столбца повториться.
Допустим есть таблица студентов с полями: ФИО, год рождения.
Поскольку может возникнуть ситуация когда ФИО и год рождения совпадут сразу у нескольких студентов, верным решением будет внести в таблицу первичный ключ:

|===
|Первичный ключ |ФИО |Год рождения

|1
|Иванов Иван
|2001

|2
|Егоров Егор
|2002

|3
|Николаенко Николай
|2001

|===

==== Внешний ключ

Внешние ключи еще называют ссылочным, они необходимы для связывания таблиц между собой.

.Товары
|===
|Артикул |ID тип товара |Цена

|151687
|1
|104

|151605
|1
|42

|151690
|2
|77

|151601
|2
|90

|===

.Тип товара
|===
|ID |Тип товара

|1
|Джемпер

|2
|Футболка

|===

В таблице "Тип товара" внешним ключом будет поле "ID тип товара" в таблице "Товары".
Благодаря такой зависимости образуется связь между двумя таблицами.

==== Составной ключ

Бывают ситуации, когда при вставке в таблицу нужно проверять запись на уникальность сразу по нескольким полям.
*Составной ключ* — это несколько первичных ключей в таблице.
Таким образом, создав составной ключ, уникальность записи будет проверяться по полям, которые объединенные в этот ключ.

|===
|Город |№ школы |Директор |Адрес |Телефон
|Гомель
|1
|Иванов Иван
|Лесная, 2
|2-22-99

|Минск
|1
|Егоров Егор
|Солнечная, 4
|4-44-44

|Минск
|2
|Николаенко Николай
|Радужная, 1
|5-55-55
|===

Составной ключ может состоять и более чем из двух полей.
В таблице поля ГОРОД и НОМЕР ШКОЛЫ вместе образуют составной ключ.
В такой таблице у разных записей не могут совпасть одновременно два поля "ГОРОД" и "НОМЕР ШКОЛЫ", а номера школ совпасть могут.

== Блокировки

*Блокировки* - это механизм поддержки требований об изолированности транзакций.
Одновременный конкурентный доступ может вызывать разные отрицательные эффекты, например чтение несуществующих данных или потерю модифицированных данных.
Рассмотрим следующий практический пример:
Пользователь №1 из отдела кадров получает извещение, что сотрудник "Егор Егоров" поменял место жительства.
Он вносит соответствующее изменение в базу данных для данного сотрудника, но при просмотре другой информации об этом сотруднике он понимает, что изменил адрес не того человека.
Он нажимает кнопку отмены, уверенный в том, что данные после отмены операции изменения адреса уже не содержат никакой ошибки.
В то же самое время пользователь №2 в отделе проектирования обращается к данным второго сотрудника с именем Егор Егоров, чтобы отправить ему домой последнюю техническую документацию, поскольку этот служащий редко бывает в офисе.
Однако пользователь №2 обратился к базе данных после того, как адрес этого второго сотрудника с именем Егор Егоров был ошибочно изменен, но до того, как он был исправлен.
В результате письмо отправляется не тому адресату.
Чтобы предотвратить подобные проблемы, каждая система управления базами данных должна обладать механизмом для управления одновременным доступом к данным всеми пользователями.
Для обеспечения согласованности данных в случае одновременного обращения к данным несколькими пользователями, применяют блокировки.
Каждая прикладная программа блокирует требуемые ей данные, что гарантирует, что никакая другая программа не сможет модифицировать эти данные.
Когда другая прикладная программа пытается получить доступ к заблокированным данным для их модификации, то система или завершает эту попытку ошибкой, или заставляет программу ожидать снятия блокировки.

Режимы блокировки определяют разные типы блокировок.
Выбор определенного режима блокировки зависит от типа ресурса, который требуется заблокировать.
Для блокировок ресурсов уровня строки и страницы применяются следующие три типа блокировок:

=== Разделяемая блокировка (shared lock)

Резервирует ресурс только для чтения.
Другие процессы не могут изменять заблокированный таким образом ресурс, но несколько процессов могут одновременно считывать информацию или накладывать разделяемую блокировку на один и тот же ресурс.
Иными словами, чтение ресурса с разделяемой блокировкой могут одновременно выполнять несколько процессов.

=== Монопольная блокировка (exclusive lock)

Резервирует страницу или строку для монопольного использования одной транзакции.
Блокировка этого типа применяется такими инструкциями как _INSERT_, _UPDATE_ и _DELETE_, которые модифицируют ресурс.
Монопольную блокировку нельзя установить, если на ресурс уже установлена разделяемая или монопольная блокировка другим процессом, т.е. на ресурс может быть установлена только одна монопольная блокировка.

=== Блокировка обновления (update lock)

Является промежуточной между разделяемой блокировкой и монопольной.
Блокировка обновления устанавливается при намерении транзакции изменить данные, но при этом само изменение не происходит.
В этом случае другим транзакциям разрешается устанавливать разделяемые блокировки, но не позволяется устанавливать монопольные блокировки, до тех пор пока транзакция не завершится.

=== Блокировки намерения

Чтобы наложить монопольную блокировку на страницу данных, сервер должен убедиться, что ни на одну из записей, входящих в эту страницу, никакая блокировка не наложена.
То есть необходимо перебрать все записи, входящие в страницу, и проверить их на наличие блокировок.
То же самое, только в гораздо большем объеме, необходимо делать и для таблицы.
Это было бы достаточно дорогостоящей операцией, но тут на помощь приходят блокировки намерения.
Прежде чем ставить блокировку на конкретную запись, ставится соответствующая блокировка намерения на таблицу и страницу.
Таким образом, отпадает необходимость проверять все записи, достаточно проверить, есть ли блокировка намерения на соответствующем уровне иерархии.

== SQL-транзакции

*Транзакция* представляет собой единицу работы, которая выполняется с базой данных.
Транзакция является распространением одного или нескольких изменений в базу данных.
Например, если необходимо создать запись или выполнить обновление, удаление записи из таблицы, то выполняется транзакцию в этой таблице.
Важно контролировать эти операции, чтобы гарантировать целостность данных и обрабатывать ошибки базы данных.

==== Свойства транзакций

Транзакции имеют следующие четыре стандартных свойств, как правило, называют аббревиатурой ACID.

* *Atomicity* – гарантирует, что все операции в рамках единицы работы завершены успешно, иначе транзакция прерывается в точке выхода из строя, и все предыдущие операции откатываются в прежнее состояние.
* *Consistency* – гарантирует, что база данных правильно изменяет состояния на более успешное совершенные транзакции.
* *Isolation* – позволяет транзакции работать независимо и прозрачно друг с другом.
* *Durability* – гарантирует, что результат или эффект зафиксированной транзакции сохраняется в случае сбоя системы.

==== Управление транзакцией

Следующие команды используются для управления операциями.

* *COMMIT* – для сохранения изменений.
* *ROLLBACK* – откат изменений.
* *SAVEPOINT* – создает точки внутри групп операций, которые следует откатить.
* *SET TRANSACTION* – размещает имя транзакции.

== Простые SQL-запросы

=== Создание таблицы

Для того, чтобы создать таблицу в SQL, используется выражение CREATE TABLE.
Он принимает в качестве параметров все колонки, которые необходимо внести, а также их типы данных.
Пример создания таблицы с названием _"Months"_, в которой будет три колонки:
_id_ - порядковый номер месяца (целочисленный тип или int).
_name_ - название месяца.
_days_ - число дней в конкретном месяце.
Код создания будет выглядеть следующим образом:

----
CREATE TABLE months (id int, name varchar(10), days int);
----

=== INSERT INTO

*INSERT INTO* - этот запрос используется для добавления двумя разными способами новых строк данных в таблицу в базе данных.
*Способ первый:*

----
INSERT INTO months VALUES (1,'January',31);
----

Этот способ не подразумевает указания названий колонок, а лишь принимает значения в том порядке, в котором они указаны в таблице.
Однако, если в будущем необходимо добавить дополнительные колонки, все предыдущие запросы работать не будут.
Для решения данной проблемы следует использовать *второй способ*.
Его суть заключается в том, что перед вводом данных указываются названия колонок.

----
INSERT INTO months (id,name,days) VALUES (2,'February',29);
----

=== Select

*Select* - это запрос используемый в случае, если необходимо показать данные в таблице.

----
SELECT * FROM characters
----

Результатом данного запроса будет таблица со всеми данными в таблице characters.
Знак звёздочки (*) означает то, что необходимо показать все столбцы из таблицы без исключений.
Так как в базе данных обычно больше одной таблицы, нам необходимо указывать название таблицы, данные из которой требуетя посмотреть.
Сделать это можно используя ключевое слово FROM.
Когда необходимы лишь некоторые столбцы из таблицы, то можно указать их имена через запятую вместо звёздочки.

----
SELECT name, weapon FROM characters
----

=== Where

*Where* - это запрос позволяющий включить в вывод лишь некоторые конкретные строки.
Данное ключевое слово позволяет фильтровать данные по определённому условию.
Например:

----
SELECT *
FROM characters
WHERE weapon = 'pistol';
----

В следующем запросе выведутся те персонажи, которые в качестве оружия используют пистолет.

=== Операторы AND & OR

Операторы _AND & OR_ условия в _WHERE_ могут быть написаны с использованием логических операторов (AND/OR) и математические операторы сравнения (=, <, >, <=, >=, <>).
К примеру есть табличка, в которой записаны данные о четырех самых продаваемых музыкальных альбомах всех времён.
Давайте выведем только те, жанром которых является рок, а продажи были меньше, чем 50 миллионов копий.

----
SELECT *
FROM albums
WHERE genre = 'rock' AND sales_in_millions <= 50
ORDER BY released
----

=== In/Between/Like

Условия в _WHERE_ могут быть записаны с использованием ещё нескольких команд, которыми являются:

* *IN* — сравнивает значение в столбце с несколькими возможными значениями и возвращает true, если значение совпадает хотя бы с одним значением
* *BETWEEN* — проверяет, находится ли значение в каком-то промежутке.
* *LIKE* — ищет по шаблону.

К примеру, можно сделать запрос для вывода данных об альбомах в жанре pop или soul:

----
SELECT * FROM albums WHERE genre IN (‘pop’,‘soul’);
----

Если необходимо вывести все альбомы, которые были выпущены в промежутке между 1975 и 1985 годом, можно использовать следующую запись:

----
SELECT * FROM albums WHERE released BETWEEN 1975 AND 1985;
----

Также, если необходимо вывести все альбомы, в названии которых есть буква ‘R’, можно использовать следующую запись:

----
SELECT * FROM albums WHERE album LIKE ‘%R%’;
----

Знак % означает любую последовательность символов (0 символов тоже считается за последовательность).
Если необходимо вывести все альбомы, первая буква в названии которых — ‘R’, то запись слегка изменится:

----
SELECT * FROM albums WHERE album LIKE ‘R%’;
----

В SQL также есть инверсия.
Для этого достаточно написать _NOT_ перед любым логическим выражением в условии (NOT BETWEEN и так далее).

=== Update

Зачастую необходимо изменить данные в таблице.
В SQL это делается с помощью *UPDATE*.

Использование *UPDATE* включает в себя выбор таблицы, в которой находится поле подлежащее изменению.
Запись нового значения осуществляется с помощью запроса _WHERE_, чтобы обозначить конкретное место в таблице.
Предположим есть таблица с самыми высокооценёнными сериалами всех времён.
Однако в ней есть несоответствие: «Игра Престолов» обозначена как комедия, изменим значение поля следующим запросом:

----
UPDATE tv_series
SET genre = 'drama'
WHERE name = 'Game of Thrones';
----

=== Удаление записей из таблицы

Удаление записи из таблицы через SQL - очень простая операция.
Всё, что нужно - это обозначить, что необходимо удалить.

----
DELETE FROM tv_series
WHERE id = 4;
----

Примечание: необходимо убедиться что используется запрос _WHERE_, когда происходит удаление записи из таблицы.
Иначе удалятся все записи.

=== Удаление таблиц

Если необходимо все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду *TRUNCATE*:

----
TRUNCATE TABLE table_name;
----

В случае, если необходимо удалить саму таблицу, то следует использовать команду *DROP*:

----
DROP TABLE table_name;
----
